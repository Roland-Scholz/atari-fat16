ca65 V2.17 - Git 59ab140
Main file   : ..\src\fat16.a65
Current file: ..\src\fat16.a65

000000r 1               DEBUG .set 0
000000r 1               
000000r 1               .macro	cmp_icbalz_y
000000r 1               	.IF PLATFORM=0
000000r 1               		CMP [ICBALZ],Y
000000r 1               	.ELSE
000000r 1               		CMP (ICBALZ),Y
000000r 1               	.ENDIF
000000r 1               .endmacro
000000r 1               
000000r 1               .macro	lda_icbalz_y
000000r 1               	.IF PLATFORM=0
000000r 1               		LDA [ICBALZ],Y
000000r 1               	.ELSE
000000r 1               		LDA (ICBALZ),Y
000000r 1               	.ENDIF
000000r 1               .endmacro
000000r 1               
000000r 1               .macro	sta_icbalz_y
000000r 1               	.IF PLATFORM=0
000000r 1               		STA [ICBALZ],Y
000000r 1               	.ELSE
000000r 1               		STA (ICBALZ),Y
000000r 1               	.ENDIF
000000r 1               .endmacro
000000r 1               
000000r 1               	.IF PLATFORM = 2 || PLATFORM = 4
000000r 1               		.include "atarixl.inc"
000000r 2               ;	SPACE	4,10
000000r 2               ;***	Copyright 1984 ATARI.  Unauthorized reproduction, adaptation,
000000r 2               ;*	distribution, performance or display of this computer program
000000r 2               ;*	or the associated audiovisual work is strictly prohibited.
000000r 2               ;	SPACE	4,10
000000r 2               ;***	OS - Operating System
000000r 2               ;*
000000r 2               ;*	NOTES
000000r 2               ;*		This represents an attempt to bring the OS :
000000r 2               ;*		into conformance with the Atari Internal So:
000000r 2               ;*		Standards as defined in the Software Develo:
000000r 2               ;*		Committee Report on Procedures And Standard:
000000r 2               ;*		(10/27/81).  Due to time constraints, the e:
000000r 2               ;*		source could not be brought up to the stand:
000000r 2               ;*		particularly in the area of subroutine head:
000000r 2               ;*		documentation (ENTRY, EXIT, CHANGES and CAL:
000000r 2               ;*		More complete and consistent conformance to:
000000r 2               ;*		standard is planned for the next revision o:
000000r 2               ;*		Operating System (Revision 3).
000000r 2               ;*
000000r 2               ;*	MODS
000000r 2               ;*		Revision A (400/800)
000000r 2               ;*		D. Crane/A. Miller/L. Kaplan/R. Whitehead
000000r 2               ;*
000000r 2               ;*		Revision B (400/800)
000000r 2               ;*		Fix several problems.
000000r 2               ;*		M. Mahar/R. S. Scheiman
000000r 2               ;*
000000r 2               ;*		Revision 10 (1200XL)
000000r 2               ;*		Support 1200XL, add new features.
000000r 2               ;*		H. Stewart/L. Winner/R. S. Scheiman/
000000r 2               ;*		Y. M. Chen/M. W. Colburn	10/26/82
000000r 2               ;*
000000r 2               ;*		Revision 11 (1200XL)
000000r 2               ;*		Fix several problems.
000000r 2               ;*		R. S. Scheiman	12/23/82
000000r 2               ;*
000000r 2               ;*		Revision 1 (600XL/800XL)
000000r 2               ;*		Support PBI and on-board BASIC.
000000r 2               ;*		R. S. Scheiman/R. K. Nordin/Y. M. Chen	03/11/83
000000r 2               ;*
000000r 2               ;*		Revision 2 (600XL/800XL)
000000r 2               ;*		Fix several problems.
000000r 2               ;*		R. S. Scheiman	05/10/83
000000r 2               ;*		Bring closer to Coding Standard (object unchanged).
000000r 2               ;*		R. K. Nordin	11/01/83
000000r 2               
000000r 2               
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Program Structure
000000r 2               ;*
000000r 2               ;*	The sections of the OS appear in the following order with
000000r 2               ;*	corresponding subtitles:
000000r 2               ;*
000000r 2               ;*	Equates and Definitions
000000r 2               ;*
000000r 2               ;*		System Symbol Equates
000000r 2               ;*		System Address Equates
000000r 2               ;*		Miscellaneous Address Equates
000000r 2               ;*		Macro Definitions
000000r 2               ;*
000000r 2               ;*	Code and Data
000000r 2               ;*
000000r 2               ;*		First 8K ROM Identification and Checksum
000000r 2               ;*
000000r 2               ;*		Interrupt Handler
000000r 2               ;*		Initialization
000000r 2               ;*		Disk Input/Ouput
000000r 2               ;*		Relocating Loader
000000r 2               ;*		Self-test, Part 1
000000r 2               ;*		Parallel Input/Output
000000r 2               ;*		Peripheral Handler Loading Facility, Part 1
000000r 2               ;*		Self-test, Part 2
000000r 2               ;*		Peripheral Handler Loading Facility, Part 2
000000r 2               ;*
000000r 2               ;*		International Character Set
000000r 2               ;*
000000r 2               ;*		Self-test, Part 3
000000r 2               ;*		Floating Point Package
000000r 2               ;*
000000r 2               ;*		Domestic Character Set
000000r 2               ;*
000000r 2               ;*		Device Handler Vector Tables
000000r 2               ;*		Jump Vectors
000000r 2               ;*		Generic Parallel Device Handler Vector Table
000000r 2               ;*
000000r 2               ;*		$E4C0 Patch
000000r 2               ;*		Central Input/Output
000000r 2               ;*		Peripheral Handler Loading Facility, Part 3
000000r 2               ;*		$E912 Patch
000000r 2               ;*		Peripheral Handler Loading Facility, Part 4
000000r 2               ;*		$E959 Patch
000000r 2               ;*		Serial Input/Output
000000r 2               ;*		Keyboard, Editor and Screen Handler, Part 1
000000r 2               ;*		Peripheral Handler Loading Facility, Part 5
000000r 2               ;*		$EF6B Patch
000000r 2               ;*		Keyboard, Editor and Screen Handler, Part 2
000000r 2               ;*		$F223 Patch
000000r 2               ;*		Keyboard, Editor and Screen Handler, Part 3
000000r 2               ;*		$FCD8 Patch
000000r 2               ;*		Cassette Handler
000000r 2               ;*		Printer Handler
000000r 2               ;*		Self-test, Part 4
000000r 2               ;*
000000r 2               ;*		Second 8K ROM Identification and Checksum
000000r 2               ;*		6502 Machine Vectors
000000r 2               ;	SUBTTL	'System Symbol Equates'
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Assembly Option Equates
000000r 2               
000000r 2               
000000r 2               FALSE	=	0
000000r 2               TRUE	=	1
000000r 2               
000000r 2               .define	VGC	TRUE	;virtual game controllers
000000r 2               .define	RAMSYS	FALSE	;not RAM based system
000000r 2               .define	LNBUG	FALSE	;no LNBUG interface
000000r 2               .define	ACMI	FALSE	;no asynchronous communications mod:
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Identification Equates
000000r 2               
000000r 2               
000000r 2               IDREV	=	$02	;identification revision number
000000r 2               IDDAY	=	$10	;identification day
000000r 2               IDMON	=	$05	;identification month
000000r 2               IDYEAR	=	$83	;identification year
000000r 2               IDCPU	=	$02	;identification CPU series
000000r 2               IDPN1	=	'B'	;identification part number field 1
000000r 2               IDPN2	=	'B'	;identification part number field 2
000000r 2               IDPN3	=	$00	;identification part number field 3
000000r 2               IDPN4	=	$00	;identification part number field 4
000000r 2               IDPN5	=	$01	;identification part number field 5
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Configuration Equates
000000r 2               ;*
000000r 2               ;*	NOTES
000000r 2               ;*		Problem: last byte of HATABS (as defined by:
000000r 2               ;*		overlaps first power-up validation byte.
000000r 2               
000000r 2               
000000r 2               MAXDEV	=	33	;offset to last possible entry of HATABS
000000r 2               IOCBSZ	=	16	;length of IOCB
000000r 2               
000000r 2               SEIOCB	=	0*IOCBSZ	;screen editor IOCB index
000000r 2               MAXIOC	=	8*IOCBSZ	;first invalid IOCB index
000000r 2               
000000r 2               DSCTSZ	=	128	;disk sector size
000000r 2               
000000r 2               LEDGE	=	2	;left edge
000000r 2               REDGE	=	39	;right edge
000000r 2               
000000r 2               INIML	=	$0700	;initial MEMLO
000000r 2               
000000r 2               ICSORG	=	$CC00	;international character set origin
000000r 2               DCSORG	=	$E000	;domestic character set origin
000000r 2               ;	SPACE	4,10
000000r 2               ;**	IOCB Command Code Equates
000000r 2               
000000r 2               
000000r 2               OPEN	=	$03	;open
000000r 2               GETREC	=	$05	;get record
000000r 2               GETCHR	=	$07	;get character(s)
000000r 2               PUTREC	=	$09	;put record
000000r 2               PUTCHR	=	$0B	;put character(s)
000000r 2               CLOSE	=	$0C	;close
000000r 2               STATIS	=	$0D	;status
000000r 2               SPECIL	=	$0E	;special
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Special Entry Command Equates
000000r 2               
000000r 2               
000000r 2               ;	Screen Commands
000000r 2               
000000r 2               DRAWLN	=	$11	;draw line
000000r 2               FILLIN	=	$12	;draw line with right fill
000000r 2               ;	SPACE	4,10
000000r 2               ;**	ICAX1 Auxiliary Byte 1 Equates
000000r 2               
000000r 2               
000000r 2               APPEND	=	$01	;open write append (D:) or screen read (E:)
000000r 2               DIRECT	=	$02	;open for directory access (D:)
000000r 2               OPNIN	=	$04	;open for input (all devices)
000000r 2               OPNOT	=	$08	;open for output (all devices)
000000r 2               MXDMOD	=	$10	;open for mixed mode (E:, S:)
000000r 2               INSCLR	=	$20	;open for input without clearing screen (E:, S:)
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Device Code Equates
000000r 2               
000000r 2               
000000r 2               CASSET	=	'C'	;cassette
000000r 2               DISK	=	'D'	;disk
000000r 2               SCREDT	=	'E'	;screen editor
000000r 2               KBD	=	'K'	;keyboard
000000r 2               PRINTR	=	'P'	;printer
000000r 2               DISPLY	=	'S'	;screen display
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Character and Key Code Equates
000000r 2               
000000r 2               
000000r 2               CLS	=	$7D	;clear screen
000000r 2               EOL	=	$9B	;end of line (RETURN)
000000r 2               
000000r 2               HELP	=	$11	;key code for HELP
000000r 2               CNTLF1	=	$83	;key code for CTRL-F1
000000r 2               CNTLF2	=	$84	;key code for CTRL-F2
000000r 2               CNTLF3	=	$93	;key code for CTRL-F3
000000r 2               CNTLF4	=	$94	;key code for CTRL-F4
000000r 2               CNTL1	=	$9F	;key code for CTRL-1
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Status Code Equates
000000r 2               
000000r 2               
000000r 2               SUCCES	=	1	;successful operation
000000r 2               
000000r 2               BRKABT	=	128	;BREAK key abort
000000r 2               PRVOPN	=	129	;IOCB already open error
000000r 2               NONDEV	=	130	;nonexistent device error
000000r 2               WRONLY	=	131	;IOCB opened for write only error
000000r 2               NVALID	=	132	;invalid command error
000000r 2               NOTOPN	=	133	;device/file not open error
000000r 2               BADIOC	=	134	;invalid IOCB index error
000000r 2               RDONLY	=	135	;IOCB opened for read only error
000000r 2               EOFERR	=	136	;end of file error
000000r 2               TRNRCD	=	137	;truncated record error
000000r 2               TIMOUT	=	138	;peripheral device timeout error
000000r 2               DNACK	=	139	;device does not acknowledge command error
000000r 2               FRMERR	=	140	;serial bus framing error
000000r 2               CRSROR	=	141	;cursor overrange error
000000r 2               OVRRUN	=	142	;serial bus data overrun error
000000r 2               CHKERR	=	143	;serial bus checksum error
000000r 2               DERROR	=	144	;device done (operation incomplete) error
000000r 2               BADMOD	=	145	;bad screen mode number error
000000r 2               FNCNOT	=	146	;function not implemented in handler error
000000r 2               SCRMEM	=	147	;insufficient memory for screen mode error
000000r 2               
000000r 2               ;**	DCB Device Bus ID Equates
000000r 2               
000000r 2               
000000r 2               DISKID	=	$31	;disk bus ID
000000r 2               PDEVN	=	$40	;printer bus ID
000000r 2               CASET	=	$60	;cassette bus ID
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Bus Command Equates
000000r 2               
000000r 2               
000000r 2               FOMAT	=	'!'	;format command
000000r 2               PUTSEC	=	'P'	;put sector command
000000r 2               READ	=	'R'	;read command
000000r 2               STATC	=	'S'	;status command
000000r 2               WRITE	=	'W'	;write command
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Command Auxiliary Byte Equates
000000r 2               
000000r 2               
000000r 2               DOUBLE	=	'D'	;print 20 characters double width
000000r 2               NORMAL	=	'N'	;print 40 characters normally
000000r 2               PLOT	=	'P'	;plot
000000r 2               SIDWAY	=	'S'	;print 16 characters sideways
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Bus Response Equates
000000r 2               
000000r 2               
000000r 2               ACK	=	'A'	;device acknowledged
000000r 2               COMPLT	=	'C'	;device successfully completed operation
000000r 2               ERROR	=	'E'	;device incurred error in attempted operation
000000r 2               NACK	=	'N'	;device did not understand
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Floating Point Package Miscellaneous Equates
000000r 2               
000000r 2               
000000r 2               FPREC	=	6	;precision
000000r 2               
000000r 2               FMPREC	=	FPREC-1	;length of mantissa
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Cassette Record Type Equates
000000r 2               
000000r 2               
000000r 2               HDR	=	$FB	;header
000000r 2               DTA	=	$FC	;data record
000000r 2               DT1	=	$FA	;last data record
000000r 2               EOT	=	$FE	;end of tape (file)
000000r 2               
000000r 2               TONE1	=	2	;record
000000r 2               TONE2	=	1	;playback
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Cassette Timing Equates
000000r 2               
000000r 2               
000000r 2               WLEADN	=	1152	;NTSC 19.2 second WRITE file leader
000000r 2               RLEADN	=	576	;NTSC 9.6 second READ file leader
000000r 2               WIRGLN	=	180	;NTSC 3.0 second WRITE IRG
000000r 2               RIRGLN	=	120	;NTSC 2.0 second READ IRG
000000r 2               WSIRGN	=	15	;NTSC 0.25 second WRITE short IRG
000000r 2               RSIRGN	=	10	;NTSC 0.16 second READ short IRG
000000r 2               BEEPNN	=	30	;NTSC 0.5 second beep duration
000000r 2               BEEPFN	=	10	;NTSC 0.16 second beep separation
000000r 2               
000000r 2               WLEADP	=	960	;PAL 19.2 second WRITE file leader
000000r 2               RLEADP	=	480	;PAL 9.6 second READ file leader
000000r 2               WIRGLP	=	150	;PAL 3.0 second WRITE IRG
000000r 2               RIRGLP	=	100	;PAL 2.0 second READ IRG
000000r 2               WSIRGP	=	13	;PAL 0.25 second WRITE short IRG
000000r 2               RSIRGP	=	8	;PAL 0.16 second READ short IRG
000000r 2               BEEPNP	=	25	;PAL 0.5 second beep duration
000000r 2               BEEPFP	=	8	;PAL 0.16 second beep separation
000000r 2               
000000r 2               WIRGHI	=	0	;high WRITE IRG
000000r 2               RIRGHI	=	0	;high READ IRG
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Power-up Validation Byte Value Equates
000000r 2               
000000r 2               
000000r 2               PUPVL1	=	$5C	;power-up validation value 1
000000r 2               PUPVL2	=	$93	;power-up validation value 2
000000r 2               PUPVL3	=	$25	;power-up validation value 3
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Relocating Loader Miscellaneous Equates
000000r 2               
000000r 2               
000000r 2               DATAER	=	156	;end of record appears before END r:
000000r 2               MEMERR	=	157	;memory insufficient for load error
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Miscellaneous Equates
000000r 2               
000000r 2               
000000r 2               IOCFRE	=	$FF	;IOCB free indicator
000000r 2               
000000r 2               B19200	=	$0028	;19200 baud POKEY counter value
000000r 2               B00600	=	$05CC	;600 baud POKEY counter value
000000r 2               
000000r 2               HITONE	=	$05	;FSK high freq. POKEY counter value (5326 Hz)
000000r 2               LOTONE	=	$07	;FSK low freq. POKEY counter value (3995 Hz)
000000r 2               
000000r 2               NCOMLO	=	$34	;PIA lower NOT COMMAND line command
000000r 2               NCOMHI	=	$3C	;PIA raise NOT COMMAND line command
000000r 2               
000000r 2               MOTRGO	=	$34	;PIA cassette motor ON command
000000r 2               MOTRST	=	$3C	;PIA cassette motor OFF command
000000r 2               
000000r 2               NODAT	=	$00	;SIO immediate operation
000000r 2               GETDAT	=	$40	;SIO read data frame
000000r 2               PUTDAT	=	$80	;SIO write data frame
000000r 2               
000000r 2               CRETRI	=	13	;number of command frame retries
000000r 2               DRETRI	=	1	;number of device retries
000000r 2               CTIM	=	2	;command frame ACK timeout
000000r 2               
000000r 2               NBUFSZ	=	40	;print normal buffer size
000000r 2               DBUFSZ	=	20	;print double buffer size
000000r 2               SBUFSZ	=	29	;print sideways buffer size
000000r 2               ;	SUBTTL	'System Address Equates'
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Page Zero Address Equates
000000r 2               
000000r 2               
000000r 2               LNFLG	=	$0000	;1-byte LNBUG flag (0 = not LNBUG)
000000r 2               NGFLAG	=	$0001	;1-byte memory status (0 = failure)
000000r 2               
000000r 2               ;	Not Cleared
000000r 2               
000000r 2               CASINI	=	$0002	;2-byte cassette program initialization address
000000r 2               RAMLO	=	$0004	;2-byte RAM address for memory test
000000r 2               TRAMSZ	=	$0006	;1-byte RAM size temporary
000000r 2               CMCMD	=	$0007	;1-byte command communications
000000r 2               
000000r 2               ;	Cleared upon Coldstart Only
000000r 2               
000000r 2               WARMST	=	$0008	;1-byte warmstart flag (0 = coldstart)
000000r 2               BOOT	=	$0009	;1-byte successful boot flags
000000r 2               DOSVEC	=	$000A	;2-byte disk program start vector
000000r 2               DOSINI	=	$000C	;2-byte disk program initialization address
000000r 2               APPMHI	=	$000E	;2-byte applications memory high limit
000000r 2               
000000r 2               ;	Cleared upon Coldstart or Warmstart
000000r 2               
000000r 2               INTZBS	=	$0010	;first page zero location to clear
000000r 2               
000000r 2               POKMSK	=	$0010	;1-byte IRQEN shadow
000000r 2               BRKKEY	=	$0011	;1-byte BREAK key flag (0 = no BREAK)
000000r 2               RTCLOK	=	$0012	;3-byte real time clock (16 millisecond units)
000000r 2               BUFADR	=	$0015	;2-byte disk interface buffer address
000000r 2               ICCOMT	=	$0017	;1-byte CIO command table index
000000r 2               DSKFMS	=	$0018	;2-byte DOS File Management System pointer
000000r 2               DSKUTL	=	$001A	;2-byte DOS utility pointer
000000r 2               ABUFPT	=	$001C	;4-byte ACMI buffer pointer area
000000r 2               
000000r 2               ZIOCB	=	$0020	;address of page zero IOCB
000000r 2               IOCBAS	=	$0020	;16-byte page zero IOCB
000000r 2               ICHIDZ	=	$0020	;1-byte handler ID ($FF = IOCB free)
000000r 2               ICDNOZ	=	$0021	;1-byte device number
000000r 2               ICCOMZ	=	$0022	;1-byte command code
000000r 2               ICSTAZ	=	$0023	;1-byte status of last action
000000r 2               ICBALZ	=	$0024	;1-byte low buffer address
000000r 2               ICBAHZ	=	$0025	;1-byte high buffer address
000000r 2               ICPTLZ	=	$0026	;1-byte low PUT-BYTE routine address-1
000000r 2               ICPTHZ	=	$0027	;1-byte high PUT-BYTE routine address-1
000000r 2               ICBLLZ	=	$0028	;1-byte low buffer length
000000r 2               ICBLHZ	=	$0029	;1-byte high buffer length
000000r 2               ICAX1Z	=	$002A	;1-byte first auxiliary information
000000r 2               ICAX2Z	=	$002B	;1-byte second auxiliary information
000000r 2               ICSPRZ	=	$002C	;4-byte spares
000000r 2               
000000r 2               ENTVEC	=	$002C	;2-byte (not used)
000000r 2               ICIDNO	=	$002E	;1-byte IOCB index (IOCB number times IOCBSZ)
000000r 2               CIOCHR	=	$002F	;1-byte character for current CIO operation
000000r 2               
000000r 2               STATUS	=	$0030	;1-byte SIO operation status
000000r 2               CHKSUM	=	$0031	;1-byte checksum (single byte sum with carry)
000000r 2               BUFRLO	=	$0032	;1-byte low data buffer address
000000r 2               BUFRHI	=	$0033	;1-byte high data buffer address
000000r 2               BFENLO	=	$0034	;1-byte low data buffer end address
000000r 2               BFENHI	=	$0035	;1-byte high data buffer end address
000000r 2               LTEMP	=	$0036	;2-byte relocating loader temporary
000000r 2               BUFRFL	=	$0038	;1-byte data buffer full flag (0 = not full)
000000r 2               RECVDN	=	$0039	;1-byte receive-frame done flag (0 = not done)
000000r 2               XMTDON	=	$003A	;1-byte transmit-frame done flag (0 = not done)
000000r 2               CHKSNT	=	$003B	;1-byte checksum sent flag (0 = not sent)
000000r 2               NOCKSM	=	$003C	;1-byte no checksum follows data flag (0 = does)
000000r 2               BPTR	=	$003D	;1-byte cassette buffer pointer
000000r 2               FTYPE	=	$003E	;1-byte cassette IRG type (neg. = continuous)
000000r 2               FEOF	=	$003F	;1-byte cassette EOF flag (0 = no EOF)
000000r 2               FREQ	=	$0040	;1-byte cassette beep counter
000000r 2               SOUNDR	=	$0041	;1-byte noisy I/O flag (0 = quiet)
000000r 2               
000000r 2               CRITIC	=	$0042	;1-byte critical section flag (0 = not critical)
000000r 2               
000000r 2               FMSZPG	=	$0043	;7-byte reserved for DOS File Management System
000000r 2               
000000r 2               ZCHAIN	=	$004A	;2-byte handler linkage chain point:
000000r 2               DSTAT	=	$004C	;1-byte display status
000000r 2               ATRACT	=	$004D	;1-byte attract-mode timer and flag
000000r 2               DRKMSK	=	$004E	;1-byte attract-mode dark (luminance) mask
000000r 2               COLRSH	=	$004F	;1-byte attract-mode color shift
000000r 2               TMPCHR	=	$0050	;1-byte	temporary character
000000r 2               HOLD1	=	$0051	;1-byte	temporary
000000r 2               LMARGN	=	$0052	;1-byte text column left margin
000000r 2               RMARGN	=	$0053	;1-byte text column right margin
000000r 2               ROWCRS	=	$0054	;1-byte cursor row
000000r 2               COLCRS	=	$0055	;2-byte cursor column
000000r 2               DINDEX	=	$0057	;1-byte display mode
000000r 2               SAVMSC	=	$0058	;2-byte saved memory scan counter
000000r 2               OLDROW	=	$005A	;1-byte prior row
000000r 2               OLDCOL	=	$005B	;2-byte prior column
000000r 2               OLDCHR	=	$005D	;1-byte saved character under cursor
000000r 2               OLDADR	=	$005E	;2-byte saved cursor memory address
000000r 2               FKDEF	=	$0060	;2-byte function key definition tab:
000000r 2               PALNTS	=	$0062	;1-byte PAL/NTSC indicator (0 = NTS:
000000r 2               LOGCOL	=	$0063	;1-byte logical line cursor column
000000r 2               ADRESS	=	$0064	;2-byte temporary address
000000r 2               
000000r 2               MLTTMP	=	$0066	;1-byte temporary
000000r 2               OPNTMP	=	$0066	;1-byte open temporary
000000r 2               TOADR	=	$0066	;2-byte destination address
000000r 2               
000000r 2               SAVADR	=	$0068	;2-byte saved address
000000r 2               FRMADR	=	$0068	;2-byte source address
000000r 2               
000000r 2               RAMTOP	=	$006A	;1-byte RAM size
000000r 2               BUFCNT	=	$006B	;1-byte buffer count (logical line size)
000000r 2               BUFSTR	=	$006C	;2-byte buffer start pointer
000000r 2               BITMSK	=	$006E	;1-byte bit mask for bit map operation
000000r 2               SHFAMT	=	$006F	;1-byte shift amount for pixel justification
000000r 2               ROWAC	=	$0070	;2-byte draw working row
000000r 2               COLAC	=	$0072	;2-byte draw working column
000000r 2               ENDPT	=	$0074	;2-byte end point
000000r 2               DELTAR	=	$0076	;1-byte row difference
000000r 2               DELTAC	=	$0077	;2-byte column difference
000000r 2               KEYDEF	=	$0079	;2-byte key definition table addres:
000000r 2               SWPFLG	=	$007B	;1-byte split screen swap flag (0 = not swapped)
000000r 2               HOLDCH	=	$007C	;1-byte temporary character
000000r 2               INSDAT	=	$007D	;1-byte temporary
000000r 2               COUNTR	=	$007E	;2-byte draw iteration count
000000r 2               
000000r 2               ;	Reserved for Application and Floating Point Package
000000r 2               
000000r 2               ;	=	$0080	;128 bytes reserved for application and FPP
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Floating Point Package Page Zero Address Equates
000000r 2               
000000r 2               
000000r 2               FR0	=	$00D4	;6-byte register 0
000000r 2               FR0M	=	$00D5	;5-byte register 0 mantissa
000000r 2               QTEMP	=	$00D9	;1-byte temporary
000000r 2               
000000r 2               FRE	=	$00DA	;6-byte (internal) register E
000000r 2               
000000r 2               FR1	=	$00E0	;6-byte register 1
000000r 2               FR1M	=	$00E1	;5-byte register 1 mantissa
000000r 2               
000000r 2               FR2	=	$00E6	;6-byte (internal) register 2
000000r 2               
000000r 2               FRX	=	$00EC	;1-byte temporary
000000r 2               
000000r 2               EEXP	=	$00ED	;1-byte value of exponent
000000r 2               
000000r 2               FRSIGN	=	$00EE	;1-byte floating point sign
000000r 2               NSIGN	=	$00EE	;1-byte sign of number
000000r 2               
000000r 2               PLYCNT	=	$00EF	;1-byte polynomial degree
000000r 2               ESIGN	=	$00EF	;1-byte sign of exponent
000000r 2               
000000r 2               SGNFLG	=	$00F0	;1-byte sign flag
000000r 2               FCHFLG	=	$00F0	;1-byte first character flag
000000r 2               
000000r 2               XFMFLG	=	$00F1	;1-byte transform flag
000000r 2               DIGRT	=	$00F1	;1-byte number of digits after decimal point
000000r 2               
000000r 2               CIX	=	$00F2	;1-byte current input index
000000r 2               INBUFF	=	$00F3	;2-byte line input buffer
000000r 2               
000000r 2               ZTEMP1	=	$00F5	;2-byte temporary
000000r 2               ZTEMP4	=	$00F7	;2-byte temporary
000000r 2               ZTEMP3	=	$00F9	;2-byte temporary
000000r 2               
000000r 2               FLPTR	=	$00FC	;2-byte floating point number pointer
000000r 2               FPTR2	=	$00FE	;2-byte floating point number pointer
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Page One (Stack) Address Equates
000000r 2               
000000r 2               
000000r 2               ;	=	$0100	;256-byte stack
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Page Two Address Equates
000000r 2               
000000r 2               
000000r 2               INTABS	=	$0200	;42-byte interrupt handler table
000000r 2               
000000r 2               VDSLST	=	$0200	;2-byte display list NMI vector
000000r 2               VPRCED	=	$0202	;2-byte serial I/O proceed line IRQ vector
000000r 2               VINTER	=	$0204	;2-byte serial I/O interrupt line IRQ vector
000000r 2               VBREAK	=	$0206	;2-byte BRK instruction IRQ vector
000000r 2               VKEYBD	=	$0208	;2-byte keyboard IRQ vector
000000r 2               VSERIN	=	$020A	;2-byte serial input ready IRQ vector
000000r 2               VSEROR	=	$020C	;2-byte serial output ready IRQ vector
000000r 2               VSEROC	=	$020E	;2-byte serial output complete IRQ vector
000000r 2               VTIMR1	=	$0210	;2-byte POKEY timer 1 IRQ vector
000000r 2               VTIMR2	=	$0212	;2-byte POKEY timer 2 IRQ vector
000000r 2               VTIMR4	=	$0214	;2-byte POKEY timer 4 IRQ vector
000000r 2               VIMIRQ	=	$0216	;2-byte immediate IRQ vector
000000r 2               CDTMV1	=	$0218	;2-byte countdown timer 1 value
000000r 2               CDTMV2	=	$021A	;2-byte countdown timer 2 value
000000r 2               CDTMV3	=	$021C	;2-byte countdown timer 3 value
000000r 2               CDTMV4	=	$021E	;2-byte countdown timer 4 value
000000r 2               CDTMV5	=	$0220	;2-byte countdown timer 5 value
000000r 2               VVBLKI	=	$0222	;2-byte immediate VBLANK NMI vector
000000r 2               VVBLKD	=	$0224	;2-byte deferred VBLANK NMI vector
000000r 2               CDTMA1	=	$0226	;2-byte countdown timer 1 vector
000000r 2               CDTMA2	=	$0228	;2-byte countdown timer 2 vector
000000r 2               
000000r 2               CDTMF3	=	$022A	;1-byte countdown timer 3 flag (0 = expired)
000000r 2               SRTIMR	=	$022B	;1-byte software key repeat timer
000000r 2               CDTMF4	=	$022C	;1-byte countdown timer 4 flag (0 = expired)
000000r 2               INTEMP	=	$022D	;1-byte temporary
000000r 2               CDTMF5	=	$022E	;1-byte countdown timer 5 flag (0 = expired)
000000r 2               SDMCTL	=	$022F	;1-byte DMACTL shadow
000000r 2               SDLSTL	=	$0230	;1-byte DLISTL shadow
000000r 2               SDLSTH	=	$0231	;1-byte DLISTH shadow
000000r 2               SSKCTL	=	$0232	;1-byte SKCTL shadow
000000r 2               LCOUNT	=	$0233	;1-byte relocating loader record le:
000000r 2               LPENH	=	$0234	;1-byte light pen horizontal value
000000r 2               LPENV	=	$0235	;1-byte light pen vertical value
000000r 2               BRKKY	=	$0236	;2-byte BREAK key vector
000000r 2               VPIRQ	=	$0238	;2-byte parallel device IRQ vector
000000r 2               CDEVIC	=	$023A	;1-byte command frame device ID
000000r 2               CCOMND	=	$023B	;1-byte command frame command
000000r 2               CAUX1	=	$023C	;1-byte command auxiliary 1
000000r 2               CAUX2	=	$023D	;1-byte command auxiliary 2
000000r 2               
000000r 2               TEMP	=	$023E	;1-byte temporary
000000r 2               
000000r 2               ;	ASSERT	low TEMP<>$FF	;may not be the last word on a page
000000r 2               
000000r 2               ERRFLG	=	$023F	;1-byte I/O error flag (0 = no error)
000000r 2               
000000r 2               ;	ASSERT	low ERRFLG<>$FF ;may not be the last word on a page
000000r 2               
000000r 2               DFLAGS	=	$0240	;1-byte disk flags from sector 1
000000r 2               DBSECT	=	$0241	;1-byte disk boot sector count
000000r 2               BOOTAD	=	$0242	;2-byte disk boot memory address
000000r 2               COLDST	=	$0244	;1-byte coldstart flag (0 = complete)
000000r 2               RECLEN	=	$0245	;1-byte relocating loader record le:
000000r 2               DSKTIM	=	$0246	;1-byte disk format timeout
000000r 2               PDVMSK	=	$0247	;1-byte parallel device selection mask
000000r 2               SHPDVS	=	$0248	;1-byte PDVS (parallel device selec:
000000r 2               PDIMSK	=	$0249	;1-byte parallel device IRQ selection mask
000000r 2               RELADR	=	$024A	;2-byte relocating loader relative :
000000r 2               PPTMPA	=	$024C	;1-byte parallel device handler tem:
000000r 2               PPTMPX	=	$024D	;1-byte parallel device handler tem:
000000r 2               
000000r 2               ;	=	$024E	;6 bytes reserved for Atari
000000r 2               
000000r 2               ;	=	$0254	;23 bytes reserved for Atari
000000r 2               
000000r 2               CHSALT	=	$026B	;1-byte character set alternate
000000r 2               VSFLAG	=	$026C	;1-byte fine vertical scroll count
000000r 2               KEYDIS	=	$026D	;1-byte keyboard disable
000000r 2               FINE	=	$026E	;1-byte fine scrolling mode
000000r 2               GPRIOR	=	$026F	;1-byte PRIOR shadow
000000r 2               
000000r 2               PADDL0	=	$0270	;1-byte potentiometer 0
000000r 2               PADDL1	=	$0271	;1-byte potentiometer 1
000000r 2               PADDL2	=	$0272	;1-byte potentiometer 2
000000r 2               PADDL3	=	$0273	;1-byte potentiometer 3
000000r 2               PADDL4	=	$0274	;1-byte potentiometer 4
000000r 2               PADDL5	=	$0275	;1-byte potentiometer 5
000000r 2               PADDL6	=	$0276	;1-byte potentiometer 6
000000r 2               PADDL7	=	$0277	;1-byte potentiometer 7
000000r 2               
000000r 2               STICK0	=	$0278	;1-byte joystick 0
000000r 2               STICK1	=	$0279	;1-byte joystick 1
000000r 2               STICK2	=	$027A	;1-byte joystick 2
000000r 2               STICK3	=	$027B	;1-byte joystick 3
000000r 2               
000000r 2               PTRIG0	=	$027C	;1-byte paddle trigger 0
000000r 2               PTRIG1	=	$027D	;1-byte paddle trigger 1
000000r 2               PTRIG2	=	$027E	;1-byte paddle trigger 2
000000r 2               PTRIG3	=	$027F	;1-byte paddle trigger 3
000000r 2               PTRIG4	=	$0280	;1-byte paddle trigger 4
000000r 2               PTRIG5	=	$0281	;1-byte paddle trigger 5
000000r 2               PTRIG6	=	$0282	;1-byte paddle trigger 6
000000r 2               PTRIG7	=	$0283	;1-byte paddle trigger 7
000000r 2               
000000r 2               STRIG0	=	$0284	;1-byte joystick trigger 0
000000r 2               STRIG1	=	$0285	;1-byte joystick trigger 1
000000r 2               STRIG2	=	$0286	;1-byte joystick trigger 2
000000r 2               STRIG3	=	$0287	;1-byte joystick trigger 3
000000r 2               
000000r 2               HIBYTE	=	$0288	;1-byte relocating loader high byte:
000000r 2               WMODE	=	$0289	;1-byte cassette WRITE mode ($80 = writing)
000000r 2               BLIM	=	$028A	;1-byte cassette buffer limit
000000r 2               IMASK	=	$028B	;1-byte (not used)
000000r 2               JVECK	=	$028C	;2-byte jump vector or temporary
000000r 2               NEWADR	=	$028E	;2-byte relocating address
000000r 2               TXTROW	=	$0290	;1-byte split screen text cursor row
000000r 2               TXTCOL	=	$0291	;2-byte split screen text cursor column
000000r 2               TINDEX	=	$0293	;1-byte split scree text mode
000000r 2               TXTMSC	=	$0294	;2-byte split screen memory scan counter
000000r 2               TXTOLD	=	$0296	;6-byte OLDROW, OLDCOL, OLDCHR, OLDADR for text
000000r 2               CRETRY	=	$029C	;1-byte number of command frame ret:
000000r 2               HOLD3	=	$029D	;1-byte temporary
000000r 2               SUBTMP	=	$029E	;1-byte temporary
000000r 2               HOLD2	=	$029F	;1-byte (not used)
000000r 2               DMASK	=	$02A0	;1-byte display (pixel location) mask
000000r 2               TMPLBT	=	$02A1	;1-byte (not used)
000000r 2               ESCFLG	=	$02A2	;1-byte escape flag ($80 = ESC detected)
000000r 2               TABMAP	=	$02A3	;15-byte (120-bit) tab stop bit map
000000r 2               LOGMAP	=	$02B2	;8-byte (32-bit) logical line bit map
000000r 2               INVFLG	=	$02B6	;1-byte inverse video flag ($80 = inverse)
000000r 2               FILFLG	=	$02B7	;1-byte right fill flag (0 = no fill)
000000r 2               TMPROW	=	$02B8	;1-byte temporary row
000000r 2               TMPCOL	=	$02B9	;2-byte temporary column
000000r 2               SCRFLG	=	$02BB	;1-byte scroll occurence flag (0 = not occurred)
000000r 2               HOLD4	=	$02BC	;1-byte temporary
000000r 2               DRETRY	=	$02BD	;1-byte number of device retries
000000r 2               SHFLOK	=	$02BE	;1-byte shift/control lock flags
000000r 2               BOTSCR	=	$02BF	;1-byte screen bottom (24 = normal, 4 = split)
000000r 2               
000000r 2               PCOLR0	=	$02C0	;1-byte player-missle 0 color/luminance
000000r 2               PCOLR1	=	$02C1	;1-byte player-missle 1 color/luminance
000000r 2               PCOLR2	=	$02C2	;1-byte player-missle 2 color/luminance
000000r 2               PCOLR3	=	$02C3	;1-byte player-missle 3 color/luminance
000000r 2               
000000r 2               COLOR0	=	$02C4	;1-byte playfield 0 color/luminance
000000r 2               COLOR1	=	$02C5	;1-byte playfield 1 color/luminance
000000r 2               COLOR2	=	$02C6	;1-byte playfield 2 color/luminance
000000r 2               COLOR3	=	$02C7	;1-byte playfield 3 color/luminance
000000r 2               
000000r 2               COLOR4	=	$02C8	;1-byte background color/luminance
000000r 2               
000000r 2               PARMBL	=	$02C9	;6-byte relocating loader parameter:
000000r 2               RUNADR	=	$02C9	;2-byte run address
000000r 2               HIUSED	=	$02CB	;2-byte highest non-zero page addre:
000000r 2               ZHIUSE	=	$02CD	;2-byte highest zero page address
000000r 2               
000000r 2               OLDPAR	=	$02CF	;6-byte relocating loader parameter:
000000r 2               GBYTEA	=	$02CF	;2-byte GET-BYTE routine address
000000r 2               LOADAD	=	$02D1	;2-byte non-zero page load address
000000r 2               ZLOADA	=	$02D3	;2-byte zero page load address
000000r 2               
000000r 2               DSCTLN	=	$02D5	;2-byte disk sector length
000000r 2               ACMISR	=	$02D7	;2-byte ACMI interrupt service rout:
000000r 2               KRPDEL	=	$02D9	;1-byte auto-repeat delay
000000r 2               KEYREP	=	$02DA	;1-byte auto-repeat rate
000000r 2               NOCLIK	=	$02DB	;1-byte key click disable
000000r 2               HELPFG	=	$02DC	;1-byte HELP key flag (0 = no HELP)
000000r 2               DMASAV	=	$02DD	;1-byte SDMCTL save/restore
000000r 2               PBPNT	=	$02DE	;1-byte printer buffer pointer
000000r 2               PBUFSZ	=	$02DF	;1-byte printer buffer size
000000r 2               
000000r 2               ;	=	$02E0	;4 bytes reserved for DOS
000000r 2               
000000r 2               RAMSIZ	=	$02E4	;1-byte high RAM size
000000r 2               MEMTOP	=	$02E5	;2-byte top of available user memory
000000r 2               MEMLO	=	$02E7	;2-byte bottom of available user memory
000000r 2               HNDLOD	=	$02E9	;1-byte user load flag (0 = no hand:
000000r 2               DVSTAT	=	$02EA	;4-byte device status buffer
000000r 2               CBAUDL	=	$02EE	;1-byte low cassette baud rate
000000r 2               CBAUDH	=	$02EF	;1-byte high cassette baud rate
000000r 2               CRSINH	=	$02F0	;1-byte cursor inhibit (0 = cursor on)
000000r 2               KEYDEL	=	$02F1	;1-byte key debounce delay timer
000000r 2               CH1	=	$02F2	;1-byte prior keyboard character
000000r 2               CHACT	=	$02F3	;1-byte CHACTL shadow
000000r 2               CHBAS	=	$02F4	;1-byte CHBASE shadow
000000r 2               
000000r 2               NEWROW	=	$02F5	;1-byte draw destination row
000000r 2               NEWCOL	=	$02F6	;2-byte draw destination column
000000r 2               ROWINC	=	$02F8	;1-byte draw row increment
000000r 2               COLINC	=	$02F9	;1-byte	draw column increment
000000r 2               
000000r 2               CHAR	=	$02FA	;1-byte internal character
000000r 2               ATACHR	=	$02FB	;1-byte ATASCII character or plot point
000000r 2               CH	=	$02FC	;1-byte keyboard code (buffer)
000000r 2               FILDAT	=	$02FD	;1-byte right fill data
000000r 2               DSPFLG	=	$02FE	;1-byte control character display flag (0 = no)
000000r 2               SSFLAG	=	$02FF	;1-byte start/stop flag (0 = not stopped)
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Page Three Address Equates
000000r 2               
000000r 2               
000000r 2               DCB	=	$0300	;12-byte device control block
000000r 2               DDEVIC	=	$0300	;1-byte unit 1 bus ID
000000r 2               DUNIT	=	$0301	;1-byte unit number
000000r 2               DCOMND	=	$0302	;1-byte bus command
000000r 2               DSTATS	=	$0303	;1-byte command type/status return
000000r 2               DBUFLO	=	$0304	;1-byte low data buffer address
000000r 2               DBUFHI	=	$0305	;1-byte high data buffer address
000000r 2               DTIMLO	=	$0306	;1-byte timeout (seconds)
000000r 2               DUNUSE	=	$0307	;1-byte (not used)
000000r 2               DBYTLO	=	$0308	;1-byte low number of bytes to transfer
000000r 2               DBYTHI	=	$0309	;1-byte high number of bytes to transfer
000000r 2               DAUX1	=	$030A	;1-byte first command auxiliary
000000r 2               DAUX2	=	$030B	;1-byte second command auxiliary
000000r 2               
000000r 2               TIMER1	=	$030C	;2-byte initial baud rate timer value
000000r 2               JMPERS	=	$030E	;1-byte jumper options
000000r 2               CASFLG	=	$030F	;1-byte cassette I/O flag (0 = not cassette I/O)
000000r 2               TIMER2	=	$0310	;2-byte final baud rate timer value
000000r 2               TEMP1	=	$0312	;2-byte temporary
000000r 2               TEMP2	=	$0313	;1-byte temporary
000000r 2               PTIMOT	=	$0314	;1-byte printer timeout
000000r 2               TEMP3	=	$0315	;1-byte temporary
000000r 2               SAVIO	=	$0316	;1-byte saved serial data input indicator
000000r 2               TIMFLG	=	$0317	;1-byte timeout flag (0 = timeout)
000000r 2               STACKP	=	$0318	;1-byte SIO saved stack pointer
000000r 2               TSTAT	=	$0319	;1-byte temporary status
000000r 2               
000000r 2               HATABS	=	$031A	;35-byte handler address table
000000r 2               
000000r 2               PUPBT1	=	$033D	;1-byte power-up validation byte 1
000000r 2               PUPBT2	=	$033E	;1-byte power-up validation byte 2
000000r 2               PUPBT3	=	$033F	;1-byte power-up validation byte 3
000000r 2               
000000r 2               IOCB	=	$0340	;128-byte I/O control blocks area
000000r 2               ICHID	=	$0340	;1-byte handler ID ($FF = free)
000000r 2               ICDNO	=	$0341	;1-byte device number
000000r 2               ICCOM	=	$0342	;1-byte command code
000000r 2               ICSTA	=	$0343	;1-byte status of last action
000000r 2               ICBAL	=	$0344	;1-byte low buffer address
000000r 2               ICBAH	=	$0345	;1-byte high buffer address
000000r 2               ICPTL	=	$0346	;1-byte low PUT-BYTE routine address-1
000000r 2               ICPTH	=	$0347	;1-byte high PUT-BYTE routine address-1
000000r 2               ICBLL	=	$0348	;1-byte low buffer length
000000r 2               ICBLH	=	$0349	;1-byte high buffer length
000000r 2               ICAX1	=	$034A	;1-byte first auxiliary information
000000r 2               ICAX2	=	$034B	;1-byte second auxiliary information
000000r 2               ICSPR	=	$034C	;4-byte work area
000000r 2               
000000r 2               PRNBUF	=	$03C0	;40-byte printer buffer
000000r 2               SUPERF	=	$03E8	;1-byte editor super function flag :
000000r 2               CKEY	=	$03E9	;1-byte cassette boot r=est flag :
000000r 2               CASSBT	=	$03EA	;1-byte cassette boot flag (0 = not:
000000r 2               CARTCK	=	$03EB	;1-byte cartridge =ivalence checksum
000000r 2               DERRF	=	$03EC	;1-byte screen OPEN error flag (0 = not)
000000r 2               
000000r 2               ;	Remainder of Page Three Not Cleared upon Reset
000000r 2               
000000r 2               ACMVAR	=	$03ED	;11 bytes reserved for ACMI
000000r 2               BASICF	=	$03F8	;1-byte BASIC switch flag (0 = BASIC enabled)
000000r 2               MINTLK	=	$03F9	;1-byte ACMI module interlock
000000r 2               GINTLK	=	$03FA	;1-byte cartridge interlock
000000r 2               CHLINK	=	$03FB	;2-byte loaded handler chain link
000000r 2               CASBUF	=	$03FD	;3-byte first 3 bytes of cassette buffer
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Page Four Address Equates
000000r 2               
000000r 2               
000000r 2               ;	=	$0400	;128-byte remainder of cassette buffer
000000r 2               
000000r 2               ;	Reserved for Application
000000r 2               
000000r 2               	.IF PLATFORM<>1
000000r 2               
000000r 2               USAREA	=	$0480	;128 bytes reserved for application
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Page Five Address Equates
000000r 2               
000000r 2               
000000r 2               ;	Reserved for Application and Floating Point Package
000000r 2               
000000r 2               ;	=	$0500	;256 bytes reserved for application and FPP
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Floating Point Package Address Equates
000000r 2               
000000r 2               
000000r 2               LBPR1	=	$057E	;1-byte LBUFF preamble
000000r 2               LBPR2	=	$057F	;1-byte LBUFF preamble
000000r 2               LBUFF	=	$0580	;128-byte line buffer
000000r 2               
000000r 2               PLYARG	=	$05E0	;6-byte floating point polynomial argument
000000r 2               FPSCR	=	$05E6	;6-byte floating point temporary
000000r 2               FPSCR1	=	$05EC	;6-byte floating point temporary
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Page Six Address Equates
000000r 2               
000000r 2               
000000r 2               ;	Reserved for Application
000000r 2               
000000r 2               ;	=	$0600	;256 bytes reserved for application
000000r 2               ;	SPACE	4,10
000000r 2               ;**	LNBUG Address Equates
000000r 2               
000000r 2               
000000r 2               ;	IF	LNBUG
000000r 2               ;LNORG	=	$6000	;LNBUG origin
000000r 2               ;LNIRQ	=	$6033	;LNBUG IRQ entry
000000r 2               ;LNNMI	=	$8351	;LNBUG NMI vector
000000r 2               ;	ENDIF	;LNBUG
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Cartridge Address Equates
000000r 2               
000000r 2               
000000r 2               CARTCS	=	$BFFA	;2-byte cartridge coldstart address
000000r 2               CART	=	$BFFC	;1-byte cartridge present indicator
000000r 2               CARTFG	=	$BFFD	;1-byte cartridge flags
000000r 2               CARTAD	=	$BFFE	;2-byte cartridge start vector
000000r 2               ;	SPACE	4,10
000000r 2               ;**	CTIA/GTIA Address Equates
000000r 2               
000000r 2               
000000r 2               CTIA	=	$D000	;CTIA/GTIA area
000000r 2               
000000r 2               ;	Read/Write Addresses
000000r 2               
000000r 2               CONSOL	=	$D01F	;console switches and speaker control
000000r 2               
000000r 2               ;	Read Addresses
000000r 2               
000000r 2               M0PF	=	$D000	;missle 0 and playfield collision
000000r 2               M1PF	=	$D001	;missle 1 and playfield collision
000000r 2               M2PF	=	$D002	;missle 2 and playfield collision
000000r 2               M3PF	=	$D003	;missle 3 and playfield collision
000000r 2               
000000r 2               P0PF	=	$D004	;player 0 and playfield collision
000000r 2               P1PF	=	$D005	;player 1 and playfield collision
000000r 2               P2PF	=	$D006	;player 2 and playfield collision
000000r 2               P3PF	=	$D007	;player 3 and playfield collision
000000r 2               
000000r 2               M0PL	=	$D008	;missle 0 and player collision
000000r 2               M1PL	=	$D009	;missle 1 and player collision
000000r 2               M2PL	=	$D00A	;missle 2 and player collision
000000r 2               M3PL	=	$D00B	;missle 3 and player collision
000000r 2               
000000r 2               P0PL	=	$D00C	;player 0 and player collision
000000r 2               P1PL	=	$D00D	;player 1 and player collision
000000r 2               P2PL	=	$D00E	;player 2 and player collision
000000r 2               P3PL	=	$D00F	;player 3 and player collision
000000r 2               
000000r 2               TRIG0	=	$D010	;joystick trigger 0
000000r 2               TRIG1	=	$D011	;joystick trigger 1
000000r 2               
000000r 2               TRIG2	=	$D012	;cartridge interlock
000000r 2               TRIG3	=	$D013	;ACMI module interlock
000000r 2               
000000r 2               PAL	=	$D014	;PAL/NTSC indicator
000000r 2               
000000r 2               ;	Write Addresses
000000r 2               
000000r 2               HPOSP0	=	$D000	;player 0 horizontal position
000000r 2               HPOSP1	=	$D001	;player 1 horizontal position
000000r 2               HPOSP2	=	$D002	;player 2 horizontal position
000000r 2               HPOSP3	=	$D003	;player 3 horizontal position
000000r 2               
000000r 2               HPOSM0	=	$D004	;missle 0 horizontal position
000000r 2               HPOSM1	=	$D005	;missle 1 horizontal position
000000r 2               HPOSM2	=	$D006	;missle 2 horizontal position
000000r 2               HPOSM3	=	$D007	;missle 3 horizontal position
000000r 2               
000000r 2               SIZEP0	=	$D008	;player 0 size
000000r 2               SIZEP1	=	$D009	;player 1 size
000000r 2               SIZEP2	=	$D00A	;player 2 size
000000r 2               SIZEP3	=	$D00B	;player 3 size
000000r 2               
000000r 2               SIZEM	=	$D00C	;missle sizes
000000r 2               
000000r 2               GRAFP0	=	$D00D	;player 0 graphics
000000r 2               GRAFP1	=	$D00E	;player 1 graphics
000000r 2               GRAFP2	=	$D00F	;player 2 graphics
000000r 2               GRAFP3	=	$D010	;player 3 graphics
000000r 2               
000000r 2               GRAFM	=	$D011	;missle graphics
000000r 2               
000000r 2               COLPM0	=	$D012	;player-missle 0 color/luminance
000000r 2               COLPM1	=	$D013	;player-missle 1 color/luminance
000000r 2               COLPM2	=	$D014	;player-missle 2 color/luminance
000000r 2               COLPM3	=	$D015	;player-missle 3 color/luminance
000000r 2               
000000r 2               COLPF0	=	$D016	;playfield 0 color/luminance
000000r 2               COLPF1	=	$D017	;playfield 1 color/luminance
000000r 2               COLPF2	=	$D018	;playfield 2 color/luminance
000000r 2               COLPF3	=	$D019	;playfield 3 color/luminance
000000r 2               
000000r 2               COLBK	=	$D01A	;background color/luminance
000000r 2               
000000r 2               PRIOR	=	$D01B	;priority select
000000r 2               VDELAY	=	$D01C	;vertical delay
000000r 2               GRACTL	=	$D01D	;graphic control
000000r 2               HITCLR	=	$D01E	;collision clear
000000r 2               ;	SPACE	4,10
000000r 2               ;**	PBI Address Equates
000000r 2               
000000r 2               
000000r 2               PBI	=	$D100	;parallel bus interface area
000000r 2               
000000r 2               ;	Read Addresses
000000r 2               
000000r 2               PDVI	=	$D1FF	;parallel device IRQ status
000000r 2               
000000r 2               ;	Write Addresses
000000r 2               
000000r 2               PDVS	=	$D1FF	;parallel device select
000000r 2               ;	SPACE	4,10
000000r 2               ;**	POKEY Address Equates
000000r 2               
000000r 2               
000000r 2               POKEY	=	$D200	;POKEY area
000000r 2               
000000r 2               ;	Read Addresses
000000r 2               
000000r 2               POT0	=	$D200	;potentiometer 0
000000r 2               POT1	=	$D201	;potentiometer 1
000000r 2               POT2	=	$D202	;potentiometer 2
000000r 2               POT3	=	$D203	;potentiometer 3
000000r 2               POT4	=	$D204	;potentiometer 4
000000r 2               POT5	=	$D205	;potentiometer 5
000000r 2               POT6	=	$D206	;potentiometer 6
000000r 2               POT7	=	$D207	;potentiometer 7
000000r 2               
000000r 2               ALLPOT	=	$D208	;potentiometer port state
000000r 2               KBCODE	=	$D209	;keyboard code
000000r 2               RANDOM	=	$D20A	;random number generator
000000r 2               SERIN	=	$D20D	;serial port input
000000r 2               IRQST	=	$D20E	;IRQ interrupt status
000000r 2               SKSTAT	=	$D20F	;serial port and keyboard status
000000r 2               
000000r 2               ;	Write Addresses
000000r 2               
000000r 2               AUDF1	=	$D200	;channel 1 audio fr=ency
000000r 2               AUDC1	=	$D201	;channel 1 audio control
000000r 2               
000000r 2               AUDF2	=	$D202	;channel 2 audio fr=ency
000000r 2               AUDC2	=	$D203	;channel 2 audio control
000000r 2               
000000r 2               AUDF3	=	$D204	;channel 3 audio fr=ency
000000r 2               AUDC3	=	$D205	;channel 3 audio control
000000r 2               
000000r 2               AUDF4	=	$D206	;channel 4 audio fr=ency
000000r 2               AUDC4	=	$D207	;channel 4 audio control
000000r 2               
000000r 2               AUDCTL	=	$D208	;audio control
000000r 2               STIMER	=	$D209	;start timers
000000r 2               SKRES	=	$D20A	;reset SKSTAT status
000000r 2               POTGO	=	$D20B	;start potentiometer scan s=ence
000000r 2               SEROUT	=	$D20D	;serial port output
000000r 2               IRQEN	=	$D20E	;IRQ interrupt enable
000000r 2               SKCTL	=	$D20F	;serial port and keyboard control
000000r 2               ;	SPACE	4,10
000000r 2               ;**	PIA Address Equates
000000r 2               
000000r 2               
000000r 2               PIA	=	$D300	;PIA area
000000r 2               
000000r 2               ;	Read/Write Addresses
000000r 2               
000000r 2               PORTA	=	$D300	;port A direction register or jacks 0 and 1
000000r 2               PORTB	=	$D301	;port B direction register or memory control
000000r 2               
000000r 2               PACTL	=	$D302	;port A control
000000r 2               PBCTL	=	$D303	;port B control
000000r 2               ;	SPACE	4,10
000000r 2               ;**	ANTIC Address Equates
000000r 2               
000000r 2               
000000r 2               ANTIC	=	$D400	;ANTIC area
000000r 2               
000000r 2               ;	Read Addresses
000000r 2               
000000r 2               VCOUNT	=	$D40B	;vertical line counter
000000r 2               PENH	=	$D40C	;light pen horizontal position
000000r 2               PENV	=	$D40D	;light pen vertical position
000000r 2               NMIST	=	$D40F	;NMI interrupt status
000000r 2               
000000r 2               ;	Write Addresses
000000r 2               
000000r 2               DMACTL	=	$D400	;DMA control
000000r 2               CHACTL	=	$D401	;character control
000000r 2               DLISTL	=	$D402	;low display list address
000000r 2               DLISTH	=	$D403	;high disply list address
000000r 2               HSCROL	=	$D404	;horizontal scroll
000000r 2               VSCROL	=	$D405	;vertical scroll
000000r 2               PMBASE	=	$D407	;player-missle base address
000000r 2               CHBASE	=	$D409	;character base address
000000r 2               WSYNC	=	$D40A	;wait for HBLANK synchronization
000000r 2               NMIEN	=	$D40E	;NMI enable
000000r 2               NMIRES	=	$D40F	;NMI interrupt status reset
000000r 2               ;	SPACE	4,10
000000r 2               ;**	PBI RAM Address Equates
000000r 2               
000000r 2               
000000r 2               PBIRAM	=	$D600	;parallel bus interface RAM area
000000r 2               ;	SPACE	4,10
000000r 2               ;**	ACMI Address Equates
000000r 2               
000000r 2               
000000r 2               ;	IF	ACMI
000000r 2               ;	ENDIF	;ACMI
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Floating Point Package Address Equates
000000r 2               
000000r 2               
000000r 2               AFP	=	$D800	;convert ASCII to floating point
000000r 2               FASC	=	$D8E6	;convert floating point to ASCII
000000r 2               IFP	=	$D9AA	;convert integer to floating point
000000r 2               FPI	=	$D9D2	;convert floating point to integer
000000r 2               ZFR0	=	$DA44	;zero FR0
000000r 2               ZF1	=	$DA46	;zero floating point number
000000r 2               FSUB	=	$DA60	;subtract floating point numbers
000000r 2               FADD	=	$DA66	;add floating point numbers
000000r 2               FMUL	=	$DADB	;multiply floating point numbers
000000r 2               FDIV	=	$DB28	;divide floating point numbers
000000r 2               PLYEVL	=	$DD40	;evaluate floating point polynomial
000000r 2               FLD0R	=	$DD89	;load floating point number
000000r 2               FLD0P	=	$DD8D	;load floating point number
000000r 2               FLD1R	=	$DD98	;load floating point number
000000r 2               FLD1P	=	$DD9C	;load floating point number
000000r 2               FST0R	=	$DDA7	;store floating point number
000000r 2               FST0P	=	$DDAB	;store floating point number
000000r 2               FMOVE	=	$DDB6	;move floating point number
000000r 2               LOG	=	$DECD	;calculate floating point logarithm
000000r 2               LOG10	=	$DED1	;calculate floating point base 10 logarithm
000000r 2               EXP	=	$DDC0	;calculate floating point exponentiation
000000r 2               EXP10	=	$DDCC	;calculate floating point base 10 exponentiation
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Parallel Device Address Equates
000000r 2               
000000r 2               
000000r 2               PDID1	=	$D803	;parallel device ID 1
000000r 2               PDIOV	=	$D805	;parallel device I/O vector
000000r 2               PDIRQV	=	$D808	;parallel device IRQ vector
000000r 2               PDID2	=	$D80B	;parallel device ID 2
000000r 2               PDVV	=	$D80D	;parallel device vector table
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Device Handler Vector Table Address Equates
000000r 2               
000000r 2               
000000r 2               EDITRV	=	$E400	;editor handler vector table
000000r 2               SCRENV	=	$E410	;screen handler vector table
000000r 2               KEYBDV	=	$E420	;keyboard handler vector table
000000r 2               PRINTV	=	$E430	;printer handler vector table
000000r 2               CASETV	=	$E440	;cassette handler vector table
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Jump Vector Address Equates
000000r 2               
000000r 2               
000000r 2               DINITV	=	$E450	;vector to initialize DIO
000000r 2               DSKINV	=	$E453	;vector to DIO
000000r 2               CIOV	=	$E456	;vector to CIO
000000r 2               SIOV	=	$E459	;vector to SIO
000000r 2               SETVBV	=	$E45C	;vector to set VBLANK parameters
000000r 2               SYSVBV	=	$E45F	;vector to process immediate VBLANK NMI
000000r 2               XITVBV	=	$E462	;vector to process deferred VBLANK NMI
000000r 2               SIOINV	=	$E465	;vector to initialize SIO
000000r 2               SENDEV	=	$E468	;vector to enable SEND
000000r 2               INTINV	=	$E46B	;vector to initialize interrupt handler
000000r 2               CIOINV	=	$E46E	;vector to initialize CIO
000000r 2               BLKBDV	=	$E471	;vector to power-up display (formerly memo pad)
000000r 2               WARMSV	=	$E474	;vector to warmstart
000000r 2               COLDSV	=	$E477	;vector to coldstart
000000r 2               RBLOKV	=	$E47A	;vector to read cassette block
000000r 2               CSOPIV	=	$E47D	;vector to open cassette for input
000000r 2               PUPDIV	=	$E480	;vector to power-up display
000000r 2               SLFTSV	=	$E483	;vector to self-test
000000r 2               PHENTV	=	$E486	;vector to enter peripheral handler
000000r 2               PHUNLV	=	$E489	;vector to unlink peripheral handler
000000r 2               PHINIV	=	$E48C	;vector to initialize peripheral handler
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Generic Parallel Device Handler Vector Table Address Equates
000000r 2               
000000r 2               
000000r 2               GPDVV	=	$E48F	;generic parallel device handler vector table
000000r 2               ;	SUBTTL	'Miscellaneous Address Equates'
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Self-test Page Zero Address Equates
000000r 2               
000000r 2               
000000r 2               STTIME	=	$0080	;2-byte main screen timeout timer
000000r 2               STAUT	=	$0082	;1-byte auto-mode flag
000000r 2               STJMP	=	$0083	;3-byte ANTIC jump instruction
000000r 2               STSEL	=	$0086	;1-byte selection
000000r 2               STPASS	=	$0087	;1-byte pass
000000r 2               STSPP	=	$0088	;1-byte SELECT previously pressed flag
000000r 2               ;	=	$0089	;1-byte (not used)
000000r 2               STKST	=	$008A	;1-byte keyboard self-test flag (0 = not)
000000r 2               STCHK	=	$008B	;2-byte checksum
000000r 2               STSMM	=	$008D	;1-byte screen memory mask
000000r 2               STSMP	=	$008E	;1-byte screen memory pointer
000000r 2               ST1K	=	$008F	;1-byte current 1K of memory to test
000000r 2               STPAG	=	$0090	;2-byte current page to test
000000r 2               STPC	=	$0092	;1-byte page count
000000r 2               STMVAL	=	$0093	;1-byte correct value for memory test
000000r 2               STSKP	=	$0094	;1-byte simulated keypress index
000000r 2               STTMP1	=	$0095	;2-byte temporary
000000r 2               STVOC	=	$0097	;1-byte current voice indicator
000000r 2               STNOT	=	$0098	;1-byte current note counter
000000r 2               STCDI	=	$0099	;1-byte cleft display pointer
000000r 2               STCDA	=	$009A	;1-byte cleft data pointer
000000r 2               STTMP2	=	$009B	;2-byte temporary
000000r 2               STTMP3	=	$009D	;1-byte temporary
000000r 2               STADR1	=	$009E	;2-byte temporary address
000000r 2               STADR2	=	$00A0	;2-byte temporary address
000000r 2               STBL	=	$00A2	;1-byte blink counter
000000r 2               STTMP4	=	$00A3	;1-byte temporary
000000r 2               STLM	=	$00A4	;1-byte LED mask
000000r 2               STTMP5	=	$00A5	;1-byte temporary
000000r 2               ;	SPACE	4,10
000000r 2               ;**	Self-test Address Equates
000000r 2               
000000r 2               
000000r 2               ST3000	=	$3000	;screen memory
000000r 2               ST3002	=	$3002	;cleft display
000000r 2               ST3004	=	$3004	;"VOICE #" text display
000000r 2               ST300B	=	$300B	;voice number display
000000r 2               ST301C	=	$301C	;START key display
000000r 2               ST301E	=	$301E	;SELECT key display
000000r 2               ST3020	=	$3020	;OPTION key display, first 8K ROM display
000000r 2               ST3021	=	$3021	;keyboard character display
000000r 2               ST3022	=	$3022	;keyboard text display
000000r 2               ST3024	=	$3024	;second 8K ROM display
000000r 2               ST3028	=	$3028	;"RAM" text display
000000r 2               ST3038	=	$3038	;RAM display
000000r 2               ST303C	=	$303C	;fifth note display
000000r 2               ST304C	=	$304C	;"B S" text display
000000r 2               ST3052	=	$3052	;tab key display
000000r 2               ST3062	=	$3062	;cleft display
000000r 2               ST306D	=	$306D	;return key display
000000r 2               ST3072	=	$3072	;control key display
000000r 2               ST3092	=	$3092	;"SH" text display
000000r 2               ST309E	=	$309E	;sixth note display
000000r 2               ST30AB	=	$30AB	;"SH" text display
000000r 2               ST30B7	=	$30B7	;"S P A C E   B A R" text display
000000r 2               ST30C1	=	$30C1	;cleft display
000000r 2               ST30C2	=	$30C2	;cleft display
000000r 2               ST30C7	=	$30C7	;third note display
000000r 2               ST30CA	=	$30CA	;fourth note display
000000r 2               ST30F8	=	$30F8	;third note display
000000r 2               ST3100	=	$3100	;screen memory
000000r 2               ST3121	=	$3121	;cleft display
000000r 2               ST3122	=	$3122	;cleft display
000000r 2               ST313C	=	$313C	;fifth note display
000000r 2               ST3150	=	$3150	;first line of staff display
000000r 2               ST3154	=	$3154	;first note display
000000r 2               ST3181	=	$3181	;cleft display
000000r 2               ST3182	=	$3182	;cleft display
000000r 2               ST3186	=	$3186	;second note display
000000r 2               ST318C	=	$318C	;fifth note display
000000r 2               ST31B0	=	$31B0	;second line of staff display
000000r 2               ST31C2	=	$31C2	;cleft display
000000r 2               ST31CA	=	$31CA	;fourth note display
000000r 2               ST31EE	=	$31EE	;sixth note display
000000r 2               ST31F1	=	$31F1	;cleft display
000000r 2               ST3210	=	$3210	;third line of staff display
000000r 2               ST321A	=	$321A	;fourth note display
000000r 2               ST3248	=	$3248	;third note display
000000r 2               ST3270	=	$3270	;fourth line of staff display
000000r 2               ST32D0	=	$32D0	;fifth line of staff display
000000r 2               
000000r 2               	.ENDIF
000000r 2               
000000r 2               ;	SUBTTL	'Macro Definitions'
000000r 2               ;	SPACE	4,10
000000r 2               ;**	FIX - Fix Address
000000r 2               ;*
000000r 2               ;*	FIX sets the origin counter to the value specified as an
000000r 2               ;*	argument.  If the current origin counter is less than the
000000r 2               ;*	argument, FIX fills the intervening bytes with zero and
000000r 2               ;*	issues a message to document the location and number of
000000r 2               ;*	bytes that are zero filled.
000000r 2               ;*
000000r 2               ;*	ENTRY	FIX	address
000000r 2               ;*
000000r 2               ;*
000000r 2               ;*	EXIT
000000r 2               ;*		Origin counter set to specified address.
000000r 2               ;*		Message issued if zero fill r=ired.
000000r 2               ;*
000000r 2               ;*	CHANGES
000000r 2               ;*		-none-
000000r 2               ;*
000000r 2               ;*	CALLS
000000r 2               ;*		-none-
000000r 2               ;*
000000r 2               ;*	NOTES
000000r 2               ;*		Due to ECHO limitiation of 255 iterations, FIX is
000000r 2               ;*		recursive.
000000r 2               ;*		If the current origin counter value is beyond the
000000r 2               ;*		argument, FIX generates an error.
000000r 2               ;*
000000r 2               ;*	MODS
000000r 2               ;*		R. K. Nordin	11/01/83
000000r 2               
000000r 2               
000000r 2               
000000r 2               .macro	FIX	address
000000r 2               	.if	* > address
000000r 2               	.error	.sprintf("$%04x precedes current origin counter of $%04x", address, *)
000000r 2               	.elseif * < address
000000r 2               	.out	.sprintf("$%04x free bytes from $%04x to $%04x", address-*, *, address-1)
000000r 2               	.res	address-*, $00
000000r 2               	.endif
000000r 2               .endmacro
000000r 2               ;	SUBTTL	'First 8K ROM Identification and Checksum'
000000r 2               ;	SPACE	4,10
000000r 2               ;	ORG	$C000
000000r 2               ;	SPACE	4,10
000000r 2               ;**	First 8K ROM Identification and Checksum
000000r 2               
000000r 2               
000000r 2               ;	DW	$0000				;reserved for checksum
000000r 2               ;	DB	IDDAY,IDMON,IDYEAR		;date (day, month, year)
000000r 2               ;	DB	$00				;not used
000000r 2               ;	DB	IDPN1,IDPN2,IDPN3,IDPN4,IDPN5	;part number
000000r 2               ;	DB	IDREV				;revision number
000000r 2               
000000r 2               
000000r 1               		.include "fat16.inc"
000000r 2               ;
000000r 2               ; PLATFORM = 0 : Homebrew FPGA
000000r 2               ; PLATFORM = 1 : Homebrew Hardware
000000r 2               ; PLATFORM = 2 : Atari XL/XE
000000r 2               ; PLATFORM = 3 : my65816 FPGA
000000r 2               ; PLATFORM = 4 : Atari XL/XE FAT12
000000r 2               ;
000000r 2               ;
000000r 2               ; FAT-16 defines
000000r 2               ;
000000r 2               ;       DOS 2           MyDOS
000000r 2               ;-------------------------------------
000000r 2               ;3	OPEN        	OPEN
000000r 2               ;5	GET RECORD	GET RECORD
000000r 2               ;7	GET CHARACTERS	GET CHARACTERS
000000r 2               ;9	PUT RECORD	PUT RECORD
000000r 2               ;11	PUT CHARACTERS	PUT CHARACTERS
000000r 2               ;12	CLOSE	        CLOSE
000000r 2               ;13	STATUS REQUEST	STATUS REQUEST
000000r 2               ;32	RENAME          RENAME
000000r 2               ;33	DELETE	        DELETE
000000r 2               ;34		        CREATE DIRECTORY
000000r 2               ;35	LOCK FILE	LOCK FILE
000000r 2               ;36	UNLOCK FILE	UNLOCK FILE
000000r 2               ;37	POINT[1]	POINT[1]
000000r 2               ;38	NOTE[1]	        NOTE[1]
000000r 2               ;39		        LOAD BINARY FILE&RUN
000000r 2               ;40		        LOAD BINARY FILE&RUN
000000r 2               ;41		        CHANGE DIRECTORY
000000r 2               ;42		        CREATE DIRECTORY
000000r 2               
000000r 2               DRVCHAR		= 'D'
000000r 2               
000000r 2               	.IF PLATFORM <= 1
000000r 2               FATPTRS		= $0006
000000r 2               FATPTRD		= $0008
000000r 2               	.ELSE
000000r 2               FATPTRS		= $0000
000000r 2               FATPTRD		= $0002
000000r 2               SECTOR		= FMSZPG
000000r 2               SHIFT		= FMSZPG+4
000000r 2               STCKPTR		= FMSZPG+5
000000r 2               	.ENDIF
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Memory Setup
000000r 2               ;--------------------------------------------------------------
000000r 2               	.IF PLATFORM <= 1
000000r 2               VBASE		= $400
000000r 2               	.ENDIF
000000r 2               
000000r 2               ;	.IF PLATFORM = 3
000000r 2               ;VBASE		= $400
000000r 2               ;	.ENDIF
000000r 2               
000000r 2               	.IF PLATFORM = 2 || PLATFORM = 4
000000r 2               VBASE		= $700
000000r 2               FATCODE		= VBASE+$600
000000r 2               DUPCODE		= $1b00
000000r 2               	.ENDIF
000000r 2               
000000r 2               	.IF PLATFORM = 2
000000r 2               JSTARTUP	= FATCODE
000000r 2               JPRINT		= FATCODE+3
000000r 2               JPUTHEX		= FATCODE+6
000000r 2               JPRINTSTR	= FATCODE+9
000000r 2               JINITFAT	= FATCODE+12
000000r 2               	.ENDIF
000000r 2               
000000r 2               	.IF PLATFORM = 4
000000r 2               JSTARTUP	= STARTUP
000000r 2               JPRINT		= PRINT
000000r 2               JPUTHEX		= PUTHEX
000000r 2               JPRINTSTR	= PRINTSTR
000000r 2               JINITFAT	= INITFAT
000000r 2               	.ENDIF
000000r 2               
000000r 2               V		= VBASE
000000r 2               BUFFER		= VBASE+$200
000000r 2               FATBUF		= VBASE+$400
000000r 2               
000000r 2               CRENAME		= 32
000000r 2               CDELETE		= 33
000000r 2               CCREDIR		= 34
000000r 2               CFSTAT		= 40
000000r 2               CCHADIR		= 41
000000r 2               CCREDIR1	= 42
000000r 2               
000000r 2               DEL		= $E5
000000r 2               EOF		= 136
000000r 2               
000000r 2               SECCLUS		= V+0		;1
000000r 2               RESSEC		= V+1		;2
000000r 2               NUMFATS		= V+3		;1
000000r 2               NUMDIR		= V+4		;2
000000r 2               NUMSECS		= V+6		;2
000000r 2               MEDIA		= V+8		;1
000000r 2               SECSFAT		= V+9		;2
000000r 2               DUMMY1		= V+11 		;1
000000r 2               
000000r 2               dummy		= V+12		;4
000000r 2               FATBASE		= V+16		;4
000000r 2               DIRBASE		= V+20		;4
000000r 2               DATBASE		= V+24		;4
000000r 2               LASTSEC		= V+28		;4
000000r 2               LASTFAT		= V+32		;4
000000r 2               BYTCLUS		= V+36 		;4
000000r 2               
000000r 2               BIN		= V+40 		;4
000000r 2               BCD		= V+44 		;5
000000r 2               DECIMAL		= V+49 		;10
000000r 2               
000000r 2               NEWCLUS		= V+59		;2
000000r 2               DDIRTY		= V+61 		;1
000000r 2               FDIRTY		= V+62 		;1
000000r 2               BUFADRL		= V+63 		;1
000000r 2               BUFADRH		= V+64 		;1
000000r 2               
000000r 2               DIRCLUS		= V+65		;2
000000r 2               DIRRENA		= V+67 		;11
000000r 2               
000000r 2               NODISPL		= SHIFT		;V+78 		;1
000000r 2               WILD		= V+79 		;1
000000r 2               DIRLINE		= V+80 		;13
000000r 2               DIRLENG		= V+93 		;10
000000r 2               DIREOF		= V+103 	;1
000000r 2               SAVEY		= V+104		;1
000000r 2               VALIDS		= V+105		;1-byte number of specials chars to check for
000000r 2               HILF		= V+106		;1-byte aux usage
000000r 2               ASTART		= V+107		;2-byte file load start vector
000000r 2               AEND		= V+109		;2-byte file load end vector
000000r 2               CNT		= V+111		;1-byte adress enter counter DUP
000000r 2               FHEADER		= V+112		;2-byte save file header ($FF)
000000r 2               FSTART		= V+114		;2-byte file load start vector save
000000r 2               FEND		= V+116		;2-byte file load end vector save
000000r 2               FLENGTH		= V+118		;2-byte file length (for DUP save function)
000000r 2               JMPIND		= V+120		;1-byte holding $4C for JMP
000000r 2               JMPPTR		= V+121		;2-byte jmp address
000000r 2               
000000r 2               F		= JMPPTR+2
000000r 2               
000000r 2               ;-------------------------------------------------------------------------------
000000r 2               ; current File-Control-Block
000000r 2               ; is copied from FCB0-3
000000r 2               ;-------------------------------------------------------------------------------
000000r 2               FIOCBNR		= F		;1-byte FCB is assigned to this IOCB
000000r 2               FFCBOFF		= F+1		;1-byte Offset of this FCB from FCB0
000000r 2               FSTRTCL		= F+2		;2-byte Start cluster of file
000000r 2               FILELEN		= F+4		;4-byte length of file
000000r 2               FWBURST		= F+8		;1-byte write burst 0=OFF, other=ON
000000r 2               FBURST		= F+9		;1-byte flag indicating burst read ($FF = slow)
000000r 2               FRPOS		= F+10		;4-byte bytes already read
000000r 2               FVAR32		= F+14		;4-byte 32-bit general var
000000r 2               FCURCLUS	= F+18		;4-byte current cluster
000000r 2               FCURSEC		= F+22		;1-byte current sector
000000r 2               FCURPTR		= F+23 		;2-byte current pointer into sector buffer
000000r 2               FSECTOR		= F+25 		;4-byte last sector read
000000r 2               
000000r 2               ;-------------------------------------------------------------------------------
000000r 2               ; Directory variables
000000r 2               ;-------------------------------------------------------------------------------
000000r 2               DIRTEXT		= F+29		;11-byte directory text 8 + 3
000000r 2               DIRPTR		= F+40		;2-byte pointer into directory sector
000000r 2               DIRSEC		= F+42		;4-byte directory sector
000000r 2               DIRFILE		= F+46		;1-byte dir or file to search for
000000r 2               FCBEND		= F+46		;FCB end-marker
000000r 2               ;-------------------------------------------------------------------------------
000000r 2               ; current FCB ends here
000000r 2               ;-------------------------------------------------------------------------------
000000r 2               
000000r 2               ;-------------------------------------------------------------------------------
000000r 2               ; space for 4 File-Control-Blocks
000000r 2               ;-------------------------------------------------------------------------------
000000r 2               FCB0		= V+256
000000r 2               FCB1		= FCB0+64
000000r 2               FCB2		= FCB1+64
000000r 2               FCB3		= FCB2+64
000000r 2               
000000r 2               ;-------------------------------------------------------------------------------
000000r 2               ; Offsets Directory-Entry
000000r 2               ;-------------------------------------------------------------------------------
000000r 2               DNAME		= 0
000000r 2               DEXT		= 8
000000r 2               DATTRIB		= 11
000000r 2               DRESERV		= 12
000000r 2               DCLUS		= 26
000000r 2               DLEN		= 28
000000r 2               
000000r 2               PART1		= $1C6
000000r 2               	.IF PLATFORM <> 4
000000r 2               FATEND		= $FFFF
000000r 2               	.ELSE
000000r 2               FATEND		= $0FFF
000000r 2               	.ENDIF
000000r 2               
000000r 1               
000000r 1               EPB	=	$E406		;putbyte
000000r 1               
000000r 1               		.ORG FATCODE
000D00  1               	.ENDIF
000D00  1               
000D00  1               	.IF PLATFORM = 2
000D00  1               		JMP STARTUP	;0
000D00  1               		JMP PRINT	;3
000D00  1               		JMP PUTHEX	;6
000D00  1               		JMP PRINTSTR	;9
000D00  1               		JMP INITFAT
000D00  1               	.ENDIF
000D00  1               
000D00  1               ;-------------------------------------------------------------------------------
000D00  1               ; set DOSINI to reset-proof DOS-Initialisation-Vector
000D00  1               ; Set DOSVEC to DUP-code
000D00  1               ; register D: handler
000D00  1               ; set MEMLO for Basic
000D00  1               ;-------------------------------------------------------------------------------
000D00  1               STARTUP:
000D00  1               	.IF PLATFORM = 2 || PLATFORM = 4
000D00  1  A9 1D        		LDA #<INIT
000D02  1  85 0C        		STA DOSINI
000D04  1  A9 0D        		LDA #>INIT
000D06  1  85 0D        		STA DOSINI+1
000D08  1               
000D08  1               	.IF PLATFORM = 4
000D08  1  BA           		TSX
000D09  1  86 48        		STX STCKPTR
000D0B  1  A9 AE        		LDA #<DUPINIT
000D0D  1  85 0A        		STA DOSVEC
000D0F  1  A9 19        		LDA #>DUPINIT
000D11  1  85 0B        		STA DOSVEC+1
000D13  1               
000D13  1  A9 A6        		LDA #<DUPEND
000D15  1  8D E7 02     		STA MEMLO
000D18  1  A9 1E        		LDA #>DUPEND
000D1A  1  8D E8 02     		STA MEMLO+1
000D1D  1               	.ELSE
000D1D  1               		LDA #<DUPCODE
000D1D  1               		STA DOSVEC
000D1D  1               		LDA #>DUPCODE
000D1D  1               		STA DOSVEC+1
000D1D  1               
000D1D  1               		LDA #<$2100
000D1D  1               		STA MEMLO
000D1D  1               		LDA #>$2100
000D1D  1               		STA MEMLO+1
000D1D  1               	.ENDIF
000D1D  1               
000D1D  1               
000D1D  1               ;		LDA #25		; ATMAS-II patches
000D1D  1               ;		STA $329F
000D1D  1               ;		STA $32BF
000D1D  1               ;		LDA #'B'
000D1D  1               ;		STA $2A11
000D1D  1               
000D1D  1  A0 2A        INIT:		LDY #<HANDTAB
000D1F  1  A9 0D        		LDA #>HANDTAB
000D21  1  A2 44        		LDX #DRVCHAR
000D23  1  20 86 E4     		JSR PHENTV				;init D: Device (not available on ATARI 400/800)
000D26  1               
000D26  1               
000D26  1               	.ELSE
000D26  1               ;		ldx #0
000D26  1               ;HAFIND:		lda HATABS,x
000D26  1               ;		beq HAFOUND
000D26  1               ;		cmp #DRVCHAR
000D26  1               ;		beq HAFOUND
000D26  1               ;		inx
000D26  1               ;		inx
000D26  1               ;		inx
000D26  1               ;		cpx #MAXDEV
000D26  1               ;		bcc HAFIND
000D26  1               ;		rts
000D26  1               ;HAFOUND:	lda #DRVCHAR
000D26  1               ;		sta HATABS,x
000D26  1               ;		lda #<HANDTAB
000D26  1               ;		sta HATABS+1,x
000D26  1               ;		lda #>HANDTAB
000D26  1               ;		sta HATABS+2,x
000D26  1               	.ENDIF
000D26  1  20 08 15     		JSR INITFAT
000D29  1               
000D29  1               ;TEST:		lda	#0
000D29  1               ;		ldx	#2
000D29  1               ;		jsr	STAXCCLUS
000D29  1               ;TEST1:		jsr	LOAXCCLUS
000D29  1               ;		jsr	COMPFAT12
000D29  1               ;		lda	SECTOR
000D29  1               ;		jsr	PUTHEX
000D29  1               ;		jsr	SPACE
000D29  1               ;
000D29  1               ;		jsr	LOAXCCLUS
000D29  1               ;		jsr	PUTHEX
000D29  1               ;		txa
000D29  1               ;		jsr	PUTHEX
000D29  1               ;		jsr	SPACE
000D29  1               ;
000D29  1               ;		lda	FATPTRS+1
000D29  1               ;		jsr	PUTHEX
000D29  1               ;		lda	FATPTRS
000D29  1               ;		jsr	PUTHEX
000D29  1               ;		jsr	NEWLINE
000D29  1               ;
000D29  1               ;		inc	FCURCLUS
000D29  1               ;		bne	TEST1
000D29  1               ;		inc	FCURCLUS+1
000D29  1               ;		bne	TEST1
000D29  1  60           		rts
000D2A  1               
000D2A  1               ;-------------------------------------------------------------------------------
000D2A  1               ; D: Handler-Table
000D2A  1               ; Open, Close, Get Put, Status, Special, Init
000D2A  1               ;-------------------------------------------------------------------------------
000D2A  1  36 0D        HANDTAB:	.word OPENCHA-1		; open channel
000D2C  1  C9 0D        		.word CLOSECHA-1	; close channel
000D2E  1  02 0E        		.word GETCHA-1		; get channel
000D30  1  FB 0E        		.word PUTCHA-1		; put channel
000D32  1  E2 0F        		.word STATUSCHA-1	; status of channel
000D34  1  74 0F        		.word SPECIAL-1         ; other XIO cmds
000D36  1  60           		rts
000D37  1               
000D37  1               STATUSCHA       = OK
000D37  1               
000D37  1               ;-------------------------------------------------------------------------------
000D37  1               ; Handler routine Open-Channel
000D37  1               ; opens a FCB file control block for IO
000D37  1               ; checks if file or directory to be read
000D37  1               ; open file/dir checks if file exists, mustt be updated etc.
000D37  1               ;-------------------------------------------------------------------------------
000D37  1  20 4C 11     OPENCHA:	JSR OPENFCB
000D3A  1  30 29        		BMI OPENERR
000D3C  1  20 EB 10     		JSR CHECKHAN
000D3F  1  30 24        		BMI OPENERR
000D41  1               
000D41  1  A5 2A        		LDA ICAX1Z				;check if Open Directory is meant
000D43  1  29 06        		AND #6
000D45  1  C9 06        		CMP #6
000D47  1  D0 08        		BNE OPENFILE				;OPENFILE OR OPENDI (fall through)
000D49  1               
000D49  1               ;-------------------------------------------------------------------------------
000D49  1               ; open a directory
000D49  1               ;-------------------------------------------------------------------------------
000D49  1               OPENDI:		;JSR INITLSEC
000D49  1  A9 00        		LDA #0
000D4B  1  8D 6A 07             	STA HILF
000D4E  1  4C D1 12     		JMP GETFILE				;DIRSTART = 0
000D51  1               
000D51  1               ;-------------------------------------------------------------------------------
000D51  1               ; open a file
000D51  1               ;-------------------------------------------------------------------------------
000D51  1  A9 01        OPENFILE:	LDA #1					;FILE THERE?
000D53  1  20 D1 12     		JSR GETFILE
000D56  1  10 19        		BPL OPENEXIS				;YES
000D58  1               
000D58  1               OPENNEW:	;lda #'N'
000D58  1               		;jsr PRINT
000D58  1               
000D58  1  A5 2A        		LDA ICAX1Z				;WRITE FILE without R/W or APPEND?
000D5A  1  29 0D        		AND #1+4+8				;
000D5C  1  C9 08        		CMP #8					;only WRITE active
000D5E  1  F0 06        		BEQ OPENNEW3				;yes
000D60  1  20 17 11     OPEN170:	JSR CLOSEFCB
000D63  1  A0 AA        		LDY #170
000D65  1  60           OPENERR:	RTS
000D66  1               
000D66  1  20 C5 11     OPENNEW3:	JSR VALIDNAM
000D69  1  10 03        		BPL OPENNEW4
000D6B  1  4C F8 10     		JMP ERR165
000D6E  1               
000D6E  1  20 05 12     OPENNEW4:	JSR INITDIR
000D71  1               
000D71  1  A5 00        OPENEXIS:	LDA FATPTRS				;remember directory position, FATPTRS...
000D73  1  8D A3 07     		STA DIRPTR
000D76  1  A5 01        		LDA FATPTRS+1
000D78  1  8D A4 07     		STA DIRPTR+1
000D7B  1               
000D7B  1  20 23 11     		JSR CHECKFCB
000D7E  1  30 E5        		BMI OPENERR
000D80  1               
000D80  1  A2 03        		LDX #3					; ... and SECTOR
000D82  1  B5 43        SAVEDIR1:	LDA SECTOR,X
000D84  1  9D A5 07     		STA DIRSEC,X
000D87  1  CA           		DEX
000D88  1  10 F8        		BPL SAVEDIR1
000D8A  1               
000D8A  1  A2 05        		LDX #5					;GET START
000D8C  1  A0 1F        		LDY #DCLUS+5				;CLUSTER
000D8E  1  B1 00        OPENF1:		LDA (FATPTRS),Y				;AND FILELEN
000D90  1  9D 7D 07     		STA FSTRTCL,X				;FROM
000D93  1  88           		DEY					;DIRENTRY
000D94  1  CA           		DEX
000D95  1  10 F7        		BPL OPENF1
000D97  1               
000D97  1  A5 2A        		LDA ICAX1Z				;IF READ
000D99  1  29 04        		AND #4					;FINISHED
000D9B  1  D0 2A        		BNE OPENEND
000D9D  1               
000D9D  1  A5 2A        		LDA ICAX1Z
000D9F  1  29 01        		AND #1					;WRITE + APPEND?
000DA1  1  D0 19        		BNE OPENAPPND				;YES
000DA3  1               
000DA3  1  20 69 16     		jsr LOAXSCLUS				;LOAD AX with file start cluster
000DA6  1  20 74 17     		jsr FREECLUS				;free all cluster associated with file
000DA9  1  20 70 16     		jsr STENDNCLUS				;store FATEND to NEWCLUS
000DAC  1  20 69 16     		jsr LOAXSCLUS
000DAF  1  20 C1 16     		jsr PUTCLUST
000DB2  1               
000DB2  1  A9 00        		LDA #0					;clear FILELEN
000DB4  1  A2 03        		LDX #3
000DB6  1  9D 7F 07     OPENW4:		STA FILELEN,X
000DB9  1  CA           		DEX
000DBA  1  10 FA        		BPL OPENW4
000DBC  1               
000DBC  1  A2 03        OPENAPPND:	LDX #3					;
000DBE  1  BD 7F 07     OPENF3:		LDA FILELEN,X				;copy filelen
000DC1  1  9D 85 07     		STA FRPOS,X				;to file-read-pos
000DC4  1  CA           		DEX
000DC5  1  10 F7        		BPL OPENF3
000DC7  1               
000DC7  1  4C 72 14     OPENEND:	JMP FSEEK				;seek to FRPOS (either 0 or FILELEN)
000DCA  1               
000DCA  1               ;-------------------------------------------------------------------------------
000DCA  1               ; Handler routine Close-Channel
000DCA  1               ;-------------------------------------------------------------------------------
000DCA  1  20 63 11     CLOSECHA:	jsr SETFCB
000DCD  1               
000DCD  1               ;		lda #'C'
000DCD  1               ;		jsr PRINT
000DCD  1               
000DCD  1  A5 2A        		lda ICAX1Z
000DCF  1  29 04        		and #4
000DD1  1  D0 2D        		bne CLOSE5				;just close FCB if read access
000DD3  1               
000DD3  1  20 97 17     		jsr WRITEFAT
000DD6  1               
000DD6  1  A2 03        		ldx #3					;otherwise update directory
000DD8  1  BD A5 07     CLOSE3:		lda DIRSEC,X				;with file-length
000DDB  1               ;		jsr PUTHEX
000DDB  1  95 43        		sta SECTOR,X				;first get directory sector
000DDD  1  CA           		dex
000DDE  1  10 F8        		bpl CLOSE3
000DE0  1               
000DE0  1               ;		jsr NEWLINE
000DE0  1  20 F6 17     		jsr READSEC
000DE3  1               
000DE3  1  AD A3 07     		lda DIRPTR				;point into the dir-sec
000DE6  1  85 02        		sta FATPTRD
000DE8  1  AD A4 07     		lda DIRPTR+1
000DEB  1  85 03        		sta FATPTRD+1
000DED  1               
000DED  1  A0 1F        		ldy #DLEN+3				;copy file-length into direntry
000DEF  1  8C 3D 07     		sty DDIRTY
000DF2  1  A2 03        		ldx #3
000DF4  1  BD 7F 07     CLOSE4:		lda FILELEN,X
000DF7  1  91 02        		sta (FATPTRD),Y
000DF9  1  88           		dey
000DFA  1  CA           		dex
000DFB  1  10 F7        		bpl CLOSE4
000DFD  1               
000DFD  1  4C DD 0F     		jmp DELETE8				;WRITESEC, CLOSEFCB, OK
000E00  1               
000E00  1               CLOSE5:
000E00  1               ;		LDA #'-'
000E00  1               ;		jsr PRINT
000E00  1  4C E0 0F     		jmp DELETE9				;CLOSEFCB, OK
000E03  1               
000E03  1               ;-------------------------------------------------------------------------------
000E03  1               ; Handler routine GET-Channel
000E03  1               ;-------------------------------------------------------------------------------
000E03  1  20 63 11     GETCHA:		JSR SETFCB
000E06  1  A5 2A        		lda ICAX1Z
000E08  1  29 02        		AND #2
000E0A  1  F0 7A        		BEQ READBYTE				;if Bit 2 is clear, file access
000E0C  1               
000E0C  1               ;-------------------------------------------------------------------------------
000E0C  1               ; Handler routine GET-Channel directory access
000E0C  1               ;-------------------------------------------------------------------------------
000E0C  1  AC 6A 07     GETDIR:		LDY HILF				;each call to GETDIR return just one byte
000E0F  1  10 03        		BPL GETDIR6				;HILF counts the bytes in one dir entry
000E11  1  A0 88        		LDY #EOF				;HILF initialised to zero in OPENDI
000E13  1  60           		RTS
000E14  1               
000E14  1  D0 3F        GETDIR6:	BNE GETDIR1				; Y > 0, get next byte of dirname
000E16  1               
000E16  1  A9 20        		LDA #32					; Y==0, init DIRLINE
000E18  1  8D 58 07     		STA DIRLINE+8
000E1B  1  8D 5C 07     		STA DIRLENG-1
000E1E  1  A9 9B        		LDA #EOL
000E20  1  8D 67 07     		STA DIREOF
000E23  1               
000E23  1  A2 00        		LDX #0					; copy DIR-info
000E25  1  B1 00        GETDIR3:	LDA (FATPTRS),Y				; from sector-buffer
000E27  1  9D 50 07     		STA DIRLINE,X				; into DIRLINE
000E2A  1  E8           		INX
000E2B  1  C8           		INY
000E2C  1  C0 08        		CPY #8					; 8.3 jump over " "
000E2E  1  D0 01        		BNE GETDIR3A
000E30  1  E8           		INX
000E31  1               
000E31  1  C0 0B        GETDIR3A:	CPY #11
000E33  1  D0 F0        		BNE GETDIR3
000E35  1               
000E35  1  A0 0B        		LDY #DATTRIB
000E37  1  B1 00        		LDA (FATPTRS),Y
000E39  1  A0 09        		LDY #9
000E3B  1  29 10        		AND #16					;ist directory?
000E3D  1  F0 0B        		BEQ GETDLEN				;no, get file length
000E3F  1               
000E3F  1  B9 7C 0E     GETDTXT:	LDA DIRTXT,Y				;write "DIR" into
000E42  1  99 5D 07     		STA DIRLENG,Y				;output length
000E45  1  88           		DEY					;pos 9 downto 0
000E46  1  10 F7        		BPL GETDTXT
000E48  1  30 09        		BMI GETDIR5
000E4A  1               
000E4A  1  B9 31 07     GETDLEN:	LDA DECIMAL,Y
000E4D  1  99 5D 07     		STA DIRLENG,Y
000E50  1  88           		DEY
000E51  1  10 F7        		BPL GETDLEN
000E53  1               
000E53  1  A0 00        GETDIR5:	LDY #0
000E55  1               
000E55  1  EE 6A 07     GETDIR1:	INC HILF
000E58  1  B9 50 07     		LDA DIRLINE,Y				;if Y points to end in DIRLINE
000E5B  1  C9 9B        		CMP #EOL				;read next dir entry
000E5D  1  D0 14        		BNE GETDIR7
000E5F  1               
000E5F  1  20 EA 12     		JSR NEXTFILE
000E62  1  30 09        		BMI GETDIR9
000E64  1               
000E64  1  A0 00        		LDY #0
000E66  1  8C 6A 07     		STY HILF
000E69  1               
000E69  1  B1 00        		LDA (FATPTRS),Y
000E6B  1  D0 04        		BNE GETDIR8
000E6D  1               
000E6D  1  88           GETDIR9:	DEY
000E6E  1  8C 6A 07     		STY HILF				;NEG.
000E71  1               
000E71  1  A9 9B        GETDIR8:	LDA #EOL
000E73  1               
000E73  1               GETDIR7:
000E73  1               	.IF PLATFORM > 0
000E73  1  C9 7E        		CMP #$7E				; "~" in "-"
000E75  1  D0 02        		BNE GETDIR2
000E77  1  A9 2D        		LDA #'-'
000E79  1               	.ENDIF
000E79  1  A0 01        GETDIR2:	LDY #1
000E7B  1  60           		RTS
000E7C  1               
000E7C  1               ;		      "0123456789"
000E7C  1  20 20 20 20  DIRTXT:		.byte "       DIR"
000E80  1  20 20 20 44  
000E84  1  49 52        
000E86  1               ;
000E86  1               
000E86  1               ;-------------------------------------------------------------------------------
000E86  1               ; Handler routine GET-Channel file access
000E86  1               ; check if we can read an entire sector directly into destination buffer
000E86  1               ; if not do a single-byte read
000E86  1               ;-------------------------------------------------------------------------------
000E86  1  20 AA 13     READBYTE:	JSR CHECKLEN				;still bytes to read available
000E89  1  90 03        		BCC READBYT1
000E8B  1  A0 88        		LDY #EOF
000E8D  1  60           		RTS
000E8E  1               
000E8E  1  A4 00        READBYT1:	LDY FATPTRS				;FATPTRS must point to begin of buffer, check LO-byte=0
000E90  1  D0 57        		BNE READSLOW				;no
000E92  1               
000E92  1  A5 29        		LDA ICBLHZ				;still >= 512 bytes to be read?
000E94  1  C9 02        		CMP #2
000E96  1  90 51        		BCC READSLOW				;no
000E98  1  A5 22        		LDA ICCOMZ				;only GETCHAR allowed, not GETREC
000E9A  1  C9 07        		CMP #GETCHR
000E9C  1  D0 4B        		BNE READSLOW
000E9E  1  A5 01        		LDA FATPTRS+1
000EA0  1  C9 09        		CMP #>BUFFER				;FATPTRS must point to begin of buffer
000EA2  1  D0 45        		BNE READSLOW
000EA4  1               
000EA4  1               ;		SEC					;carry set from prev. CMP, still more than 512 bytes in the files available?
000EA4  1  AD 7F 07     		LDA FILELEN				;filelen can't be greater then 64k (not true!! TODO!)
000EA7  1  ED 85 07     		SBC FRPOS
000EAA  1  AD 80 07     		LDA FILELEN+1
000EAD  1  ED 86 07     		SBC FRPOS+1
000EB0  1  C9 02        		CMP #2
000EB2  1  90 35        		BCC READSLOW
000EB4  1               
000EB4  1               ;		JSR IODUMP
000EB4  1               
000EB4  1               ;-------------------------------------------------------------------------------
000EB4  1               ; copy Buffer to destination and read next one
000EB4  1               ;-------------------------------------------------------------------------------
000EB4  1  B9 00 09     READFAST:	LDA BUFFER,Y				;buffer must be page aligned, Y = 0 from above
000EB7  1  91 24        		sta_icbalz_y
000EB9  1  88           		DEY
000EBA  1  D0 F8        		BNE READFAST
000EBC  1  E6 25        		INC ICBAHZ				;increase destination page
000EBE  1               	.IF PLATFORM=0
000EBE  1               		bne READFA1
000EBE  1               		inc ICBABZ
000EBE  1               	.ENDIF
000EBE  1  B9 00 0A     READFA1:	LDA BUFFER+$100,Y
000EC1  1  91 24        		sta_icbalz_y
000EC3  1  C8           		INY
000EC4  1  D0 F8        		BNE READFA1
000EC6  1               
000EC6  1  85 2F        		STA CIOCHR
000EC8  1  E6 25        		INC ICBAHZ				;increase destination page
000ECA  1               	.IF PLATFORM=0
000ECA  1               		bne READFA3A
000ECA  1               		inc ICBABZ
000ECA  1               	.ENDIF
000ECA  1               
000ECA  1               READFA3A:
000ECA  1               	.IF PLATFORM=0
000ECA  1               		lda ICBLHZ
000ECA  1               		bne READFA3B
000ECA  1               		dec ICBLBZ
000ECA  1               READFA3B:	dec ICBLHZ
000ECA  1               		bne READFA3C
000ECA  1               		dec ICBLBZ
000ECA  1               READFA3C:	dec ICBLHZ
000ECA  1               	.ELSE
000ECA  1  C6 29        		DEC ICBLHZ				;decrease bytes to read by 512
000ECC  1  C6 29        		DEC ICBLHZ
000ECE  1               	.ENDIF
000ECE  1  20 D1 13     		JSR INCRPOS512				;increase FRPOS by 512
000ED1  1               
000ED1  1  20 FC 13     		JSR INCSEC				;read next sector/cluster
000ED4  1               
000ED4  1  A5 29        		LDA ICBLHZ				;no more to be read?
000ED6  1  05 28        		ORA ICBLLZ
000ED8  1               	.IF PLATFORM=0
000ED8  1               		ora ICBLBZ
000ED8  1               	.ENDIF
000ED8  1  D0 AC        		bne READBYTE
000EDA  1               
000EDA  1               ;		BEQ READFA4
000EDA  1               ;		JMP READBYTE
000EDA  1               
000EDA  1  E6 28        READFA4:	INC ICBLLZ				;set buffer length to 1
000EDC  1  A5 24        		LDA ICBALZ				;decrement buffer address
000EDE  1  D0 02        		BNE READFA5				;since CIO routine always expects one byte
000EE0  1               
000EE0  1               	.IF PLATFORM=0
000EE0  1               		lda ICBAHZ
000EE0  1               		bne READFA6
000EE0  1               		dec ICBABZ
000EE0  1               	.ENDIF
000EE0  1               
000EE0  1  C6 25        READFA6:	DEC ICBAHZ
000EE2  1  C6 24        READFA5:	DEC ICBALZ
000EE4  1  A5 2F        		LDA CIOCHR
000EE6  1  4C F9 0E     		JMP READBYT5				;exit success, Y=1
000EE9  1               
000EE9  1               ;-------------------------------------------------------------------------------
000EE9  1               ; Handler routine GET-Channel file access, read single byte
000EE9  1               ;-------------------------------------------------------------------------------
000EE9  1  A0 00        READSLOW:	LDY #0
000EEB  1  B1 00        		LDA (FATPTRS),Y
000EED  1  85 2F        		STA CIOCHR
000EEF  1               
000EEF  1  20 CB 13     		JSR INCRPOS
000EF2  1  20 F0 13     		JSR INCPTR
000EF5  1  30 04        		BMI READBYT2
000EF7  1               
000EF7  1  A5 2F        		LDA CIOCHR
000EF9  1  A0 01        READBYT5:	LDY #1
000EFB  1  60           READBYT2:	RTS
000EFC  1               
000EFC  1               ;-------------------------------------------------------------------------------
000EFC  1               ; Handler routine PUT-Channel file access
000EFC  1               ;-------------------------------------------------------------------------------
000EFC  1  85 2F        PUTCHA:		STA CIOCHR				; save byte, could have been called via ICPTLZ
000EFE  1               
000EFE  1  20 63 11     		JSR SETFCB
000F01  1               
000F01  1  A5 2A        		LDA ICAX1Z				;also READ => UPDATE?
000F03  1  29 04        		AND #4					;ceck filelen
000F05  1  F0 08        		BEQ PUTCHA1				;no
000F07  1               
000F07  1  20 AA 13     PUTUPD:		JSR CHECKLEN				;file-pos less than filelen
000F0A  1  90 59        		BCC PUTSLOW1				;yes, continue slow
000F0C  1  A0 88        PUTUPD1:	LDY #EOF				;signal error
000F0E  1  60           		RTS
000F0F  1               
000F0F  1  A4 00        PUTCHA1:	LDY FATPTRS				;points to begin of page?
000F11  1  D0 4F        		BNE PUTSLOW
000F13  1  A5 29        		LDA ICBLHZ				;at least 512 bytes To write?
000F15  1  C9 02        		CMP #2
000F17  1  90 49        		BCC PUTSLOW
000F19  1  A5 01        		LDA FATPTRS+1				;points to begin of buffer?
000F1B  1  C9 09        		CMP #>BUFFER
000F1D  1  D0 43        		BNE PUTSLOW
000F1F  1  A5 22        		LDA ICCOMZ				;binary put?
000F21  1  C9 0B        		CMP #PUTCHR
000F23  1  D0 3D        		BNE PUTSLOW
000F25  1               
000F25  1               ;-------------------------------------------------------------------------------
000F25  1               ; Handler routine PUT-Channel file access, put entire sector
000F25  1               ;-------------------------------------------------------------------------------
000F25  1  EE 83 07     PUTFAST:	INC FWBURST
000F28  1               		;LDY #0					;Y zero from above
000F28  1  B1 24        PUTFAST1:	lda_icbalz_y
000F2A  1  99 00 09     		STA BUFFER,Y
000F2D  1  C8           		INY
000F2E  1  D0 F8        		BNE PUTFAST1
000F30  1  E6 25        		INC ICBAHZ
000F32  1  B1 24        PUTFAST2:	lda_icbalz_y
000F34  1  99 00 0A     		STA BUFFER+$100,Y
000F37  1  C8           		INY
000F38  1  D0 F8        		BNE PUTFAST2
000F3A  1               
000F3A  1  C8           		INY
000F3B  1  8C 3D 07     		STY DDIRTY				;mark as dirty
000F3E  1               
000F3E  1  20 D1 13     		JSR INCRPOS512
000F41  1               
000F41  1  20 BD 13     		JSR INCFILELE2
000F44  1  20 BD 13     		JSR INCFILELE2
000F47  1               
000F47  1  38           		SEC
000F48  1  A5 28        		LDA ICBLLZ
000F4A  1  E9 FF        		SBC #$FF
000F4C  1  85 28        		STA ICBLLZ
000F4E  1  A5 29        		LDA ICBLHZ
000F50  1  E9 01        		SBC #1
000F52  1  85 29        		STA ICBLHZ
000F54  1               	.IF PLATFORM=0
000F54  1               		lda ICBLBZ
000F54  1               		sbc #0
000F54  1               		sta ICBLBZ
000F54  1               	.ENDIF
000F54  1               
000F54  1  18           		CLC
000F55  1  A5 24        		LDA ICBALZ
000F57  1  69 FF        		ADC #$FF
000F59  1  85 24        		STA ICBALZ
000F5B  1  90 02        		BCC PUTFAST3
000F5D  1  E6 25        		INC ICBAHZ
000F5F  1               	.IF PLATFORM=0
000F5F  1               		bne PUTFAST3
000F5F  1               		inc ICBABZ
000F5F  1               	.ENDIF
000F5F  1               
000F5F  1  4C FC 13     PUTFAST3:	JMP INCSEC
000F62  1               
000F62  1               
000F62  1               ;-------------------------------------------------------------------------------
000F62  1               ; 1-byte PUT routine if not a whole sector is to be written
000F62  1               ;-------------------------------------------------------------------------------
000F62  1  20 B8 13     PUTSLOW:	JSR INCFILELEN
000F65  1  A5 2F        PUTSLOW1:	LDA CIOCHR
000F67  1  A0 00        		LDY #0
000F69  1  91 00        		STA (FATPTRS),Y
000F6B  1  C8           		INY
000F6C  1  8C 3D 07     		STY DDIRTY
000F6F  1               
000F6F  1  20 CB 13     		JSR INCRPOS
000F72  1  4C F0 13     		JMP INCPTR
000F75  1               
000F75  1               ;-------------------------------------------------------------------------------
000F75  1               ; SPACIAL Handler routine dispatcher
000F75  1               ;-------------------------------------------------------------------------------
000F75  1  BA           SPECIAL:	TSX
000F76  1  86 48                        STX STCKPTR
000F78  1               
000F78  1  20 EB 10                     jsr CHECKHAN				;position to ':'
000F7B  1  30 17        		bmi SPECIAL3
000F7D  1               
000F7D  1  A5 22        		LDA ICCOMZ				;search for command in table
000F7F  1  A2 04        		LDX #(XFUNCEND-XFUNC)
000F81  1  DD 95 0F     SPECIAL2:	CMP XFUNC,X
000F84  1  F0 06        		BEQ SPECIAL1
000F86  1  CA           		DEX
000F87  1  10 F8        		BPL SPECIAL2
000F89  1  A0 84        		LDY #132				;command not found
000F8B  1  60           		RTS
000F8C  1               
000F8C  1  BD 9A 0F     SPECIAL1:       LDA XJMPTABH,X				;jump to special-function
000F8F  1  48           		PHA
000F90  1  BD 9F 0F     		LDA XJMPTABL,X
000F93  1  48           		PHA
000F94  1  60           SPECIAL3:	RTS
000F95  1               
000F95  1  21           XFUNC:		.byte CDELETE
000F96  1  29           		.byte CCHADIR
000F97  1  20           		.byte CRENAME
000F98  1  22           		.byte CCREDIR
000F99  1  2A           XFUNCEND:	.byte CCREDIR1
000F9A  1               
000F9A  1               
000F9A  1  0F           XJMPTABH:	.byte >(DELETE-1)
000F9B  1  0F           		.byte >(CHADIR-1)
000F9C  1  10           		.byte >(RENAME-1)
000F9D  1  10           		.byte >(CREDIR-1)
000F9E  1  10           		.byte >(CREDIR-1)
000F9F  1               
000F9F  1  A3           XJMPTABL:	.byte <(DELETE-1)
000FA0  1  E6           		.byte <(CHADIR-1)
000FA1  1  2F           		.byte <(RENAME-1)
000FA2  1  87           		.byte <(CREDIR-1)
000FA3  1  87           		.byte <(CREDIR-1)
000FA4  1               
000FA4  1               ;-------------------------------------------------------------------------------
000FA4  1               ; SPECIAL-handler for DELETE file
000FA4  1               ; todo: directory
000FA4  1               ;-------------------------------------------------------------------------------
000FA4  1               DELETE:
000FA4  1  20 4C 11     		JSR OPENFCB
000FA7  1  30 3D        		BMI NOTOK
000FA9  1               
000FA9  1  A9 01        		LDA #1					;does file exist?
000FAB  1  20 D1 12     		JSR GETFILE
000FAE  1  30 30        		BMI DELETE9				;no or other error, return OK
000FB0  1               
000FB0  1  20 23 11     DELETE2:	JSR CHECKFCB
000FB3  1  30 20        		BMI DELETE3
000FB5  1               
000FB5  1  A5 00        		LDA FATPTRS				;save pointer into directory
000FB7  1  48           		PHA
000FB8  1  A5 01        		LDA FATPTRS+1
000FBA  1  48           		PHA
000FBB  1               
000FBB  1  A0 1A        		LDY #DCLUS				;LOAD AX with first cluster
000FBD  1  B1 00        		LDA (FATPTRS),Y
000FBF  1  AA           		TAX
000FC0  1  C8           		INY
000FC1  1  B1 00        		LDA (FATPTRS),Y
000FC3  1  20 74 17     		JSR FREECLUS				;free all cluster
000FC6  1               
000FC6  1  68           		PLA
000FC7  1  85 01        		STA FATPTRS+1
000FC9  1  68           		PLA
000FCA  1  85 00        		STA FATPTRS
000FCC  1               
000FCC  1               ;		lda #'P'
000FCC  1               ;		jsr PRINT
000FCC  1               ;		lda FATPTRS+1
000FCC  1               ;		jsr PUTHEX
000FCC  1               ;		lda FATPTRS
000FCC  1               ;		jsr PUTHEX
000FCC  1               ;		jsr NEWLINE
000FCC  1               
000FCC  1  A0 00        		LDY #DNAME
000FCE  1  A9 E5        		LDA #$E5
000FD0  1  91 00        		STA (FATPTRS),Y
000FD2  1  8D 3D 07     		STA DDIRTY
000FD5  1               
000FD5  1               DELETE3:	;tya
000FD5  1               		;jsr PUTHEX
000FD5  1  20 EA 12     		JSR NEXTFILE
000FD8  1  10 D6        		BPL DELETE2
000FDA  1               
000FDA  1  20 97 17     DELETE7:	JSR WRITEFAT
000FDD  1  20 DF 17     DELETE8:	JSR WRITESEC
000FE0  1  20 17 11     DELETE9:	JSR CLOSEFCB
000FE3  1  A0 01        OK:		LDY #1
000FE5  1  18           		CLC
000FE6  1  60           NOTOK:		RTS
000FE7  1               
000FE7  1               ;-------------------------------------------------------------------------------
000FE7  1               ; SPECIAL-handler for CHANGE Directory
000FE7  1               ;-------------------------------------------------------------------------------
000FE7  1  AC 68 07     CHADIR:		LDY SAVEY
000FEA  1  B1 24        CHADIR2:	lda_icbalz_y				;is '/' access from ROOT?
000FEC  1  C9 2F        		cmp #'/'
000FEE  1  D0 0A        		bne CHADIR3				;no
000FF0  1               
000FF0  1  A9 00        		lda #0					;set DIRCLUS to 0
000FF2  1  8D 41 07     		sta DIRCLUS
000FF5  1  8D 42 07     		sta DIRCLUS+1
000FF8  1  F0 F0        		beq CHADIR2				;read next char
000FFA  1               
000FFA  1  C9 9B        CHADIR3:	cmp #EOL				;end of filename?
000FFC  1  F0 E2        		beq DELETE9				;yes, exit OK
000FFE  1               
000FFE  1  A9 03        CHADIR3C:	lda #3					;read only dirs
001000  1  20 9A 13     		jsr DIRSTART				;copy DIRCLUS to FSTRTCL
001003  1  20 4C 12     		jsr STR2RAW				;generate matching string
001006  1  88           		dey
001007  1  8C 68 07     		sty SAVEY
00100A  1               
00100A  1  20 FD 12     		jsr OPENDIR				;find first directory
00100D  1  B0 1E        		bcs CHADIR170				;not found
00100F  1  20 DD 12     CHADIR3A:	jsr FINDFIL1				;loop until matching dir found
001012  1  30 19        		bmi CHADIR170				;no
001014  1               
001014  1  A0 1A        CHADIR1:	ldy #DCLUS				;get DIRCLUS from found directory
001016  1  B1 00        		lda (FATPTRS),Y
001018  1  8D 41 07     		sta DIRCLUS
00101B  1  C8           		iny
00101C  1  B1 00        		lda (FATPTRS),Y
00101E  1  8D 42 07     		sta DIRCLUS+1
001021  1               
001021  1  AC 68 07     CHADIR4:	ldy SAVEY				;go over '/' and change directory again
001024  1  B1 24        CHADIR5:	lda_icbalz_y
001026  1  C9 2F        		cmp #'/'
001028  1  D0 D0        		bne CHADIR3
00102A  1  C8           		iny
00102B  1  D0 F7        		bne CHADIR5
00102D  1               
00102D  1  4C 60 0D     CHADIR170:	jmp OPEN170
001030  1               
001030  1               ;-------------------------------------------------------------------------------
001030  1               ; SPECIAL-handler for RENAME (file / directory)
001030  1               ;-------------------------------------------------------------------------------
001030  1  AC 68 07     RENAME:		ldy SAVEY
001033  1  B1 24        RENAME2:	lda_icbalz_y
001035  1  C9 2C        		CMP #','
001037  1  F0 0A        		BEQ RENAME1	;FOUND
001039  1  C9 9B        		CMP #EOL
00103B  1  F0 03        		BEQ RENAME8
00103D  1  C8           		INY
00103E  1  D0 F3        		BNE RENAME2
001040  1  4C F8 10     RENAME8:	JMP ERR165
001043  1               
001043  1  A9 9B        RENAME1:	lda #EOL				;',' -> eol
001045  1  91 24        		sta_icbalz_y
001047  1               
001047  1  C8           		INY
001048  1  20 4C 12     		JSR STR2RAW				;convert target string in 8+3
00104B  1               
00104B  1  EE 69 07     		INC VALIDS
00104E  1  20 C5 11     		JSR VALIDNAM
001051  1  08           		PHP
001052  1  CE 69 07     		DEC VALIDS
001055  1  28           		PLP
001056  1  30 E8        		BMI RENAME8
001058  1               
001058  1  A2 0A        RENAME4:	LDX #10					;save string in DIRRENA
00105A  1  BD 98 07     RENAME3:	LDA DIRTEXT,X
00105D  1  9D 43 07     		STA DIRRENA,X
001060  1  CA           		DEX
001061  1  10 F7        		BPL RENAME3
001063  1               
001063  1  A0 00        		LDY #0					;convert search string
001065  1  20 4C 12     		jsr STR2RAW
001068  1               
001068  1  A9 00        		LDA #0
00106A  1  20 D1 12     		JSR GETFILE
00106D  1  30 16        		BMI RENAME9
00106F  1               
00106F  1  A0 0A        RENAME7:	LDY #10
001071  1  8C 3D 07     		STY DDIRTY
001074  1  B9 43 07     RENAME6:	LDA DIRRENA,Y
001077  1  C9 3F        		CMP #'?'
001079  1  F0 02        		BEQ RENAME5
00107B  1  91 00        		STA (FATPTRS),Y
00107D  1  88           RENAME5:	DEY
00107E  1  10 F4        		BPL RENAME6
001080  1               
001080  1  20 EA 12     		JSR NEXTFILE
001083  1  10 EA        		BPL RENAME7
001085  1               
001085  1  4C DD 0F     RENAME9:	JMP DELETE8
001088  1               
001088  1               ;-------------------------------------------------------------------------------
001088  1               ; SPECIAL-handler for CREDIR (create directory)
001088  1               ;-------------------------------------------------------------------------------
001088  1  A9 03        CREDIR:		LDA #3
00108A  1  20 D1 12     		JSR GETFILE
00108D  1  30 03        		BMI CREDIR1				;directory must not exist
00108F  1  4C 60 0D     		JMP OPEN170
001092  1               
001092  1  20 C5 11     CREDIR1:	JSR VALIDNAM
001095  1  10 03        		BPL CREDIR3
001097  1  4C F8 10     		JMP ERR165
00109A  1               
00109A  1  A9 08        CREDIR3:	LDA #8					;get a free entry and initialize it
00109C  1  85 2A        		STA ICAX1Z
00109E  1  20 05 12     		JSR INITDIR				;FCURCLUS holds cluster of new directory
0010A1  1               
0010A1  1  A0 0B        		LDY #DATTRIB
0010A3  1  A9 10        		LDA #16					;set attribute directory
0010A5  1  91 00        		STA (FATPTRS),Y
0010A7  1               
0010A7  1  20 55 14     		JSR CLRCLUST
0010AA  1  20 0E 16     		JSR CLU2SEC
0010AD  1  20 F6 17     		JSR READSEC
0010B0  1               
0010B0  1  A2 0A        		LDX #10
0010B2  1  A9 20        		LDA #32
0010B4  1  9D 00 09     CREDIR6:	STA BUFFER,X
0010B7  1  9D 20 09     		STA BUFFER+32,X
0010BA  1  CA           		DEX
0010BB  1  10 F7        		BPL CREDIR6
0010BD  1               
0010BD  1  A9 2E        		LDA #'.'
0010BF  1  8D 00 09     		STA BUFFER
0010C2  1  8D 20 09     		STA BUFFER+32
0010C5  1  8D 21 09     		STA BUFFER+33
0010C8  1               
0010C8  1  A9 10        		LDA #16
0010CA  1  8D 0B 09     		STA BUFFER+DATTRIB
0010CD  1  8D 2B 09     		STA BUFFER+DATTRIB+32
0010D0  1               
0010D0  1  AD 8D 07     		LDA FCURCLUS
0010D3  1  8D 1A 09     		STA BUFFER+DCLUS
0010D6  1  AD 8E 07     		LDA FCURCLUS+1
0010D9  1  8D 1B 09     		STA BUFFER+DCLUS+1
0010DC  1               
0010DC  1  AD 41 07     		LDA DIRCLUS
0010DF  1  8D 3A 09     		STA BUFFER+DCLUS+32
0010E2  1  AD 42 07     		LDA DIRCLUS+1
0010E5  1  8D 3B 09     		STA BUFFER+DCLUS+33
0010E8  1               
0010E8  1  4C DA 0F     CREDIR4:	JMP DELETE7				;WRITESEC/FAT, CLOSEFCB
0010EB  1               
0010EB  1               ;
0010EB  1               ;FSTAT:		;JSR SETFCB
0010EB  1               ;;		BPL FSTAT2
0010EB  1               ;;		RTS
0010EB  1               ;
0010EB  1               ;FSTAT2:		LDY #5
0010EB  1               ;		LDX #3
0010EB  1               ;FSTAT1:		LDA FILELEN,X
0010EB  1               ;		sta_icbalz_y
0010EB  1               ;		DEY
0010EB  1               ;		DEX
0010EB  1               ;		BPL FSTAT1
0010EB  1               ;		JMP OK
0010EB  1               
0010EB  1               ;-------------------------------------------------------------------------------
0010EB  1               ; Check if second or third character is ":"
0010EB  1               ; return Err165 (Bad file name / file name error) if not
0010EB  1               ;-------------------------------------------------------------------------------
0010EB  1  A0 01        CHECKHAN:	LDY #1
0010ED  1  A9 3A        		LDA #':'
0010EF  1  D1 24        		cmp_icbalz_y
0010F1  1  F0 0A        		BEQ CHECKHA1
0010F3  1  C8           		INY
0010F4  1  D1 24        		cmp_icbalz_y
0010F6  1  F0 05        		BEQ CHECKHA1
0010F8  1  20 17 11     ERR165:		JSR CLOSEFCB
0010FB  1  A0 A4        		LDY #164				;iny = 165
0010FD  1  C8           CHECKHA1:	iny
0010FE  1  8C 68 07     		STY SAVEY
001101  1  60           		RTS
001102  1               
001102  1               
001102  1               
001102  1               ;-------------------------------------------------------------------------------
001102  1               ;GET FCB Structure 0-3
001102  1               ;Input 	FCBNO in Y
001102  1               ;Return FCB-offset in X
001102  1               ;-------------------------------------------------------------------------------
001102  1  A2 00        GETFCB:		LDX #0
001104  1  98           GETFCB0:	TYA
001105  1  DD 00 08     		CMP FCB0,X
001108  1  F0 0A        		BEQ GETFCB9
00110A  1  8A           		TXA
00110B  1  18           		CLC
00110C  1  69 40        		ADC #64
00110E  1  AA           		TAX
00110F  1  D0 F3        		BNE GETFCB0
001111  1  A0 A1        		LDY #161		;TOO MANY open files
001113  1  60           		RTS
001114  1  A0 01        GETFCB9:	LDY #1
001116  1  60           		RTS			;OPEN FILES
001117  1               
001117  1               ;-------------------------------------------------------------------------------
001117  1               ; mark current FCB as unassigned
001117  1               ;-------------------------------------------------------------------------------
001117  1  AE 7C 07     CLOSEFCB:	ldx FFCBOFF				;get OFFSET of current FCB
00111A  1  A9 FF        		lda #$FF				;switch off copy and original FCB
00111C  1  8D 7B 07     		sta FIOCBNR
00111F  1  9D 00 08     		sta FCB0,X
001122  1  60           		rts
001123  1               
001123  1               ;-------------------------------------------------------------------------------
001123  1               ; check if another file with same cluster open
001123  1               ;-------------------------------------------------------------------------------
001123  1  A2 00        CHECKFCB:	ldx #0
001125  1  BD 00 08     CHECKFCB2:	lda FCB0,X
001128  1  C9 FF        		cmp #$FF
00112A  1  F0 18        		beq CHECKFCB1				;FCB EMPTY
00112C  1  C5 2E        		cmp ICIDNO
00112E  1  F0 14        		beq CHECKFCB1				;own FCB
001130  1               
001130  1  A0 1A        		ldy #DCLUS
001132  1  B1 00        		lda (FATPTRS),Y
001134  1  DD 02 08     		cmp FCB0+2,X
001137  1  D0 0B        		bne CHECKFCB1
001139  1  C8           		iny
00113A  1  B1 00        		lda (FATPTRS),Y
00113C  1  DD 03 08     		cmp FCB0+3,X
00113F  1  D0 03        		bne CHECKFCB1
001141  1  A0 A7        		ldy #167
001143  1  60           		rts
001144  1               
001144  1  8A           CHECKFCB1:	txa
001145  1  18           		clc
001146  1  69 40        		adc #64
001148  1  AA           		tax
001149  1  D0 DA        		bne CHECKFCB2
00114B  1  60           		rts
00114C  1               
00114C  1               ;-------------------------------------------------------------------------------
00114C  1               ; Find an empty FCB in FCB table, clear it and swap-in
00114C  1               ;-------------------------------------------------------------------------------
00114C  1  A0 FF        OPENFCB:        LDY #$FF
00114E  1  20 02 11                     JSR GETFCB                              ;get FREE FCB
001151  1  30 71                        BMI SETFCB2				;no free available
001153  1               
001153  1  A5 2E        OPENFCB1:       LDA ICIDNO
001155  1  9D 00 08                     STA FCB0,X                              ;X holds offset to FCB0 from GETFCB
001158  1               
001158  1  A9 00                        LDA #0                                  ;CLEAR FCB
00115A  1  A0 2D                        LDY #FCBEND-F-1
00115C  1  9D 02 08     OPENFCB0:       STA FCB0+2,X
00115F  1  E8                           INX
001160  1  88                           DEY
001161  1  D0 F9                        BNE OPENFCB0
001163  1               
001163  1               ;-------------------------------------------------------------------------------
001163  1               ; swap-out and swap-in from FCB table to current FCB
001163  1               ;-------------------------------------------------------------------------------
001163  1  BA           SETFCB:		TSX
001164  1  E8                           INX
001165  1  E8                           INX
001166  1  86 48                        STX STCKPTR
001168  1               
001168  1  AD 7B 07                     LDA FIOCBNR				;optimisation: current FCB
00116B  1  C5 2E        		CMP ICIDNO				;already active?
00116D  1  F0 53        		BEQ SETFCB1				;yes, do nothing
00116F  1               
00116F  1  C9 FF        SWAPFCB:	CMP #$FF				;current FCB unassigned?
001171  1  F0 25        		BEQ SWAPIN				;yes, just swapin FCB
001173  1               
001173  1  A2 03        SEC2FSEC:	LDX #3					;save SECTOR
001175  1  B5 43        SEC2FSE1:	LDA SECTOR,X
001177  1  9D 94 07     		STA FSECTOR,X
00117A  1  CA           		DEX
00117B  1  10 F8        		BPL SEC2FSE1
00117D  1               
00117D  1  A5 00        PTR2FPTR:	LDA FATPTRS				;and FATPTRS
00117F  1  8D 92 07     		STA FCURPTR
001182  1  A5 01        		LDA FATPTRS+1
001184  1  8D 93 07     		STA FCURPTR+1
001187  1               
001187  1  A0 00        		LDY #0					;copy current FCB to FCB-table
001189  1  AE 7C 07     		LDX FFCBOFF
00118C  1  B9 7B 07     SWAPFCB0:	LDA FIOCBNR,Y
00118F  1  9D 00 08     		STA FCB0,X
001192  1  E8           		INX
001193  1  C8           		INY
001194  1  C0 2F        		CPY #FCBEND-F+1
001196  1  D0 F4        		BNE SWAPFCB0
001198  1               
001198  1  A4 2E        SWAPIN:		LDY ICIDNO
00119A  1  20 02 11     		JSR GETFCB
00119D  1               
00119D  1  A0 00        		LDY #0
00119F  1  BD 00 08     SWAPIN0:	LDA FCB0,X
0011A2  1  99 7B 07     		STA FIOCBNR,Y
0011A5  1  E8           		INX
0011A6  1  C8           		INY
0011A7  1  C0 2F        		CPY #FCBEND-F+1
0011A9  1  D0 F4        		BNE SWAPIN0
0011AB  1               
0011AB  1  A5 22        		LDA ICCOMZ				;if not OPEN command, read current sector
0011AD  1  C9 03        		CMP #OPEN				;of file and set PTR
0011AF  1  F0 11        		BEQ SETFCB1
0011B1  1  C9 21        		CMP #CDELETE
0011B3  1  F0 0D        		BEQ SETFCB1
0011B5  1               
0011B5  1  20 37 14     		jsr INCSEC5
0011B8  1  AD 92 07     		LDA FCURPTR
0011BB  1  85 00        		STA FATPTRS
0011BD  1  AD 93 07     		LDA FCURPTR+1
0011C0  1  85 01        		STA FATPTRS+1
0011C2  1               
0011C2  1  A0 01        SETFCB1:	LDY #1
0011C4  1  60           SETFCB2:	RTS
0011C5  1               
0011C5  1               ;-------------------------------------------------------------------------------
0011C5  1               ; COPY FCB FSECTOR to SECTOR and FCURPTR to FATPTRS and read SECTOR
0011C5  1               ;-------------------------------------------------------------------------------
0011C5  1               ;FSEC2SEC:	LDX #3
0011C5  1               ;FSEC2SE1:	LDA FSECTOR,X
0011C5  1               ;		STA SECTOR,X
0011C5  1               ;		DEX
0011C5  1               ;		BPL FSEC2SE1
0011C5  1               ;
0011C5  1               ;		RTS
0011C5  1               ;		JMP READSEC
0011C5  1               
0011C5  1               
0011C5  1               
0011C5  1               ;-------------------------------------------------------------------------------
0011C5  1               ; checks if filename contains only valid characters
0011C5  1               ; returns N=0 if yes
0011C5  1               ;-------------------------------------------------------------------------------
0011C5  1  A2 0A        VALIDNAM:	LDX #10
0011C7  1  BD 98 07     VALIDNA1:	LDA DIRTEXT,X				;CARD
0011CA  1  C9 30        		CMP #'0'
0011CC  1  90 0C        		BCC VALIDNA3				;< 0? => check special chars
0011CE  1  C9 3A        		CMP #'9'+1				;<= 9?
0011D0  1  90 25        		BCC VALIDNA2				;yes OK, next char
0011D2  1  C9 41        		CMP #'A'				;
0011D4  1  90 04        		BCC VALIDNA3				;< A? => check special chars
0011D6  1  C9 5B        		CMP #'Z'+1				;<= Z?
0011D8  1  90 1D        		BCC VALIDNA2				;yes OK, next char
0011DA  1               
0011DA  1  AC 69 07     VALIDNA3:	LDY VALIDS				;check for special chars
0011DD  1  D9 E6 11     VALIDNA4:	CMP VALIDCHA,Y
0011E0  1  F0 15        		BEQ VALIDNA2
0011E2  1  88           		DEY
0011E3  1  10 F8        		BPL VALIDNA4
0011E5  1  60           		RTS					;no valid char found, return N=1
0011E6  1               
0011E6  1  20 7E 21 40  VALIDCHA:	.byte " ~!@#$%&()-_^{}'?"		;usually test without "?", so 16+1 bytes!
0011EA  1  23 24 25 26  
0011EE  1  28 29 2D 5F  
0011F7  1               
0011F7  1  CA           VALIDNA2:	DEX
0011F8  1  10 CD        		BPL VALIDNA1	;X=$FF
0011FA  1               
0011FA  1  A9 20        		LDA #32		;check if first char != space
0011FC  1  CD 98 07     		CMP DIRTEXT
0011FF  1  F0 02        		BEQ VALIDNA9
001201  1               
001201  1               ;		CMP DIRTEXT+8
001201  1               ;		BEQ VALIDNA9
001201  1               
001201  1  E8           		INX		;X=0, make sure N=0
001202  1  60           		RTS
001203  1               
001203  1  CA           VALIDNA9:	DEX		;X=$FE, N=1
001204  1  60           		RTS
001205  1               
001205  1               ;-------------------------------------------------------------------------------
001205  1               ; initialize a new directory entry (used by OPEN and CREDIR)
001205  1               ; 1. get a new cluster (next cluster xFFF) for the file or dir
001205  1               ; 2. get a free dir entry
001205  1               ; 3. populate entry
001205  1               ;-------------------------------------------------------------------------------
001205  1  A2 02        INITDIR:	LDX #2					;start at cluster #2
001207  1  A9 00        		LDA #0
001209  1  20 7B 16     		JSR GETFCLUS				;get a free cluster for dir in NEWCLUS
00120C  1  20 62 16     		jsr LOAXNCLUS                           ;save NEWCLUS
00120F  1  48           		PHA
001210  1  8A           		TXA
001211  1  48           		PHA
001212  1               
001212  1  20 F8 12     		JSR FINDFDIR                            ;get deleted ($E5) or free ($00) entry
001215  1  B0 0A        		BCS INITDIR1				;free entry found
001217  1               
001217  1  68           		PLA					;no free dir, pop NEWCLUS and bail out of OPEN
001218  1  68           		PLA
001219  1  68           		PLA
00121A  1  68           		PLA
00121B  1  20 17 11     ERR169:		JSR CLOSEFCB				;todo: Cluster not freed!
00121E  1  A0 A9        		LDY #169
001220  1  60           		RTS
001221  1               
001221  1               INITDIR1:
001221  1  A0 00        		LDY #0					;DIRNAME IN
001223  1  8C A9 07     		STY DIRFILE				;RESET DIRFILE = all files
001226  1  B9 98 07     INITDIR2:	LDA DIRTEXT,Y				;DIR ENTRY
001229  1  91 00        		STA (FATPTRS),Y
00122B  1  C8           		INY
00122C  1  C0 0B        		CPY #11
00122E  1  D0 F6        		BNE INITDIR2
001230  1               
001230  1  A9 00        		LDA #0					;INITIALIZE
001232  1  91 00        INITDIR3:	STA (FATPTRS),Y				;REST
001234  1  C8           		INY
001235  1  C0 20        		CPY #32
001237  1  D0 F9        		BNE INITDIR3
001239  1               
001239  1  8C 3D 07     		STY DDIRTY				;PUT START
00123C  1  A0 1A        		LDY #DCLUS				;CLUSTER
00123E  1  68           		PLA					;INTO
00123F  1  8D 8D 07     		STA FCURCLUS
001242  1  91 00        		STA (FATPTRS),Y				;DIR ENTRY
001244  1  C8           		INY
001245  1  68           		PLA
001246  1  8D 8E 07     		STA FCURCLUS+1
001249  1  91 00        		STA (FATPTRS),Y
00124B  1               
00124B  1               ;		lda FATPTRS+1
00124B  1               ;		jsr PUTHEX
00124B  1               ;		lda FATPTRS
00124B  1               ;		jsr PUTHEX
00124B  1               ;		lda FCURCLUS+1
00124B  1               ;		jsr PUTHEX
00124B  1               ;		lda FCURCLUS
00124B  1               ;		jsr PUTHEX
00124B  1               ;		jsr NEWLINE
00124B  1               
00124B  1  60           		RTS
00124C  1               
00124C  1               ;-------------------------------------------------------------------------------
00124C  1               ; converts given filename-pattern into DIRTEXT 8+3 chars
00124C  1               ;-------------------------------------------------------------------------------
00124C  1  A2 0B        STR2RAW:	LDX #11			;fill DIRTEXT
00124E  1  A9 20        		LDA #32			;with spaces
001250  1  9D 97 07     S2R12:		STA DIRTEXT-1,X
001253  1  CA           		DEX
001254  1  D0 FA        		bne S2R12
001256  1               
001256  1  8E 4F 07     		STX WILD		;x = 0
001259  1               
001259  1  A9 2E        		LDA #'.'
00125B  1  D1 24        		cmp_icbalz_y		;first char '.' (local dir)?
00125D  1               ;		CMP (ICBALZ),Y
00125D  1  D0 0E        		BNE S2R1			;no, goto S2R1
00125F  1  8D 98 07     		STA DIRTEXT			;save in first char of DIRTEXT
001262  1  C8           		INY					;examine next input char
001263  1  D1 24        		cmp_icbalz_y
001265  1               ;		CMP (ICBALZ),Y		;also '.'?
001265  1  D0 06        		BNE S2R1			;no, goto S2R1
001267  1  8D 99 07     		STA DIRTEXT+1		;save in 2nd char of DIRTEXT
00126A  1  C8           		INY					;Y += 2 ?
00126B  1  C8           		INY
00126C  1  60           		RTS					;return
00126D  1               
00126D  1  20 8F 12     S2R1:		JSR S2R4		;call S2R4 until 8 chars processed
001270  1  B0 04        		BCS S2R2
001272  1  E0 08        		CPX #8
001274  1  D0 F7        		BNE S2R1
001276  1  C9 9B        S2R2:		CMP #EOL
001278  1  F0 14        		BEQ S2R6
00127A  1  C9 2F        		CMP #'/'
00127C  1  F0 10        		BEQ S2R6
00127E  1  A2 08        		LDX #8
001280  1  A9 00        		LDA #0
001282  1  8D 4F 07     		STA WILD
001285  1  20 8F 12     S2R5:		JSR S2R4
001288  1  B0 04        		BCS S2R6
00128A  1  E0 0B        		CPX #11
00128C  1  D0 F7        		BNE S2R5
00128E  1  60           S2R6:		RTS
00128F  1               
00128F  1  B1 24        S2R4:		lda_icbalz_y
001291  1               ;		LDA (ICBALZ),Y
001291  1               ;		JSR PRINT
001291  1  2C 4F 07     		BIT WILD		;wildcard active?
001294  1  30 26        		BMI S2R7		;yes => S2R7
001296  1               
001296  1  C8           		INY
001297  1  C9 2A        		CMP #'*'
001299  1  D0 05        		BNE S2R8
00129B  1  CE 4F 07     		DEC WILD
00129E  1  30 1C        		BMI S2R7
0012A0  1  C9 2E        S2R8:		CMP #'.'
0012A2  1  D0 06        		BNE S2R11
0012A4  1  E0 08        		CPX #8
0012A6  1  90 26        		BCC S2R3
0012A8  1  18           		CLC
0012A9  1  60           		RTS
0012AA  1  C9 20        S2R11:		CMP #32			;is space?
0012AC  1  F0 20        		BEQ S2R3		;yes => next
0012AE  1  C9 9B        		CMP #EOL
0012B0  1  F0 1C        		BEQ S2R3
0012B2  1  C9 2F        		CMP #'/'
0012B4  1  F0 18        		BEQ S2R3
0012B6  1  C9 00        		CMP #0
0012B8  1  F0 14        		BEQ S2R3
0012BA  1  D0 02        		BNE S2R9
0012BC  1  A9 3F        S2R7:		LDA #'?'
0012BE  1  C9 61        S2R9:		CMP #'a'
0012C0  1  90 06        		BCC S2R10
0012C2  1  C9 7B        		CMP #'z'+1
0012C4  1  B0 02        		BCS S2R10
0012C6  1  E9 1F        		SBC #31
0012C8  1  9D 98 07     S2R10:		STA DIRTEXT,X		;normal character
0012CB  1  E8           		INX
0012CC  1  18           		CLC
0012CD  1  60           		RTS
0012CE  1  E8           S2R3:		INX
0012CF  1  38           		SEC
0012D0  1  60           		RTS
0012D1  1               
0012D1  1               ;IODUMP:		LDX ICIDNO
0012D1  1               ;		LDY #0
0012D1  1               ;IODUMP1:	LDA IOCB,X
0012D1  1               ;		JSR PUTHEX
0012D1  1               ;		INX
0012D1  1               ;		INY
0012D1  1               ;		CPY #16
0012D1  1               ;		BNE IODUMP1
0012D1  1               ;		LDA #$9B
0012D1  1               ;		JSR PRINT
0012D1  1               ;		LDY #EOF
0012D1  1               ;		RTS
0012D1  1               
0012D1  1               ;-------------------------------------------------------------------------------
0012D1  1               ; Traverse directory and check if filename matches
0012D1  1               ; 0=ALL, 1=FILES, 2=FREE DIR, 3=DIR
0012D1  1               ;-------------------------------------------------------------------------------
0012D1  1  20 9A 13     GETFILE:	jsr DIRSTART				;initialise DIRFILE, FSTRTCL from DIRCLUST
0012D4  1  AC 68 07     		ldy SAVEY				;Y = 2 or 3 from CHECKHAN
0012D7  1  20 4C 12     		jsr STR2RAW				;convert to 11 chars including * to ?
0012DA  1  20 FD 12     		jsr OPENDIR				;position to first directory entry
0012DD  1               
0012DD  1  A0 0A        FINDFIL1:	ldy #10
0012DF  1  B9 98 07     FINDFIL3:	lda DIRTEXT,Y
0012E2  1  C9 3F        		cmp #'?'				;matches any character
0012E4  1  F0 0C        		beq FINDFIL2
0012E6  1  D1 00        		cmp (FATPTRS),Y				;matches character in directory?
0012E8  1  F0 08        		beq FINDFIL2
0012EA  1               
0012EA  1  20 11 13     NEXTFILE:	jsr NEXTDIR				;if not, get next directory entry
0012ED  1  90 EE        		bcc FINDFIL1				;check again
0012EF  1  A0 AA        		ldy #170				;no further entry, return EOF
0012F1  1  60           		rts
0012F2  1               
0012F2  1  88           FINDFIL2:	dey
0012F3  1  10 EA        		bpl FINDFIL3
0012F5  1  A0 01        		ldy #1
0012F7  1  60           FINDFILEND:	rts
0012F8  1               
0012F8  1               ;-------------------------------------------------------------------------------
0012F8  1               ; Find free directory entry starting from DIRCLUS
0012F8  1               ;-------------------------------------------------------------------------------
0012F8  1  A9 02        FINDFDIR:	LDA #2
0012FA  1  20 9A 13     		JSR DIRSTART				;fall through to OPENDIR
0012FD  1               
0012FD  1               ;-------------------------------------------------------------------------------
0012FD  1               ; Positions directory-cursor to first entry that matches DIRTEXT via CHECKDIR
0012FD  1               ; (file/dir or both) or first empty dir
0012FD  1               ;-------------------------------------------------------------------------------
0012FD  1  20 69 16     OPENDIR:	jsr LOAXSCLUS                           ;Start cluster zero, then root Dir
001300  1  D0 09        		bne OPENDIR1				;X (FSTRTCL) not zero
001302  1  A8           		tay					;test A (FSTRTCL+1)
001303  1  D0 06        		bne OPENDIR1
001305  1               
001305  1  20 8D 13     		JSR CROOT
001308  1  4C 16 13     		JMP CHECKDIR				;loop until first suitable entry is found
00130B  1               
00130B  1  20 34 14     OPENDIR1:	jsr INCSEC4                             ;store AX, cluster2sec, reset ptr and readsec
00130E  1  4C 16 13     		JMP CHECKDIR
001311  1               
001311  1               
001311  1               ;-------------------------------------------------------------------------------
001311  1               ; positions to next available dir entry via READDIR and CHECKDIR
001311  1               ;-------------------------------------------------------------------------------
001311  1  20 56 13     NEXTDIR:	jsr READDIR
001314  1  B0 3F        		bcs NEXTDIR9				;No further Dir, RTS
001316  1               
001316  1               CHECKDIR:	;jsr DUMPSEC
001316  1  AE A9 07     		ldx DIRFILE
001319  1               
001319  1  A0 00        		ldy #DNAME				;check first char of entry-name
00131B  1  B1 00        		lda (FATPTRS),Y
00131D  1  C9 E5        		cmp #DEL				;or entry deleted?
00131F  1  D0 05        		bne NEXTDIR2				;no
001321  1               
001321  1  E0 02        		cpx #2					;looking for free dir?
001323  1  D0 EC        		bne NEXTDIR				;no, loop
001325  1               CHECKDIR1:	;sec					;yes, end C=1, set by cpx and cmp
001325  1  60           		rts
001326  1               
001326  1  E0 02        NEXTDIR2:	cpx #2					;not empty and looking for free dir?
001328  1  F0 E7        		beq NEXTDIR				;yes, loop
00132A  1               
00132A  1  A0 0B        		ldy #DATTRIB
00132C  1  B1 00        		lda (FATPTRS),Y				;SKIP
00132E  1  29 08        		and #8					;VOLUME
001330  1  D0 DF        		bne NEXTDIR				;LABEL
001332  1               
001332  1  8A           		txa					;DIRFILE = 0?
001333  1  F0 10        		beq NEXTDIR3				;file/dir found
001335  1               
001335  1  B1 00        		lda (FATPTRS),Y				;DIR?
001337  1  29 10        		and #16
001339  1  E0 03        		cpx #3
00133B  1  D0 05        		bne NEXTDIR4				;we are looking for files
00133D  1  AA           		tax					;we are looking for dirs
00133E  1  D0 05        		bne NEXTDIR3				;dir found
001340  1  F0 CF        		beq NEXTDIR				;oherwise loop
001342  1               
001342  1  AA           NEXTDIR4:	tax					;looking for files, but dir found
001343  1  D0 CC        		bne NEXTDIR
001345  1               
001345  1  A0 1F        NEXTDIR3:	ldy #DLEN+3				;copy 4-byte file length to bin
001347  1  B1 00        NEXTDIR1:	lda (FATPTRS),Y
001349  1  99 0C 07     		sta BIN-DLEN,Y
00134C  1  88           		dey
00134D  1  C0 1C        		cpy #DLEN
00134F  1  B0 F6        		bcs NEXTDIR1
001351  1               
001351  1  20 A4 18     		jsr BIN2DEC				;and convert to decimal
001354  1  18           		clc
001355  1  60           NEXTDIR9:	rts
001356  1               
001356  1               
001356  1               ;-------------------------------------------------------------------------------
001356  1               ; adds 32 to the current position of PTR in directory sector
001356  1               ; check FSTARTCL if root directory or not
001356  1               ; read next sector/cluster required
001356  1               ; return C = 1 if end of dir-cluster or zero-entry reached
001356  1               ;
001356  1               ; todo:
001356  1               ;-------------------------------------------------------------------------------
001356  1  A0 00        READDIR:        LDY #DNAME
001358  1  B1 00        		LDA (FATPTRS),Y
00135A  1  F0 2F        		BEQ READDIR3                            ;if zero: end of dirs reached
00135C  1               
00135C  1  18                   	CLC
00135D  1  A5 00        		LDA FATPTRS
00135F  1  69 20        		ADC #32
001361  1  85 00        		STA FATPTRS
001363  1  A5 01        		LDA FATPTRS+1
001365  1  69 00        		ADC #0
001367  1  85 01        		STA FATPTRS+1
001369  1  C9 0B        		CMP #(>BUFFER)+2
00136B  1  D0 0B        		BNE READDIR2		                ;OK => CLC,RTS
00136D  1               
00136D  1  AD 7D 07     		LDA FSTRTCL                             ;if root dir, inc sector
001370  1  0D 7E 07     		ORA FSTRTCL+1
001373  1  D0 05        		bne READDIR1
001375  1               
001375  1  20 07 14     		JSR INCSEC7                             ;root dir, inc sector, reset ptr, readsec
001378  1  18           READDIR2:	CLC
001379  1  60           		RTS
00137A  1               
00137A  1  20 FC 13     READDIR1:	JSR INCSEC                              ;inc sector/cluster etc.
00137D  1  A9 0F        		LDA #>FATEND
00137F  1  CD 8E 07     		CMP FCURCLUS+1
001382  1  D0 F4        		BNE READDIR2
001384  1  A9 FF        		LDA #<FATEND
001386  1  CD 8D 07     		CMP FCURCLUS
001389  1  D0 ED        		BNE READDIR2
00138B  1               
00138B  1  38           READDIR3:	SEC
00138C  1  60           		RTS
00138D  1               
00138D  1               ;-------------------------------------------------------------------------------
00138D  1               ; position to start of root-directory
00138D  1               ; SECTOR = DIRBASE, FSTRTCL = 0
00138D  1               ;-------------------------------------------------------------------------------
00138D  1  A2 04        CROOT:		LDX #4
00138F  1  BD 13 07     CROOT1:		LDA DIRBASE-1,X
001392  1  95 42        		STA SECTOR-1,X
001394  1  CA           		DEX
001395  1  D0 F8        		bne CROOT1
001397  1               
001397  1               ;		STX FSTRTCL				;X = 0
001397  1               ;		STX FSTRTCL+1
001397  1  4C 3A 14     CROOT2:         JMP INCSEC6                             ;reset ptr, readsec
00139A  1               
00139A  1               ;-------------------------------------------------------------------------------
00139A  1               ; save A in DIRFILE function code)
00139A  1               ; copy DIRCLUS to FSTARTCL
00139A  1               ;
00139A  1               ; DIRFILE	0=ALL, 1=FILES, 2=FREE DIR, 3=DIR
00139A  1               ;-------------------------------------------------------------------------------
00139A  1  8D A9 07     DIRSTART:	STA DIRFILE
00139D  1  AD 41 07     		LDA DIRCLUS
0013A0  1  8D 7D 07     		STA FSTRTCL
0013A3  1  AD 42 07     		LDA DIRCLUS+1
0013A6  1  8D 7E 07     		STA FSTRTCL+1
0013A9  1  60           		RTS
0013AA  1               
0013AA  1               CHECKLEN:
0013AA  1               ;		LDX #3
0013AA  1               ;CL1:		LDA FRPOS,X
0013AA  1               ;		JSR PUTHEX
0013AA  1               ;		DEX
0013AA  1               ;		BPL CL1
0013AA  1               ;		LDA #EOL
0013AA  1               ;		JSR PRINT
0013AA  1               
0013AA  1  A2 03        		LDX #3
0013AC  1  BD 85 07     CHECKL2:	LDA FRPOS,X
0013AF  1  DD 7F 07     		CMP FILELEN,X
0013B2  1  90 03        		BCC CHECKL1
0013B4  1  CA           		DEX
0013B5  1  10 F5        		BPL CHECKL2
0013B7  1  60           CHECKL1:	RTS
0013B8  1               
0013B8  1               ;-------------------------------------------------------------------------------
0013B8  1               ; increments 4-byte FILELEN
0013B8  1               ;-------------------------------------------------------------------------------
0013B8  1  EE 7F 07     INCFILELEN:	INC FILELEN
0013BB  1  D0 0D        		BNE INCFILELEX
0013BD  1  EE 80 07     INCFILELE2:	INC FILELEN+1
0013C0  1  D0 08        		BNE INCFILELEX
0013C2  1  EE 81 07     		INC FILELEN+2
0013C5  1  D0 03        		BNE INCFILELEX
0013C7  1  EE 82 07     		INC FILELEN+3
0013CA  1  60           INCFILELEX:	RTS
0013CB  1               
0013CB  1               
0013CB  1               ;-------------------------------------------------------------------------------
0013CB  1               ; increments 4-byte FRPOS
0013CB  1               ;-------------------------------------------------------------------------------
0013CB  1  EE 85 07     INCRPOS:	INC FRPOS
0013CE  1  F0 04        		BEQ INCRPOS2
0013D0  1  60           		rts
0013D1  1               
0013D1  1               ;-------------------------------------------------------------------------------
0013D1  1               ; adds 512 to FRPOS
0013D1  1               ;-------------------------------------------------------------------------------
0013D1  1  20 D4 13     INCRPOS512:	JSR INCRPOS2
0013D4  1  EE 86 07     INCRPOS2:	INC FRPOS+1
0013D7  1  D0 08        		BNE INCRPOS1
0013D9  1  EE 87 07     		INC FRPOS+2
0013DC  1  D0 03        		BNE INCRPOS1
0013DE  1  EE 88 07     		INC FRPOS+3
0013E1  1  60           INCRPOS1:	RTS
0013E2  1               
0013E2  1               ;-------------------------------------------------------------------------------
0013E2  1               ; increments 4-byte SECTOR
0013E2  1               ;-------------------------------------------------------------------------------
0013E2  1  A2 00        INCSECTO:	ldx #0
0013E4  1  F6 43        INCSECTO2:	inc SECTOR,X
0013E6  1  D0 05        		bne INCSECT1
0013E8  1  E8           		inx
0013E9  1  E0 04        		cpx #4
0013EB  1  D0 F7        		bne INCSECTO2
0013ED  1               
0013ED  1               INCSECT1:
0013ED  1  A2 00        		ldx #0
0013EF  1               ;INCSECT2:	lda SECTOR,x
0013EF  1               ;		jsr PUTHEX
0013EF  1               ;		inx
0013EF  1               ;		cpx #4
0013EF  1               ;		bne INCSECT2
0013EF  1  60           		rts
0013F0  1               
0013F0  1               
0013F0  1               ;-------------------------------------------------------------------------------
0013F0  1               ; increments file read-pointer
0013F0  1               ; - reads next sector if at end of read-buffer
0013F0  1               ; - reads next cluster if end of sectors per cluster
0013F0  1               ;-------------------------------------------------------------------------------
0013F0  1  E6 00        INCPTR:		INC FATPTRS				;increment buffer-pointer
0013F2  1  D0 2E        		BNE INCPTROK				;if not >= Buffer+$200
0013F4  1  E6 01        		INC FATPTRS+1				;nothing else to do
0013F6  1  A5 01        		LDA FATPTRS+1
0013F8  1  C9 0B        		CMP #(>BUFFER)+2
0013FA  1  D0 26        		BNE INCPTROK
0013FC  1               ;
0013FC  1               ; READ NEXT SECTOR
0013FC  1               ;
0013FC  1  EE 91 07     INCSEC:		INC FCURSEC				;otherwise point to next sector
0013FF  1  AD 91 07     		LDA FCURSEC
001402  1  CD 00 07     		CMP SECCLUS
001405  1  F0 05        		BEQ INCSEC3				;new cluster necessary!
001407  1               
001407  1  20 E2 13     INCSEC7:	JSR INCSECTO				;just increment sector
00140A  1  F0 2E        		BEQ INCSEC6				;jmp always, reset buffer-ptr and read-sector
00140C  1               
00140C  1               ;
00140C  1               ; READ NEXT CLUSTER
00140C  1               ;
00140C  1  A9 00        INCSEC3:	LDA #0					;reset current sector in file
00140E  1  8D 91 07     		STA FCURSEC
001411  1               
001411  1  20 2F 17     		JSR GETNEXTC			        ;get next cluster in AX
001414  1               
001414  1  C9 0F        		CMP #>FATEND				;FAT End marker $xFF0
001416  1  D0 1C        		BNE INCSEC4
001418  1  E0 FF        		CPX #<FATEND
00141A  1  D0 18        		BNE INCSEC4				;not end of clusters
00141C  1               
00141C  1  A5 2A        		LDA ICAX1Z				;WRITE ACCESS?
00141E  1  29 08        		AND #8
001420  1  D0 03        		BNE INCSEC1				;yes, acquire new cluster
001422  1  A0 01        INCPTROK:	LDY #1					;exit OK
001424  1  60           INCPTREX:	RTS
001425  1               
001425  1  20 AF 16     INCSEC1:	JSR CHAINCLU				;add a new cluster
001428  1               
001428  1  AD A9 07     		LDA DIRFILE				;Skip if not
00142B  1  C9 02        		CMP #2					;GET FREE DIR
00142D  1  D0 08        		BNE INCSEC5				;
00142F  1               
00142F  1  20 55 14     		JSR CLRCLUST				;otherwise clear sectors in new cluster
001432  1  F0 03        		BEQ INCSEC5				;skip store AX in FCURCLUS
001434  1               
001434  1  20 5B 16     INCSEC4:	JSR STAXCCLUS
001437  1  20 0E 16     INCSEC5:	JSR CLU2SEC				;compute sector
00143A  1  A9 00        INCSEC6:	LDA #<BUFFER				;reset buffer pointer
00143C  1  85 00        		STA FATPTRS
00143E  1  A9 09        		LDA #>BUFFER
001440  1  85 01        		STA FATPTRS+1
001442  1  4C F6 17     		JMP READSEC				;read sector
001445  1               
001445  1               ;-------------------------------------------------------------------------------
001445  1               ; clear data buffer
001445  1               ;-------------------------------------------------------------------------------
001445  1  A9 00        CLEARBUF:	LDA #0
001447  1  AA           		TAX
001448  1  9D 00 09     CLEARBU1:	STA BUFFER,X
00144B  1  9D 00 0A     		STA BUFFER+$100,X
00144E  1  E8           		INX
00144F  1  D0 F7        		BNE CLEARBU1
001451  1  EE 3D 07     		INC DDIRTY				;mark dirty
001454  1  60           		RTS
001455  1               
001455  1               ;-------------------------------------------------------------------------------
001455  1               ; clear cluster
001455  1               ;-------------------------------------------------------------------------------
001455  1  A9 00        CLRCLUST:	lda #0
001457  1  8D 91 07     		sta FCURSEC
00145A  1  20 0E 16     		jsr CLU2SEC
00145D  1               
00145D  1  AD 00 07     		LDA SECCLUS
001460  1  8D 91 07     		STA FCURSEC
001463  1               
001463  1  20 F6 17     CLRCLUST1:	JSR READSEC
001466  1  20 45 14     		JSR CLEARBUF
001469  1  20 E2 13     		JSR INCSECTO
00146C  1               
00146C  1  CE 91 07     		DEC FCURSEC
00146F  1  D0 F2        		BNE CLRCLUST1				;loop FCURSEC times
001471  1  60           		rts
001472  1               
001472  1               ;-------------------------------------------------------------------------------
001472  1               ;
001472  1               ;-------------------------------------------------------------------------------
001472  1  AD 7D 07     FSEEK:		LDA FSTRTCL
001475  1  8D 8D 07     		STA FCURCLUS
001478  1  AD 7E 07     		LDA FSTRTCL+1
00147B  1  8D 8E 07     		STA FCURCLUS+1
00147E  1               
00147E  1  A2 03        		LDX #3
001480  1  BD 85 07     FSEEK2:		LDA FRPOS,X
001483  1  9D 89 07     		STA FVAR32,X
001486  1  CA           		DEX
001487  1  10 F7        		BPL FSEEK2
001489  1               
001489  1  A9 89        FSEEK1:		LDA #<FVAR32
00148B  1  85 02        		STA FATPTRD
00148D  1  A9 07        		LDA #>FVAR32
00148F  1  85 03        		STA FATPTRD+1
001491  1  A9 24        		LDA #<BYTCLUS
001493  1  85 00        		STA FATPTRS
001495  1  A9 07        		LDA #>BYTCLUS
001497  1  85 01        		STA FATPTRS+1
001499  1               
001499  1  20 0E 19     		JSR CMP32	; FATPTRD < FATPTRS?
00149C  1  90 1A        		BCC FSEEKS	; ja
00149E  1               
00149E  1  20 FF 18     		JSR SBC32
0014A1  1               
0014A1  1  20 2F 17     		JSR GETNEXTC
0014A4  1               
0014A4  1  C9 0F        		CMP #>FATEND
0014A6  1  D0 0A        		BNE FSEEK3
0014A8  1  E0 FF        		CPX #<FATEND
0014AA  1  D0 06        		BNE FSEEK3
0014AC  1               
0014AC  1  20 AF 16     		JSR CHAINCLU
0014AF  1  4C 89 14     		JMP FSEEK1
0014B2  1               
0014B2  1  20 5B 16     FSEEK3:		JSR STAXCCLUS
0014B5  1  4C 89 14     		JMP FSEEK1
0014B8  1               
0014B8  1               ;
0014B8  1               ; INSIDE CLUSTER
0014B8  1               ; SECTOR+OFFSET
0014B8  1               ;
0014B8  1  A9 00        FSEEKS:		LDA #0
0014BA  1  8D 91 07     		STA FCURSEC
0014BD  1  20 0E 16     		JSR CLU2SEC
0014C0  1               
0014C0  1               ;		jsr DUMPSEC
0014C0  1               
0014C0  1  AD 8A 07     		LDA FVAR32+1
0014C3  1  4A           		LSR
0014C4  1  8D 91 07     		STA FCURSEC
0014C7  1  18           		CLC
0014C8  1  65 44        		ADC SECTOR+1
0014CA  1  85 44        		STA SECTOR+1
0014CC  1  90 06        		BCC FSEEKS1
0014CE  1  E6 45        		INC SECTOR+2
0014D0  1  D0 02        		BNE FSEEKS1
0014D2  1  E6 46        		INC SECTOR+3
0014D4  1               
0014D4  1               ;		jsr DUMPSEC
0014D4  1               
0014D4  1               
0014D4  1  AD 8A 07     FSEEKS1:	LDA FVAR32+1
0014D7  1  29 01        		AND #1
0014D9  1  18           		CLC
0014DA  1  69 09        		ADC #>BUFFER
0014DC  1  85 01        		STA FATPTRS+1
0014DE  1  AD 89 07     		LDA FVAR32
0014E1  1  85 00        		STA FATPTRS
0014E3  1               
0014E3  1               ;		jsr DUMPSEC
0014E3  1               ;		JSR SEC2FSEC
0014E3  1               
0014E3  1  4C F6 17     		JMP READSEC
0014E6  1               ;		JSR KBGETC
0014E6  1               ;		RTS
0014E6  1               
0014E6  1               
0014E6  1               ;-------------------------------------------------------------------------------
0014E6  1               ; LASTSEC = $FFFFFFFF
0014E6  1               ;-------------------------------------------------------------------------------
0014E6  1  A9 FF        INITLSEC:	LDA #$FF
0014E8  1  A2 03        		LDX #3
0014EA  1  9D 1C 07     INITLSEC1:	STA LASTSEC,X
0014ED  1  CA           		DEX
0014EE  1  10 FA        		BPL INITLSEC1
0014F0  1  60           		RTS
0014F1  1               
0014F1  1               ;-------------------------------------------------------------------------------
0014F1  1               ; LASTFAT = $FFFFFFFF
0014F1  1               ;-------------------------------------------------------------------------------
0014F1  1  A9 FF        INITFSEC:	LDA #$FF
0014F3  1  A2 03        		LDX #3
0014F5  1  9D 20 07     INITFSEC1:	STA LASTFAT,X
0014F8  1  CA           		DEX
0014F9  1  10 FA        		BPL INITFSEC1
0014FB  1  60           		RTS
0014FC  1               
0014FC  1               ;-------------------------------------------------------------------------------
0014FC  1               ; get stuck if FAT16/12 can't be found
0014FC  1               ;-------------------------------------------------------------------------------
0014FC  1               DIE:	.IF PLATFORM <= 1
0014FC  1               		SEC
0014FC  1               		RTS
0014FC  1               	.ELSE
0014FC  1  20 33 19     		jsr PUTHEX
0014FF  1  AD 03 03     		lda DSTATS
001502  1  20 33 19     		jsr PUTHEX
001505  1  4C 05 15     DIE1:		jmp DIE1
001508  1               	.ENDIF
001508  1               
001508  1               ;-------------------------------------------------------------------------------
001508  1               ; Init all variables
001508  1               ; read boot sector
001508  1               ; compute FATBASE, DIRBASE, DATBASE, etc.
001508  1               ;-------------------------------------------------------------------------------
001508  1               INITFAT:
001508  1  A9 00        		LDA #0					;clear 512-byte of variables
00150A  1  AA           		TAX
00150B  1  9D 00 07     VCLEAR:		STA V,X
00150E  1  9D 00 08     		STA V+256,X
001511  1  CA           		DEX
001512  1  D0 F7        		BNE VCLEAR
001514  1               
001514  1               ;		LDA #0					;initialise offset
001514  1  AA           VSET2:		TAX					;into FCB
001515  1  9D 01 08     		STA FCB0+1,X				;0, 64, 128, 192
001518  1  18           		CLC
001519  1  69 40        		ADC #64
00151B  1  D0 F7        		BNE VSET2
00151D  1               
00151D  1  20 E6 14     		JSR INITLSEC				;set LASTSEC to $FFFFFFFF
001520  1  20 F1 14     		JSR INITFSEC				;set LASTFAT to $FFFFFFFF
001523  1               
001523  1  8D 7B 07     		STA FIOCBNR				;all $FF
001526  1  8D 00 08     		STA FCB0
001529  1  8D 40 08     		STA FCB1
00152C  1  8D 80 08     		STA FCB2
00152F  1  8D C0 08     		STA FCB3
001532  1               
001532  1               
001532  1               ;		LDA #<BUFFER
001532  1               ;		STA BUFADRL
001532  1               ;		LDA #>BUFFER
001532  1               ;		STA BUFADRH
001532  1               
001532  1  A9 0F        		LDA #VALIDNA2-VALIDCHA-2
001534  1  8D 69 07     		STA VALIDS
001537  1               
001537  1               ;		LDA #'/
001537  1               ;		STA PATH
001537  1               
001537  1  20 C6 15     		JSR READBOOT				;read boot sector
00153A  1               
00153A  1               	.IF PLATFORM <> 4
00153A  1               		CMP #3
00153A  1               		BNE DIE
00153A  1               	.ELSE
00153A  1  C9 02        		CMP #2
00153C  1  D0 BE        		BNE DIE
00153E  1               	.ENDIF
00153E  1               
00153E  1               ;		JSR DUMPBUF
00153E  1               
00153E  1  A2 0A        		LDX #10					;copy 11 important bytes / values
001540  1  BD 0D 09     VCOPY:		LDA BUFFER+13,X				;from boot sector
001543  1  9D 00 07     		STA V,X					;to FAT variables
001546  1  CA           		DEX					;(SECCLUS to SECSFAT)
001547  1  10 F7        		BPL VCOPY
001549  1               
001549  1  AD 00 07     		LDA SECCLUS				;bytes per cluster as 32-byte word
00154C  1  0A           		ASL
00154D  1  8D 25 07     		STA BYTCLUS+1
001550  1               
001550  1  18           		CLC					;compute FATBASE, DIRBASE
001551  1  A5 43        		LDA SECTOR
001553  1  6D 01 07     		ADC RESSEC
001556  1  8D 10 07     		STA FATBASE
001559  1  8D 14 07     		STA DIRBASE
00155C  1  A5 44        		LDA SECTOR+1
00155E  1  6D 02 07     		ADC RESSEC+1
001561  1  8D 11 07     		STA FATBASE+1
001564  1  8D 15 07     		STA DIRBASE+1
001567  1  90 0E        		BCC DIRBAS
001569  1  EE 12 07     		INC FATBASE+2
00156C  1  EE 16 07     		INC DIRBASE+2
00156F  1  D0 06        		BNE DIRBAS
001571  1  EE 13 07     		INC FATBASE+3
001574  1  EE 17 07     		INC DIRBASE+3
001577  1               
001577  1  18           DIRBAS:		CLC
001578  1  AE 03 07     		LDX NUMFATS
00157B  1  AD 14 07     DIRBAS2:	LDA DIRBASE
00157E  1  6D 09 07     		ADC SECSFAT
001581  1  8D 14 07     		STA DIRBASE
001584  1  AD 15 07     		LDA DIRBASE+1
001587  1  6D 0A 07     		ADC SECSFAT+1
00158A  1  8D 15 07     		STA DIRBASE+1
00158D  1  90 08        		BCC DIRBAS1
00158F  1  EE 16 07     		INC DIRBASE+2
001592  1  D0 03        		BNE DIRBAS1
001594  1  EE 17 07     		INC DIRBASE+3
001597  1  CA           DIRBAS1:	DEX
001598  1  D0 E1        		BNE DIRBAS2
00159A  1               
00159A  1               ;		LDY #<DIRBASE	;COPY DIRBASE
00159A  1               ;		LDA #>DIRBASE	;TO SECTOR
00159A  1               ;		JSR COPY32
00159A  1               
00159A  1  AD 04 07     		LDA NUMDIR	;#ROOTDIRS
00159D  1  8D 18 07     		STA DATBASE
0015A0  1  AD 05 07     		LDA NUMDIR+1
0015A3  1  8D 19 07     		STA DATBASE+1
0015A6  1               
0015A6  1  A2 04        		LDX #4		; DATBASE = NUMDIR / 16
0015A8  1  4E 19 07     DATBAS1:	LSR DATBASE+1
0015AB  1  6E 18 07     		ROR DATBASE
0015AE  1  CA           		DEX
0015AF  1  D0 F7        		BNE DATBAS1
0015B1  1               
0015B1  1  18           		CLC		; DATBASE += DIRBASE
0015B2  1  AD 18 07     		LDA DATBASE
0015B5  1  6D 14 07     		ADC DIRBASE
0015B8  1  8D 18 07     		STA DATBASE
0015BB  1  AD 19 07     		LDA DATBASE+1
0015BE  1  6D 15 07     		ADC DIRBASE+1
0015C1  1  8D 19 07     		STA DATBASE+1
0015C4  1               
0015C4  1               ;		jsr PRINTINFO
0015C4  1               
0015C4  1  18           		CLC
0015C5  1  60           		RTS
0015C6  1               
0015C6  1               
0015C6  1               
0015C6  1               ;-------------------------------------------------------------------------------
0015C6  1               ; read first sector and see if MBR (FAT-16) or boot-sector (FAT-12)
0015C6  1               ;-------------------------------------------------------------------------------
0015C6  1               READBOOT:
0015C6  1  20 28 19     		JSR CLEARSEC                            ;read MBR or Boot sector
0015C9  1  20 F6 17     		JSR READSEC				;Fat16, SD-Card: MBR; Fat12 Bootsec
0015CC  1               
0015CC  1  20 E2 15     		JSR CHECKFAT
0015CF  1  F0 07        		BEQ READB3				;Fat16 MBR
0015D1  1  C9 03        		CMP #3
0015D3  1  D0 02        		BNE READB2
0015D5  1  A9 00        READB1:		LDA #0
0015D7  1  60           READB2:		RTS
0015D8  1               
0015D8  1  A0 C6        READB3:		LDY #<(BUFFER+PART1)
0015DA  1  A9 0A        		LDA #>(BUFFER+PART1)
0015DC  1  20 1A 19     		JSR COPY32
0015DF  1               
0015DF  1  20 F6 17     		JSR READSEC
0015E2  1               
0015E2  1               ;-------------------------------------------------------------------------------
0015E2  1               ; 0:FAT16 MBR
0015E2  1               ; 1:NO BOOTSEC/MBR
0015E2  1               ; 2:BOOTSEC, NO FAT16/Harddrive
0015E2  1               ; 3:BOOTSEC, FAT16
0015E2  1               ;-------------------------------------------------------------------------------
0015E2  1  AD FE 0A     CHECKFAT:	LDA BUFFER+$1FE
0015E5  1  C9 55        		CMP #$55				;check sec+$1fe = 55AA
0015E7  1  D0 1F        		BNE CHKFATEX1
0015E9  1  AD FF 0A     		LDA BUFFER+$1FF
0015EC  1  C9 AA        		CMP #$AA
0015EE  1  D0 18        		BNE CHKFATEX1				;no boot sector
0015F0  1  AD C2 0A     		LDA BUFFER+$1C2				;check in MBR
0015F3  1  C9 0E        		CMP #$0E				;0E Partition
0015F5  1  F0 14        		BEQ CHKFATEX0
0015F7  1  C9 06        		CMP #$06				;06 Partition
0015F9  1  F0 10        		BEQ CHKFATEX0
0015FB  1  AD 15 09     		LDA BUFFER+$15
0015FE  1  C9 F8        		CMP #$F8				;Hard Drive
001600  1  D0 03        		BNE CHKFATEX2
001602  1               ;		LDA BUFFER+$37
001602  1               ;		CMP #'A'
001602  1               ;		BNE CHKFAT4
001602  1  A9 03        CHKFATEX3:	LDA #3
001604  1  60           		RTS
001605  1  A9 02        CHKFATEX2:	LDA #2
001607  1  60           		RTS
001608  1  A9 01        CHKFATEX1:	LDA #1
00160A  1  60           		RTS
00160B  1  A9 00        CHKFATEX0:	LDA #0
00160D  1  60           		RTS
00160E  1               
00160E  1               
00160E  1               ;*******************************************************************************
00160E  1               ;*******************************************************************************
00160E  1               ; CLUSTER related routines
00160E  1               ;*******************************************************************************
00160E  1               ;*******************************************************************************
00160E  1               
00160E  1               
00160E  1               ;-------------------------------------------------------------------------------
00160E  1               ; compute absolute data-sector-number from FCURCLUS and FCURSEC
00160E  1               ;-------------------------------------------------------------------------------
00160E  1  20 28 19     CLU2SEC:	JSR CLEARSEC				;clear SECTOR
001611  1               
001611  1  38           		SEC					;subtract 2 from current cluster
001612  1  AD 8D 07     		LDA FCURCLUS
001615  1  E9 02        		SBC #2
001617  1  85 43        		STA SECTOR
001619  1  AD 8E 07     		LDA FCURCLUS+1
00161C  1  E9 00        		SBC #0
00161E  1  85 44        		STA SECTOR+1
001620  1               
001620  1  AD 00 07     		LDA SECCLUS				;multiply by sec per clusters
001623  1  4A           CL2SEC2:	LSR
001624  1  F0 09        		BEQ CL2SEC1
001626  1  06 43        		ASL SECTOR
001628  1  26 44        		ROL SECTOR+1
00162A  1  26 45        		ROL SECTOR+2
00162C  1  4C 23 16     		JMP CL2SEC2
00162F  1               
00162F  1  18           CL2SEC1:	clc					;add Data-Base
001630  1  A2 00        		ldx #0
001632  1  A0 04        		ldy #4
001634  1  B5 43        CL2SEC1A:	lda SECTOR, x
001636  1  7D 18 07     		adc DATBASE, x
001639  1  95 43        		sta SECTOR, x
00163B  1  E8           		inx
00163C  1  88           		dey
00163D  1  D0 F5        		bne CL2SEC1A
00163F  1               
00163F  1  18           		clc					;add file current sector
001640  1  A5 43        		lda SECTOR
001642  1  6D 91 07     		adc FCURSEC
001645  1  85 43        		sta SECTOR
001647  1  90 0A        		bcc CL2SEC1B
001649  1  E6 44        		inc SECTOR+1
00164B  1  D0 06        		bne CL2SEC1B
00164D  1  E6 45        		inc SECTOR+2
00164F  1  D0 02        		bne CL2SEC1B
001651  1  E6 46        		inc SECTOR+3
001653  1  60           CL2SEC1B:	rts
001654  1               
001654  1               ;-------------------------------------------------------------------------------
001654  1               ; load AX with FCURCLUS
001654  1               ;-------------------------------------------------------------------------------
001654  1  AE 8D 07     LOAXCCLUS:	ldx FCURCLUS
001657  1  AD 8E 07     		lda FCURCLUS+1
00165A  1  60           		rts
00165B  1               
00165B  1               ;-------------------------------------------------------------------------------
00165B  1               ; store AX in FCURCLUS
00165B  1               ;-------------------------------------------------------------------------------
00165B  1  8E 8D 07     STAXCCLUS:	stx FCURCLUS
00165E  1  8D 8E 07     		sta FCURCLUS+1
001661  1  60           		rts
001662  1               
001662  1               ;-------------------------------------------------------------------------------
001662  1               ; load AX with NEWCLUS
001662  1               ;-------------------------------------------------------------------------------
001662  1  AE 3B 07     LOAXNCLUS:	ldx NEWCLUS
001665  1  AD 3C 07     		lda NEWCLUS+1
001668  1  60           		rts
001669  1               
001669  1               ;-------------------------------------------------------------------------------
001669  1               ; load AX with FSTRTCL
001669  1               ;-------------------------------------------------------------------------------
001669  1  AD 7E 07     LOAXSCLUS:	lda FSTRTCL+1
00166C  1  AE 7D 07     		ldx FSTRTCL
00166F  1  60           		rts
001670  1               
001670  1               ;-------------------------------------------------------------------------------
001670  1               ; store FATEND in NEWCLUS
001670  1               ;-------------------------------------------------------------------------------
001670  1  A0 FF        STENDNCLUS:	ldy #<FATEND
001672  1  8C 3B 07     		sty NEWCLUS
001675  1  A0 0F        		ldy #>FATEND
001677  1  8C 3C 07     		sty NEWCLUS+1
00167A  1  60           		rts
00167B  1               ;-------------------------------------------------------------------------------
00167B  1               ; GET FREE CLUSTER SEARCHING FROM
00167B  1               ;
00167B  1               ; X:CLUST:L
00167B  1               ; A:CLUST:H
00167B  1               ;
00167B  1               ; AND INITIALIZE TO $xFFF
00167B  1               ;
00167B  1               ; NEWCLUS	: HOLDS NEW CLUSTER-NO.
00167B  1               ;-------------------------------------------------------------------------------
00167B  1  8E 3B 07     GETFCLUS:	stx NEWCLUS
00167E  1  8D 3C 07     		sta NEWCLUS+1
001681  1               
001681  1  20 62 16     GETFCLUS2:	jsr LOAXNCLUS
001684  1  20 32 17     		jsr GETCLUST
001687  1               
001687  1  A8           		tay					;high-byte zero?
001688  1  D0 1A        		bne GETFCLUS1				;no, increment
00168A  1  8A           		txa                                     ;low-byte zero?
00168B  1  D0 17        		bne GETFCLUS1				;no, increment
00168D  1               
00168D  1  20 62 16     		jsr LOAXNCLUS                           ;found free cluster
001690  1  A8           		tay
001691  1  48           		pha
001692  1  8A           		txa
001693  1  48           		pha
001694  1  98           		tya
001695  1               
001695  1  20 70 16     		jsr STENDNCLUS				;store FATEND to NEWCLUS via Y
001698  1  20 C1 16     		jsr PUTCLUST
00169B  1  68           		pla
00169C  1  8D 3B 07     		sta NEWCLUS
00169F  1  68           		pla
0016A0  1  8D 3C 07     		sta NEWCLUS+1
0016A3  1  60           		rts
0016A4  1               
0016A4  1  EE 3B 07     GETFCLUS1:	inc NEWCLUS
0016A7  1  D0 D8        		bne GETFCLUS2
0016A9  1  EE 3C 07     		inc NEWCLUS+1
0016AC  1  4C 81 16     		jmp GETFCLUS2
0016AF  1               
0016AF  1               ;-------------------------------------------------------------------------------
0016AF  1               ; GET FREE CLUSTER
0016AF  1               ; INIT TO $FFFF
0016AF  1               ; CHAIN WITH CURCLUS
0016AF  1               ;-------------------------------------------------------------------------------
0016AF  1  20 54 16     CHAINCLU:	jsr LOAXCCLUS				;load AX with FCURCLUS
0016B2  1  20 7B 16     		jsr GETFCLUS				;get free cluster in NEWCLUST
0016B5  1  20 54 16     		jsr LOAXCCLUS				;load ax again run into PUTCLUST
0016B8  1  20 C1 16     		jsr PUTCLUST				;put NEWCLUST in current cluster
0016BB  1  20 62 16     		jsr LOAXNCLUS				;copy NEWCLUS to FCURCLUS
0016BE  1  4C 5B 16     		jmp STAXCCLUS
0016C1  1               
0016C1  1               ;-------------------------------------------------------------------------------
0016C1  1               ; Put cluster-number in NEWCLUS to cluster pointed to by
0016C1  1               ; X:	CLUST:L
0016C1  1               ; A:	CLUST:H
0016C1  1               ; even		odd
0016C1  1               ; 03 21		06 54
0016C1  1               ; Byte	Byte	Byte
0016C1  1               ; NN	NN	NN
0016C1  1               ; 21	43	65
0016C1  1               ;-------------------------------------------------------------------------------
0016C1  1               PUTCLUST:
0016C1  1               	.IF PLATFORM = 4
0016C1  1               
0016C1  1  20 08 17     		jsr COMPFAT12
0016C4  1               
0016C4  1  A9 FF        		lda #$FF
0016C6  1  8D 3E 07     		sta FDIRTY
0016C9  1               
0016C9  1  B0 12        		bcs PUTCODD
0016CB  1               
0016CB  1  AD 3B 07     		lda NEWCLUS
0016CE  1  91 00        		sta (FATPTRS), y
0016D0  1  20 5A 17     		jsr INCFATBYTE
0016D3  1  B1 00        		lda (FATPTRS), y
0016D5  1  29 F0        		and #240				;mask out lower nibble
0016D7  1  0D 3C 07     		ora NEWCLUS+1				;or-in lower nibble
0016DA  1  91 00        		sta (FATPTRS), y
0016DC  1  60           		rts
0016DD  1               
0016DD  1  B1 00        PUTCODD:	lda (FATPTRS), y
0016DF  1  29 0F        		and #15					;mask out high nibble
0016E1  1  91 00        		sta (FATPTRS), y
0016E3  1  AD 3B 07     		lda NEWCLUS
0016E6  1  0A           		asl
0016E7  1  0A           		asl
0016E8  1  0A           		asl
0016E9  1  0A           		asl
0016EA  1  11 00        		ora (FATPTRS), y			;or in low nibble
0016EC  1  91 00        		sta (FATPTRS), y
0016EE  1               
0016EE  1  20 5A 17     		jsr INCFATBYTE
0016F1  1               
0016F1  1  AD 3B 07     		lda NEWCLUS
0016F4  1  85 47        		sta SHIFT
0016F6  1  AD 3C 07     		lda NEWCLUS + 1
0016F9  1  06 47        		asl SHIFT
0016FB  1  2A           		rol
0016FC  1  06 47        		asl SHIFT
0016FE  1  2A           		rol
0016FF  1  06 47        		asl SHIFT
001701  1  2A           		rol
001702  1  06 47        		asl SHIFT
001704  1  2A           		rol
001705  1  91 00        		sta (FATPTRS), y
001707  1  60           		rts
001708  1               
001708  1               ;-------------------------------------------------------------------------------
001708  1               ; Point FATPTRS to cluster in AX and read FAT sector if needed
001708  1               ; Carry holds even/odd cluster
001708  1               ; Y: 0
001708  1               ;-------------------------------------------------------------------------------
001708  1  A8           COMPFAT12:	tay					;copy for later use
001709  1  4A           		lsr					;SECTOR = AX / 2
00170A  1  85 01        		sta FATPTRS+1
00170C  1  8A           		txa
00170D  1  6A           		ror
00170E  1  85 00        		sta FATPTRS
001710  1  08           		php					;save carry for even/odd
001711  1               
001711  1  18           		clc
001712  1  8A           		txa
001713  1  65 00        		adc FATPTRS
001715  1  85 00        		sta FATPTRS
001717  1  98           		tya
001718  1  65 01        		adc FATPTRS+1
00171A  1  4A           		lsr
00171B  1  85 43        		sta SECTOR
00171D  1  E6 43        		inc SECTOR				;HACK! add FATBASE actually (usually 1)
00171F  1  A9 00        		lda #0
001721  1  85 44        		sta SECTOR+1
001723  1  2A           		rol
001724  1  69 0B        		adc #>FATBUF
001726  1  85 01        		sta FATPTRS+1
001728  1               
001728  1               ;		lda SECTOR+1
001728  1               ;		jsr PUTHEX
001728  1               ;		lda SECTOR
001728  1               ;		jsr PUTHEX
001728  1               
001728  1               ;		lda #'+'
001728  1               ;		jsr PRINT
001728  1  20 AE 17     		jsr READFAT
00172B  1               ;		lda #'-'
00172B  1               ;		jsr PRINT
00172B  1               
00172B  1  28           		plp					;restore carry
00172C  1  A0 00        		ldy #0					;return N=0
00172E  1  60           		rts
00172F  1               	.ELSE
00172F  1               		jsr COMPFAT16
00172F  1               		lda NEWCLUST
00172F  1               		sta (FATPTRS),Y
00172F  1               		iny
00172F  1               		lda NEWCLUST+1
00172F  1               		sta (FATPTRS),Y
00172F  1               		rts
00172F  1               
00172F  1               COMPFAT16:
00172F  1               		CLC
00172F  1               		STA SECTOR
00172F  1               		ADC FATBASE
00172F  1               		STA SECTOR
00172F  1               		LDA FATBASE+1
00172F  1               		ADC #0
00172F  1               		STA SECTOR+1
00172F  1               		LDA FATBASE+2
00172F  1               		ADC #0
00172F  1               		STA SECTOR+2
00172F  1               		LDA FATBASE+3
00172F  1               		ADC #0
00172F  1               		STA SECTOR+3
00172F  1               		TXA					;save X
00172F  1               		PHA
00172F  1               		JSR READFAT
00172F  1               
00172F  1               		LDA #<FATBUF
00172F  1               		STA FATPTRS
00172F  1               		LDA #>FATBUF
00172F  1               		STA FATPTRS+1
00172F  1               
00172F  1               		PLA					;get former X
00172F  1               		ASL
00172F  1               		BCC COMPFAT16A
00172F  1               		INC FATPTRS+1
00172F  1               COMPFAT16A:	tay
00172F  1               		rts
00172F  1               	.ENDIF
00172F  1               
00172F  1               ;-------------------------------------------------------------------------------
00172F  1               ; get next cluster from FCURCLUS in AX
00172F  1               ;-------------------------------------------------------------------------------
00172F  1  20 54 16     GETNEXTC:       jsr LOAXCCLUS
001732  1               
001732  1               ;-------------------------------------------------------------------------------
001732  1               ; X:	CLUST:L
001732  1               ; A:	CLUST:H
001732  1               ; returns cluster-number stored at cluster AX in AX
001732  1               ;-------------------------------------------------------------------------------
001732  1               GETCLUST:
001732  1               
001732  1               	.IF PLATFORM = 4
001732  1               ;-------------------------------------------------------------------------------
001732  1               ; GETCLUST for FAT-12:
001732  1               ;	FATSEC = (A*256+X) * 3 / 2 (1.5)
001732  1               ;-------------------------------------------------------------------------------
001732  1  20 08 17     		jsr COMPFAT12
001735  1  B0 0B        		bcs GETCODD
001737  1               
001737  1  B1 00        GETCEVEN:	lda (FATPTRS), y
001739  1  20 5A 17     		jsr INCFATBYTE				;preserves A
00173C  1  AA           		tax
00173D  1  B1 00        GETCEVEN1:	lda (FATPTRS), y
00173F  1  29 0F        		and #15
001741  1  60           		rts
001742  1               
001742  1  B1 00        GETCODD:	lda (FATPTRS),y
001744  1  85 47        		sta SHIFT
001746  1  20 5A 17     		jsr INCFATBYTE
001749  1  B1 00        		lda (FATPTRS),y
00174B  1  4A           		lsr
00174C  1  66 47        		ror SHIFT
00174E  1  4A           		lsr
00174F  1  66 47        		ror SHIFT
001751  1  4A           		lsr
001752  1  66 47        		ror SHIFT
001754  1  4A           		lsr
001755  1  66 47        		ror SHIFT
001757  1  A6 47        		ldx SHIFT
001759  1  60           		rts
00175A  1               
00175A  1               
00175A  1               ;-------------------------------------------------------------------------------
00175A  1               ; increment pointer into FAT and check for overflow
00175A  1               ; read new FAT sector if neeed
00175A  1               ;-------------------------------------------------------------------------------
00175A  1  E6 00        INCFATBYTE:	inc FATPTRS
00175C  1  D0 15        		bne INCFATBYTE1				;1ff?
00175E  1               
00175E  1  48           		pha
00175F  1  A5 01        		lda FATPTRS+1
001761  1  C9 0B        		cmp #>FATBUF				;first page of buffer?
001763  1  F0 0B        		beq INCFATBYTE2                         ;yes, increment
001765  1               
001765  1  E6 43        		inc SECTOR                              ;no, read next FAT sector
001767  1  20 AE 17     		jsr READFAT
00176A  1               
00176A  1  A0 00        		ldy #0                                  ;reset Y and PTR to start of buffer
00176C  1  A9 0A        		lda #(>FATBUF) - 1
00176E  1  85 01        		sta FATPTRS+1
001770  1  E6 01        INCFATBYTE2:	inc FATPTRS+1
001772  1  68                           pla
001773  1  60           INCFATBYTE1:	rts
001774  1               
001774  1               	.ELSE
001774  1               ;-------------------------------------------------------------------------------
001774  1               ; GETCLUST for FAT-16:
001774  1               ;-------------------------------------------------------------------------------
001774  1               		jsr COMPFAT16
001774  1               		LDA (FATPTRS),Y
001774  1               		TAX
001774  1               		INY
001774  1               		LDA (FATPTRS),Y
001774  1               		RTS
001774  1               	.ENDIF
001774  1               
001774  1               ;-------------------------------------------------------------------------------
001774  1               ; free all cluster from cluster AX to last in chain ($xFFF)
001774  1               ;-------------------------------------------------------------------------------
001774  1  A0 00        FREECLUS:	ldy #0					;NEWCLUST = 0
001776  1  8C 3B 07     		sty NEWCLUS
001779  1  8C 3C 07     		sty NEWCLUS+1
00177C  1               
00177C  1  20 5B 16     FREECLUS1:	jsr STAXCCLUS				;store AX in FCURCLUS
00177F  1  20 32 17     		jsr GETCLUST				;get next cluster in AX
001782  1  48           		pha					;store on stack
001783  1  8A           		txa
001784  1  48           		pha
001785  1  20 54 16     		jsr LOAXCCLUS
001788  1  20 C1 16     		jsr PUTCLUST				;set cluster to zereo (free)
00178B  1  68           		pla					;get next cluster from stack
00178C  1  AA           		tax
00178D  1  68           		pla
00178E  1  C9 0F        		cmp #>FATEND				;next cluster is FATEND
001790  1  D0 EA        		bne FREECLUS1				;return
001792  1  E0 FF        		cpx #<FATEND
001794  1  D0 E6        		bne FREECLUS1
001796  1  60           		rts
001797  1               
001797  1               
001797  1               
001797  1               ;*******************************************************************************
001797  1               ;*******************************************************************************
001797  1               ; DATA- and FAT-sector SIO routines
001797  1               ;*******************************************************************************
001797  1               ;*******************************************************************************
001797  1               
001797  1               
001797  1               ;-------------------------------------------------------------------------------
001797  1               ; write FAT if FDIRTY <> 0
001797  1               ;-------------------------------------------------------------------------------
001797  1  AD 3E 07     WRITEFAT:	LDA FDIRTY
00179A  1  D0 01        		BNE WRITEFA1
00179C  1  60                           RTS
00179D  1               
00179D  1               WRITEFA1:	;LDA #'F'
00179D  1               		;JSR PRINT
00179D  1               		;LDA #'W'
00179D  1               		;JSR PRINT
00179D  1               
00179D  1  A2 20        		LDX #<LASTFAT
00179F  1  A9 07        		LDA #>LASTFAT
0017A1  1  20 6F 18     		JSR SETSEC				;set sector-number in floppy/drive
0017A4  1               
0017A4  1  20 64 18             	JSR SETWRITE				;set DSTATS and DCOMND
0017A7  1  A9 00        		LDA #0					;reset dirty
0017A9  1  8D 3E 07     		STA FDIRTY
0017AC  1  F0 24        		BEQ RWFAT				;execute SIO command
0017AE  1               
0017AE  1               ;-------------------------------------------------------------------------------
0017AE  1               ; read a FAT sector.
0017AE  1               ; if new sector to read, check if old one is dirty
0017AE  1               ; write old FAT sector if dirty
0017AE  1               ;-------------------------------------------------------------------------------
0017AE  1  A2 03        READFAT:	LDX #3
0017B0  1  B5 43        READFAT3:	LDA SECTOR,X				;compare SECTOR with LASTFAT
0017B2  1  DD 20 07     		CMP LASTFAT,X
0017B5  1  D0 04        		BNE READFAT2
0017B7  1  CA           		DEX
0017B8  1  10 F6        		BPL READFAT3				;if equal
0017BA  1  60           		RTS					;sector already read, nothing to do
0017BB  1               
0017BB  1  20 97 17     READFAT2:	JSR WRITEFAT				;write old sector if dirty
0017BE  1               
0017BE  1               		;LDA #'F'
0017BE  1               		;JSR PRINT
0017BE  1               		;LDA #'R'
0017BE  1               		;JSR PRINT
0017BE  1               
0017BE  1  A2 03        		LDX #3					;copy sector to LASTFAT
0017C0  1  B5 43        READFAT4:	LDA SECTOR,X
0017C2  1  9D 20 07     		STA LASTFAT,X
0017C5  1  CA           		DEX
0017C6  1  10 F8        		BPL READFAT4
0017C8  1               
0017C8  1  A2 43        		LDX #<SECTOR				;set sector to floppy/drive
0017CA  1  A9 00        		LDA #>SECTOR
0017CC  1  20 6F 18     		JSR SETSEC
0017CF  1               
0017CF  1  20 59 18     READFAT1:	JSR SETREAD				;set DSTATS and DCOMND
0017D2  1               
0017D2  1  A9 00        RWFAT:		LDA #<FATBUF
0017D4  1  8D 04 03     		STA DBUFLO
0017D7  1  A9 0B        		LDA #>FATBUF
0017D9  1  8D 05 03     		STA DBUFLO+1
0017DC  1  4C 3B 18     		JMP RWSEC1
0017DF  1               
0017DF  1               ;-------------------------------------------------------------------------------
0017DF  1               ; write a Data sector if DDIRTY <> 0
0017DF  1               ;-------------------------------------------------------------------------------
0017DF  1  AD 3D 07     WRITESEC:	LDA DDIRTY
0017E2  1  D0 01        		BNE WRITESE1
0017E4  1  60           		RTS
0017E5  1               
0017E5  1               WRITESE1:	;LDA #'S'
0017E5  1               		;JSR PRINT
0017E5  1               		;LDA #'W'
0017E5  1               		;JSR PRINT
0017E5  1               
0017E5  1  A2 1C        		LDX #<LASTSEC
0017E7  1  A9 07        		LDA #>LASTSEC
0017E9  1  20 6F 18     		JSR SETSEC
0017EC  1  20 64 18             	JSR SETWRITE
0017EF  1  A9 00        		LDA #0
0017F1  1  8D 3D 07     		STA DDIRTY
0017F4  1  F0 3B        		BEQ RWSEC
0017F6  1               
0017F6  1               ;-------------------------------------------------------------------------------
0017F6  1               ; read a data sector, save old sector if dirty
0017F6  1               ;-------------------------------------------------------------------------------
0017F6  1  A2 03        READSEC:	LDX #3
0017F8  1  B5 43        READSEC3:	LDA SECTOR,X
0017FA  1  DD 1C 07     		CMP LASTSEC,X
0017FD  1  D0 04        		BNE READSEC2
0017FF  1  CA           		DEX
001800  1  10 F6        		BPL READSEC3
001802  1  60           		RTS
001803  1               
001803  1  20 DF 17     READSEC2:	JSR WRITESEC
001806  1               		;LDA #'S'
001806  1               		;JSR PRINT
001806  1               		;LDA #'R'
001806  1               		;JSR PRINT
001806  1               
001806  1  A2 03        		LDX #3					;set LASTSEC TO SECTOR
001808  1  B5 43        READSEC4:	LDA SECTOR,X
00180A  1  9D 1C 07     		STA LASTSEC,X
00180D  1  CA           		DEX
00180E  1  10 F8        		BPL READSEC4
001810  1               
001810  1  A2 00        READSECF:	LDX #0
001812  1  AD 83 07     		LDA FWBURST				;write Burst active?
001815  1  8E 83 07     		STX FWBURST
001818  1  F0 0D        		BEQ READSECF1				;no ->
00181A  1  A5 29        		LDA ICBLHZ				;still $200 to read?
00181C  1  C9 02        		CMP #2
00181E  1  90 07        		BCC READSECF1				;no ->
001820  1  D0 04        		BNE READSECF2				;greater, no read
001822  1  A5 28        		LDA ICBLLZ				;we have substracted only $1ff
001824  1  F0 01        		BEQ READSECF1				;so, if lenght-LO = 0 then end is reached.
001826  1  60           READSECF2:	RTS
001827  1               
001827  1  A2 43        READSECF1:	LDX #<SECTOR
001829  1  A9 00        		LDA #>SECTOR
00182B  1  20 6F 18     		JSR SETSEC
00182E  1               
00182E  1  20 59 18     READSEC1:	JSR SETREAD
001831  1               
001831  1  A9 00        RWSEC:		LDA #<BUFFER
001833  1               		;LDA BUFADRL
001833  1  8D 04 03     		STA DBUFLO
001836  1  A9 09        		LDA #>BUFFER
001838  1               		;LDA BUFADRH
001838  1  8D 05 03     		STA DBUFHI
00183B  1               
00183B  1               	.IF PLATFORM <= 1
00183B  1               RWSEC1:		LDX DBUFLO
00183B  1               		LDA DBUFLO+1
00183B  1               		CPY #$80		; $40 = read; $80 = write
00183B  1               		beq RWSEC2
00183B  1               		jmp readSector
00183B  1               RWSEC2:		jmp writeSector
00183B  1               	.ELSE
00183B  1               RWSEC1:
00183B  1  A9 00        		LDA #0			; 2*256 / 512 bytes
00183D  1  8D 08 03     		STA DBYTLO
001840  1  A9 02        		LDA #2
001842  1  8D 09 03     		STA DBYTLO+1
001845  1               	.IF PLATFORM = 4
001845  1  2C 03 03     		bit DSTATS              ;SALLY can recieve only 256byte chunks
001848  1  10 0C        		bpl RWSEC3		;read, get 512 bytes
00184A  1  CE 09 03     		dec DBYTLO+1		;write put 2 * 256 bytes
00184D  1  20 9A 18     		jsr CALLSIO
001850  1  20 64 18     		jsr SETWRITE
001853  1  EE 05 03     		inc DBUFHI
001856  1               	.ENDIF
001856  1  4C 9A 18     RWSEC3:		JMP CALLSIO
001859  1               	.ENDIF
001859  1               
001859  1               
001859  1               SETREAD:
001859  1               	.IF PLATFORM <= 1
001859  1               		LDY #$40
001859  1               	.ELSE
001859  1  A9 40        		LDA #$40
00185B  1  8D 03 03     		STA DSTATS
00185E  1  A9 52        		LDA #'R'
001860  1  8D 02 03     		STA DCOMND
001863  1               	.ENDIF
001863  1  60           		RTS
001864  1               
001864  1               SETWRITE:
001864  1               	.IF PLATFORM <= 1
001864  1               		LDY #$80
001864  1               	.ELSE
001864  1  A9 80        		LDA #$80
001866  1  8D 03 03     		STA DSTATS
001869  1  A9 50        		LDA #'P'
00186B  1  8D 02 03     		STA DCOMND
00186E  1               	.ENDIF
00186E  1  60           		RTS
00186F  1               ;
00186F  1               ;
00186F  1               ;
00186F  1               	.IF PLATFORM <= 1
00186F  1               SETSEC:		jmp setSector
00186F  1               	.ELSE
00186F  1  8E 04 03     SETSEC:		STX DBUFLO
001872  1  86 02        		STX FATPTRD
001874  1  8D 05 03     		STA DBUFLO+1
001877  1  85 03        		STA FATPTRD+1
001879  1               ;		ldy #1
001879  1               ;		lda (FATPTRD),Y
001879  1               ;		jsr PUTHEX
001879  1               ;		dey
001879  1               ;		lda (FATPTRD),Y
001879  1               ;		jsr PUTHEX
001879  1               ;		jsr NEWLINE
001879  1               
001879  1  A9 31        		LDA #$31
00187B  1  8D 00 03     		STA DDEVIC
00187E  1  A9 02        		LDA #2
001880  1  8D 01 03     		STA DUNIT
001883  1               
001883  1  20 64 18     		JSR SETWRITE
001886  1               
001886  1  A9 04        		LDA #4
001888  1  8D 08 03     		STA DBYTLO
00188B  1  0A           		ASL
00188C  1  8D 06 03     		STA DTIMLO
00188F  1  A9 00        		LDA #0
001891  1  8D 09 03     		STA DBYTLO+1
001894  1  8D 0A 03     		STA DAUX1
001897  1  8D 0B 03     		STA DAUX2                       ;fall through
00189A  1               	.ENDIF
00189A  1               
00189A  1  20 59 E4     CALLSIO:        JSR SIOV
00189D  1  10 04                        BPL CALLSIO1
00189F  1  A6 48                        LDX STCKPTR
0018A1  1  9A                           TXS
0018A2  1  98           		TYA
0018A3  1  60           CALLSIO1:       RTS
0018A4  1               ;*******************************************************************************
0018A4  1               ;*******************************************************************************
0018A4  1               ; debug and helper routines
0018A4  1               ;*******************************************************************************
0018A4  1               ;*******************************************************************************
0018A4  1               
0018A4  1               
0018A4  1               ;-------------------------------------------------------------------------------
0018A4  1               ; convert 32 bit number to 10-byte text, do not display leading zeros
0018A4  1               ; from BIN 4-bytes
0018A4  1               ;   to BCD 5-bytes
0018A4  1               ;   to DECIMAL 10-bytes
0018A4  1               ;-------------------------------------------------------------------------------
0018A4  1  A9 00        BIN2DEC:	LDA #0			;clear 5-byte BCD (=10 nibbles)
0018A6  1  A2 04        		LDX #4
0018A8  1  9D 2C 07     BIN2DEC1:	STA BCD,X
0018AB  1  CA           		DEX
0018AC  1  10 FA        		BPL BIN2DEC1
0018AE  1               
0018AE  1  A2 20        		LDX #32
0018B0  1  F8           		SED
0018B1  1  0E 28 07     BIN2DEC2:	ASL BIN
0018B4  1  2E 29 07     		ROL BIN+1
0018B7  1  2E 2A 07     		ROL BIN+2
0018BA  1  2E 2B 07     		ROL BIN+3
0018BD  1               
0018BD  1  A0 05        		LDY #5
0018BF  1  B9 2B 07     BIN2DEC3:	LDA BCD-1,Y
0018C2  1  79 2B 07     		ADC BCD-1,Y
0018C5  1  99 2B 07     		STA BCD-1,Y
0018C8  1  88           		DEY
0018C9  1  D0 F4        		BNE BIN2DEC3
0018CB  1               
0018CB  1  CA           		DEX
0018CC  1  D0 E3        		BNE BIN2DEC2
0018CE  1               
0018CE  1  D8           		CLD
0018CF  1  84 47        		STY NODISPL		;X, Y = 0
0018D1  1               
0018D1  1  BD 2C 07     BIN2DEC4:	LDA BCD,X
0018D4  1  48           		PHA
0018D5  1  4A           		LSR
0018D6  1  4A           		LSR
0018D7  1  4A           		LSR
0018D8  1  4A           		LSR
0018D9  1  20 E8 18     		JSR BIN2INC
0018DC  1  68           		PLA
0018DD  1  29 0F        		AND #15
0018DF  1  20 E8 18     		JSR BIN2INC
0018E2  1  E8           		INX
0018E3  1  E0 05        		CPX #5
0018E5  1  D0 EA        		BNE BIN2DEC4
0018E7  1  60           		RTS
0018E8  1               
0018E8  1  D0 0C        BIN2INC:	BNE BIN2INC1		; no '0' => print it?
0018EA  1  24 47        		BIT NODISPL		; print if nodisplay negativ
0018EC  1  30 0A        		BMI BIN2INC2
0018EE  1  C0 09        		CPY #9			; print last digit in any case
0018F0  1  F0 06        		BEQ BIN2INC2
0018F2  1  A9 20        		LDA #32			; else print space
0018F4  1  D0 04        		BNE BIN2INC3
0018F6  1               
0018F6  1  C6 47        BIN2INC1:	DEC NODISPL
0018F8  1  49 30        BIN2INC2:	EOR #'0'
0018FA  1  99 31 07     BIN2INC3:	STA DECIMAL,Y
0018FD  1  C8           		INY
0018FE  1  60           		RTS
0018FF  1               
0018FF  1               ;-------------------------------------------------------------------------------
0018FF  1               ; subtract 32-byte word: FATPTRD = FATPTRD - FATPTRS
0018FF  1               ;-------------------------------------------------------------------------------
0018FF  1  A0 00        SBC32:		LDY #0
001901  1  38           		SEC
001902  1  B1 02        SBC32A:		LDA (FATPTRD),Y
001904  1  F1 00        		SBC (FATPTRS),Y
001906  1  91 02        		STA (FATPTRD),Y
001908  1  C8           		INY
001909  1  C0 04        		CPY #4
00190B  1  90 F5        		BCC SBC32A
00190D  1  60           		RTS
00190E  1               
00190E  1               ;-------------------------------------------------------------------------------
00190E  1               ; FATPTRD - FATPTRS (compare)
00190E  1               ;-------------------------------------------------------------------------------
00190E  1  A0 03        CMP32:		LDY #3
001910  1  B1 02        CMP32A:		LDA (FATPTRD),Y
001912  1  D1 00        		CMP (FATPTRS),Y
001914  1  D0 03        		BNE CMP32B
001916  1  88           		DEY
001917  1  10 F7        		BPL CMP32A
001919  1  60           CMP32B:		RTS
00191A  1               
00191A  1               ;-------------------------------------------------------------------------------
00191A  1               ; copy from PTR in AY from FATPTRS to FATPTRD
00191A  1               ;-------------------------------------------------------------------------------
00191A  1  84 00        COPY32:		STY FATPTRS
00191C  1  85 01        		STA FATPTRS+1
00191E  1  A0 03        COPY32B:	LDY #3
001920  1  B1 00        COPY32A:	LDA (FATPTRS),Y
001922  1  91 02        		STA (FATPTRD),Y
001924  1  88           		DEY
001925  1  10 F9        		BPL COPY32A
001927  1  60           		RTS
001928  1               
001928  1  A9 00        CLEARSEC:	lda #0
00192A  1  85 43        		sta SECTOR
00192C  1  85 44        		sta SECTOR+1
00192E  1  85 45        		sta SECTOR+2
001930  1  85 46        		sta SECTOR+3
001932  1  60           		rts
001933  1               
001933  1               ;		LDY #<SECTOR				;Clear SECTOR via
001933  1               ;		LDA #>SECTOR				;FATPTRD
001933  1               ;
001933  1               ;;-------------------------------------------------------------------------------
001933  1               ;; clear long-word AY -> FATPTRD
001933  1               ;;-------------------------------------------------------------------------------
001933  1               ;CLEAR32:	STY FATPTRD
001933  1               ;		STA FATPTRD+1
001933  1               ;		LDA #0
001933  1               ;FILL32:		LDY #3
001933  1               ;CL32A:		STA (FATPTRD),Y
001933  1               ;		DEY
001933  1               ;		BPL CL32A
001933  1               ;		RTS
001933  1               
001933  1               ;-------------------------------------------------------------------------------
001933  1               ; print A hexadecimal, retain AXY
001933  1               ;-------------------------------------------------------------------------------
001933  1  48           PUTHEX:		PHA
001934  1  8A           		TXA
001935  1  48           		PHA
001936  1  98           		TYA
001937  1  48           		PHA
001938  1               
001938  1               	.IF PLATFORM = 2 || PLATFORM = 4
001938  1  BA           		TSX
001939  1  BD 03 01     		LDA $103,X
00193C  1               	.ELSE
00193C  1               		LDA 3,s
00193C  1               	.ENDIF
00193C  1  48           		PHA
00193D  1  4A           		LSR
00193E  1  4A           		LSR
00193F  1  4A           		LSR
001940  1  4A           		LSR
001941  1  20 50 19     		JSR PUTNIB
001944  1               
001944  1  68           		PLA
001945  1  29 0F        		AND #15
001947  1  20 50 19     		JSR PUTNIB
00194A  1               
00194A  1  68           		PLA
00194B  1  A8           		TAY
00194C  1  68           		PLA
00194D  1  AA           		TAX
00194E  1  68           		PLA
00194F  1  60           		RTS
001950  1               
001950  1  C9 0A        PUTNIB:		CMP #10
001952  1  90 02        		BCC PUTNIB1
001954  1  69 06        		ADC #6
001956  1  69 30        PUTNIB1:	ADC #48
001958  1  4C A3 19     		JMP EOUTCH
00195B  1               
00195B  1  48           PRINT:		PHA
00195C  1  8A           		TXA
00195D  1  48           		PHA
00195E  1  98           		TYA
00195F  1  48           		PHA
001960  1               	.IF PLATFORM = 2 || PLATFORM = 4
001960  1  BA           		TSX
001961  1  BD 03 01     		LDA $103,X
001964  1  C9 0A        		CMP #$0A
001966  1  D0 02        		BNE PR1
001968  1  A9 9B        		LDA #EOL
00196A  1               	.ELSE
00196A  1               		lda 3,s
00196A  1               	.ENDIF
00196A  1  20 A3 19     PR1:		JSR EOUTCH
00196D  1  68           		PLA
00196E  1  A8           		TAY
00196F  1  68           		PLA
001970  1  AA           		TAX
001971  1  68           		PLA
001972  1  60           		RTS
001973  1               
001973  1  48           SPACE:		pha
001974  1  A9 20        		lda #32
001976  1  D0 03        		bne NEWLINE1
001978  1               
001978  1  48           NEWLINE:	PHA
001979  1  A9 9B        		LDA #EOL
00197B  1  20 5B 19     NEWLINE1:	JSR PRINT
00197E  1  68           		PLA
00197F  1  60           		RTS
001980  1               ;
001980  1               ;
001980  1               ;
001980  1  A8           PRINTSTR:	TAY
001981  1  A5 00        		LDA FATPTRS
001983  1  48           		PHA
001984  1  A5 01        		LDA FATPTRS+1
001986  1  48           		PHA
001987  1               
001987  1  86 00        		STX FATPTRS
001989  1  84 01        		STY FATPTRS+1
00198B  1  A0 00        		LDY #0
00198D  1  90 03        		BCC PRINTSTR2
00198F  1               
00198F  1  20 78 19     		JSR NEWLINE
001992  1               
001992  1  B1 00        PRINTSTR2:	LDA (FATPTRS),Y
001994  1  F0 06        		BEQ PRINTSTR1
001996  1  20 5B 19     		JSR PRINT
001999  1  C8           		INY
00199A  1  D0 F6        		BNE PRINTSTR2	;do not print more than 256 chars
00199C  1  68           PRINTSTR1:	PLA
00199D  1  85 01        		STA FATPTRS+1
00199F  1  68           		PLA
0019A0  1  85 00        		STA FATPTRS
0019A2  1  60           		RTS
0019A3  1               
0019A3  1               	.IF DEBUG = 1
0019A3  1               PRINTINFO:
0019A3  1               	.IF PLATFORM = 2 || PLATFORM = 4
0019A3  1               		LDA #4					;key still pressed
0019A3  1               		BIT SKSTAT
0019A3  1               		BNE PRINTINFO4				;no, leave
0019A3  1               		LDA KBCODE				;help key?
0019A3  1               		CMP #17
0019A3  1               		BEQ PRINTINFO6				;yes print
0019A3  1               PRINTINFO4:	RTS
0019A3  1               	.ENDIF
0019A3  1               
0019A3  1               PRINTINFO6:	SEC
0019A3  1               		LDX #<MSG0
0019A3  1               		LDA #>MSG0
0019A3  1               		JSR PRINTSTR
0019A3  1               		LDA SECCLUS
0019A3  1               		JSR PUTHEX
0019A3  1               
0019A3  1               		SEC
0019A3  1               		LDX #<MSG1
0019A3  1               		LDA #>MSG1
0019A3  1               		JSR PRINTSTR
0019A3  1               		LDA RESSEC+1
0019A3  1               		JSR PUTHEX
0019A3  1               		LDA RESSEC
0019A3  1               		JSR PUTHEX
0019A3  1               
0019A3  1               		SEC
0019A3  1               		LDX #<MSG2
0019A3  1               		LDA #>MSG2
0019A3  1               		JSR PRINTSTR
0019A3  1               		LDA NUMFATS
0019A3  1               		JSR PUTHEX
0019A3  1               
0019A3  1               		SEC
0019A3  1               		LDX #<MSG3
0019A3  1               		LDA #>MSG3
0019A3  1               		JSR PRINTSTR
0019A3  1               		LDA NUMDIR+1
0019A3  1               		JSR PUTHEX
0019A3  1               		LDA NUMDIR
0019A3  1               		JSR PUTHEX
0019A3  1               
0019A3  1               		SEC
0019A3  1               		LDX #<MSG4
0019A3  1               		LDA #>MSG4
0019A3  1               		JSR PRINTSTR
0019A3  1               		LDA SECSFAT+1
0019A3  1               		JSR PUTHEX
0019A3  1               		LDA SECSFAT
0019A3  1               		JSR PUTHEX
0019A3  1               
0019A3  1               		SEC
0019A3  1               		LDX #<MSG5
0019A3  1               		LDA #>MSG5
0019A3  1               		JSR PRINTSTR
0019A3  1               		LDX #3
0019A3  1               PRINTINFO7:	LDA SECTOR,X
0019A3  1               		JSR PUTHEX
0019A3  1               		DEX
0019A3  1               		BPL PRINTINFO7
0019A3  1               
0019A3  1               		SEC
0019A3  1               		LDX #<MSG6
0019A3  1               		LDA #>MSG6
0019A3  1               		JSR PRINTSTR
0019A3  1               		LDX #3
0019A3  1               PRINTINFO1:	LDA FATBASE,X
0019A3  1               		JSR PUTHEX
0019A3  1               		DEX
0019A3  1               		BPL PRINTINFO1
0019A3  1               
0019A3  1               		SEC
0019A3  1               		LDX #<MSG7
0019A3  1               		LDA #>MSG7
0019A3  1               		JSR PRINTSTR
0019A3  1               		LDX #3
0019A3  1               PRINTINFO2:	LDA DIRBASE,X
0019A3  1               		JSR PUTHEX
0019A3  1               		DEX
0019A3  1               		BPL PRINTINFO2
0019A3  1               
0019A3  1               		SEC
0019A3  1               		LDX #<MSG8
0019A3  1               		LDA #>MSG8
0019A3  1               		JSR PRINTSTR
0019A3  1               		LDX #3
0019A3  1               PRINTINFO3:	LDA DATBASE,X
0019A3  1               		JSR PUTHEX
0019A3  1               		DEX
0019A3  1               		BPL PRINTINFO3
0019A3  1               
0019A3  1               	.IF PLATFORM = 2 || PLATFORM = 4
0019A3  1               		LDA #4
0019A3  1               PRINTINFO5:	BIT SKSTAT
0019A3  1               		BEQ PRINTINFO5
0019A3  1               	.ENDIF
0019A3  1               
0019A3  1               		JMP NEWLINE
0019A3  1               
0019A3  1               MSG0:		.byte "Sectors per cluster: $",0
0019A3  1               MSG1:		.byte "Reserved sectors   : $",0
0019A3  1               MSG2:		.byte "Number of FATs     : $",0
0019A3  1               MSG3:		.byte "Number of root-entr: $",0
0019A3  1               MSG4:		.byte "Sectors per FAT    : $",0
0019A3  1               MSG5:		.byte "FAT-16 boot sector : $",0
0019A3  1               MSG6:		.byte "FAT base           : $",0
0019A3  1               MSG7:		.byte "DIR base           : $",0
0019A3  1               MSG8:		.byte "DAT base           : $",0
0019A3  1               
0019A3  1               	.ENDIF
0019A3  1               
0019A3  1               ;-------------------------------------------------------------------------------
0019A3  1               ; print character via Editor handler routine at $E406
0019A3  1               ;-------------------------------------------------------------------------------
0019A3  1  AA           EOUTCH:		TAX
0019A4  1  AD 07 E4     		LDA EPB+1
0019A7  1  48           		PHA
0019A8  1  AD 06 E4     		LDA EPB
0019AB  1  48           		PHA
0019AC  1  8A           		TXA
0019AD  1  60           		RTS
0019AE  1               
0019AE  1               ;-------------------------------------------------------------------------------
0019AE  1               ; print SECTOR
0019AE  1               ;-------------------------------------------------------------------------------
0019AE  1               ;DUMPSEC:	pha
0019AE  1               ;		txa
0019AE  1               ;		pha
0019AE  1               ;		ldx #3
0019AE  1               ;DUMPSEC1:	lda SECTOR,x
0019AE  1               ;		jsr PUTHEX
0019AE  1               ;		dex
0019AE  1               ;		bpl DUMPSEC1
0019AE  1               ;		jsr NEWLINE
0019AE  1               ;		pla
0019AE  1               ;		tax
0019AE  1               ;		pla
0019AE  1               ;		rts
0019AE  1               
0019AE  1               ;-------------------------------------------------------------------------------
0019AE  1               ; DEBUG FATPTRS
0019AE  1               ;-------------------------------------------------------------------------------
0019AE  1               ;DUMPPTR:	LDA FATPTRS+1
0019AE  1               ;		JSR PUTHEX
0019AE  1               ;		LDA FATPTRS
0019AE  1               ;		JSR PUTHEX
0019AE  1               ;		JMP SPACE
0019AE  1               
0019AE  1               ;DUMPBUF:	jsr DUMP256
0019AE  1               ;		lda #4					;key still pressed
0019AE  1               ;DUMPBUF3:	bit SKSTAT
0019AE  1               ;		bne DUMPBUF3				;no
0019AE  1               ;		inc DUMPBUF2+2
0019AE  1               ;		jsr DUMP256
0019AE  1               ;		dec DUMPBUF2+2
0019AE  1               ;		lda #4					;key still pressed
0019AE  1               ;DUMPBUF4:	bit SKSTAT
0019AE  1               ;		bne DUMPBUF4				;no
0019AE  1               ;		rts
0019AE  1               ;
0019AE  1               ;DUMP256:	ldx #0
0019AE  1               ;DUMPBUF1:	txa
0019AE  1               ;		and #15
0019AE  1               ;		bne DUMPBUF2
0019AE  1               ;		jsr NEWLINE
0019AE  1               ;DUMPBUF2:	lda BUFFER, x
0019AE  1               ;		jsr PUTHEX
0019AE  1               ;		inx
0019AE  1               ;		bne DUMPBUF1
0019AE  1               ;		jmp NEWLINE
0019AE  1               
0019AE  1               	.IF PLATFORM = 4
0019AE  1               		.include "dup.a65"
0019AE  2               	.IF PLATFORM  <= 1
0019AE  2               		.A8
0019AE  2               		.I8
0019AE  2               	.ENDIF
0019AE  2               
0019AE  2               	.IF PLATFORM = 2
0019AE  2               
0019AE  2               		.include "fat16.inc"
0019AE  2               		.include "atarixl.inc"
0019AE  2               	.ENDIF
0019AE  2               
0019AE  2               	.IF PLATFORM = 2 || PLATFORM = 4
0019AE  2               
0019AE  2               FNAME		= $500
0019AE  2               FVEC		= $2E0
0019AE  2               FINIT		= $2E2
0019AE  2               	.ENDIF
0019AE  2               
0019AE  2               	.IF PLATFORM = 2
0019AE  2               		.ORG DUPCODE
0019AE  2               	.ENDIF
0019AE  2               
0019AE  2               	.IF PLATFORM = 3
0019AE  2               		.include "fat16.inc"
0019AE  2               		.include "homebrew.inc"
0019AE  2               		.include "myos.inc"
0019AE  2               
0019AE  2               		DUPCODE		= $0A00
0019AE  2               		.ORG DUPCODE
0019AE  2               	.ENDIF
0019AE  2               ;
0019AE  2               ;
0019AE  2               ;
0019AE  2               ;		JMP	DUPINIT
0019AE  2               ;		JMP	LOADFIL
0019AE  2               
0019AE  2  A9 00        DUPINIT:	LDA	#0
0019B0  2  A2 1F        		LDX	#31
0019B2  2  9D 00 05     DUPINIT1:	STA	FNAME,x
0019B5  2  CA           		DEX
0019B6  2  10 FA        		BPL	DUPINIT1
0019B8  2  A9 4C        		LDA	#$4C
0019BA  2  8D 78 07     		STA	JMPIND
0019BD  2               
0019BD  2               	.IF PLATFORM = 2 || PLATFORM = 4
0019BD  2               ;		LDX	#$70
0019BD  2               ;		LDA	#OPEN
0019BD  2               ;		STA 	ICCOM,X
0019BD  2               ;		LDA 	#4
0019BD  2               ;		STA 	ICAX1,X
0019BD  2               ;		STA 	ICBLH,X
0019BD  2               ;		LDA 	#<KBDNAME
0019BD  2               ;		STA 	ICBAL,X
0019BD  2               ;		LDA 	#>KBDNAME
0019BD  2               ;		STA 	ICBAH,X
0019BD  2               ;		LDA 	#0
0019BD  2               ;		STA 	ICBLL,X
0019BD  2               ;		STA 	ICAX2,X
0019BD  2               ;		JSR 	CIOV
0019BD  2               	.ENDIF
0019BD  2               
0019BD  2  18           MENU:		CLC
0019BE  2  A2 7E        		LDX	#<DUPMENU
0019C0  2  A9 1D        		LDA	#>DUPMENU
0019C2  2  20 80 19     		JSR	JPRINTSTR
0019C5  2               
0019C5  2  20 64 1D     		JSR 	GETCHAR
0019C8  2  20 5B 19     		JSR	JPRINT
0019CB  2               
0019CB  2  A2 08        		LDX	#8
0019CD  2  DD 2F 1E     FINDCMD:	CMP	CMDTABXIO,X
0019D0  2  F0 05        		BEQ	DOCMD
0019D2  2  CA           		DEX
0019D3  2  10 F8        		BPL	FINDCMD
0019D5  2  30 E6        		BMI	MENU
0019D7  2               
0019D7  2  E0 04        DOCMD:		CPX	#4
0019D9  2  90 0E        		BCC	DOXIO
0019DB  2  8A           		TXA
0019DC  2  E9 04        		SBC	#4		;carry set = 4
0019DE  2  0A           		ASL
0019DF  2  AA           		TAX
0019E0  2  BD 3D 1E     		LDA	JMPTAB+1,X
0019E3  2  48           		PHA
0019E4  2  BD 3C 1E     		LDA	JMPTAB,X
0019E7  2  48           		PHA
0019E8  2  60           		RTS
0019E9  2               
0019E9  2  BD 38 1E     DOXIO:		LDA	XIOCMD,X
0019EC  2  A2 10        		LDX	#$10
0019EE  2  9D 42 03     		STA	ICCOM,X
0019F1  2               
0019F1  2  20 0B 1A     		JSR 	PRINTSPEC
0019F4  2               
0019F4  2  20 CB 1C     		JSR 	GETSTR
0019F7  2  30 6D        		BMI 	ERR
0019F9  2               
0019F9  2  20 15 1C     		JSR 	CORRNAME
0019FC  2               
0019FC  2  A2 10        		LDX	#$10
0019FE  2  20 E0 1C     		JSR 	FOPEN3
001A01  2  30 63        		BMI 	ERR
001A03  2  10 B8        		BPL 	MENU
001A05  2               
001A05  2               
001A05  2               
001A05  2  BA           EXIT:		TSX
001A06  2  E0 FF        		CPX	#$FF
001A08  2  F0 B3        		BEQ	MENU
001A0A  2  60           EXIT1:		RTS
001A0B  2               
001A0B  2               
001A0B  2  18           PRINTSPEC:	CLC
001A0C  2  A2 55        		LDX	#<SPECSTR
001A0E  2  A9 1E        		LDA	#>SPECSTR
001A10  2  4C 80 19     		JMP	JPRINTSTR
001A13  2               
001A13  2               
001A13  2  18           GOTOADR:	CLC
001A14  2  A2 97        		LDX	#<GOTOSTR
001A16  2  A9 1E        		LDA	#>GOTOSTR
001A18  2  20 80 19     		JSR	JPRINTSTR
001A1B  2               
001A1B  2  20 18 1D     		JSR 	ENTERADR
001A1E  2  C9 58        		CMP 	#'X'
001A20  2  F0 9B        		BEQ 	MENU
001A22  2  20 28 1A     		JSR 	GOTOADR1
001A25  2  4C BD 19     		JMP 	MENU
001A28  2  6C 6B 07     GOTOADR1:	JMP 	(ASTART)
001A2B  2               
001A2B  2  20 0B 1A     DIR:		JSR 	PRINTSPEC
001A2E  2               
001A2E  2  20 CB 1C     		JSR 	GETSTR
001A31  2  30 33        		BMI 	ERR
001A33  2               
001A33  2  AD 00 05     		LDA 	FNAME		;only EOL entered?
001A36  2  C9 9B        		CMP 	#EOL
001A38  2  D0 0B        		BNE 	DIR4		;no
001A3A  2               
001A3A  2  A2 05        		LDX 	#5		;replace with D:*.*
001A3C  2  BD 6A 1E     DIR3:		LDA 	DEFSPEC,X
001A3F  2  9D 00 05     		STA 	FNAME,X
001A42  2  CA           		DEX
001A43  2  10 F7        		BPL 	DIR3
001A45  2               
001A45  2  20 15 1C     DIR4:		JSR 	CORRNAME
001A48  2               
001A48  2  20 FA 1C     		JSR 	FOPENDIR
001A4B  2  30 19        		BMI 	ERR
001A4D  2               
001A4D  2  20 99 1C     DIR1:		JSR 	FGETDIR
001A50  2  30 0B        		BMI 	DIR2
001A52  2               
001A52  2  18           		CLC
001A53  2  A2 00        		LDX 	#<FNAME
001A55  2  A9 05        		LDA 	#>FNAME
001A57  2  20 80 19     		JSR 	JPRINTSTR
001A5A  2  4C 4D 1A     		JMP 	DIR1
001A5D  2               
001A5D  2  20 0E 1D     DIR2:		JSR 	FCLOSE
001A60  2  20 64 1D     		JSR 	GETCHAR
001A63  2  4C BD 19     		JMP 	MENU
001A66  2               
001A66  2  98           ERR:		TYA
001A67  2  48           		PHA
001A68  2  20 0E 1D     		JSR 	FCLOSE
001A6B  2               
001A6B  2  18           		CLC
001A6C  2  A2 62        		LDX	#<ERRSTR
001A6E  2  A9 1E        		LDA	#>ERRSTR
001A70  2  20 80 19     		JSR	JPRINTSTR
001A73  2               
001A73  2  68           		PLA
001A74  2  20 33 19     ERRPRT:		JSR 	JPUTHEX
001A77  2  20 64 1D     		JSR 	GETCHAR
001A7A  2  4C BD 19     		JMP 	MENU
001A7D  2               
001A7D  2               ;-------------------------------------------------------------------------------
001A7D  2               ; Load File
001A7D  2               ; - Print Filespec
001A7D  2               ; - Get String
001A7D  2               ; - Load file in Chunks
001A7D  2               ;-------------------------------------------------------------------------------
001A7D  2  20 0B 1A     LOAD:		JSR 	PRINTSPEC
001A80  2  20 CB 1C     		JSR 	GETSTR
001A83  2  30 E1        		BMI 	ERR
001A85  2  20 8D 1A     		JSR 	LOADFIL
001A88  2  30 DC        		BMI 	ERR
001A8A  2  4C BD 19     		JMP 	MENU
001A8D  2               
001A8D  2               
001A8D  2  A9 14        LOADFIL:	LDA 	#<LABRTS
001A8F  2  8D E0 02     		STA 	FVEC
001A92  2  A9 1C        		LDA 	#>LABRTS
001A94  2  8D E1 02     		STA 	FVEC+1
001A97  2               
001A97  2  20 15 1C     		JSR 	CORRNAME
001A9A  2               
001A9A  2  20 D4 1C     		JSR 	FOPEN
001A9D  2  30 47        		BMI 	ERR1
001A9F  2  20 A3 1C     		JSR 	FGETST		;get 2 bytes in ASTART
001AA2  2  30 42        		BMI 	ERR1
001AA4  2               
001AA4  2  A9 FF        		LDA 	#$FF		;check if first 2-bytes are $FF
001AA6  2  CD 6B 07     		CMP 	ASTART		;if not, close and exit
001AA9  2  D0 43        		BNE 	MCLOSE
001AAB  2  CD 6C 07     		CMP 	ASTART+1
001AAE  2  D0 3E        		BNE 	MCLOSE
001AB0  2               
001AB0  2  20 A3 1C     LOADCHU1:	JSR 	FGETST		;get start address
001AB3  2  30 31        		BMI 	ERR1
001AB5  2  20 B2 1C     LOADCHU:	JSR 	FGETEND		;get end address
001AB8  2  30 2C        		BMI 	ERR1
001ABA  2  20 41 1C     		JSR 	FGETCHUN	;read chunk of data
001ABD  2  30 27        		BMI 	ERR1
001ABF  2               
001ABF  2  AD E2 02     		LDA 	FINIT		;init this chunk
001AC2  2  8D 79 07     		STA 	JMPPTR
001AC5  2  AD E3 02     		LDA 	FINIT+1
001AC8  2  8D 7A 07     		STA 	JMPPTR+1
001ACB  2  20 78 07     		JSR 	JMPIND
001ACE  2               
001ACE  2  20 A3 1C     		JSR 	FGETST		;read next 2-bytes
001AD1  2  C0 88        		CPY 	#EOFERR		;EOF?
001AD3  2  F0 1C        		BEQ 	FGOTO		;yes, try to start the file
001AD5  2  98           		TYA
001AD6  2  30 0E        		BMI 	ERR1		;error?
001AD8  2               
001AD8  2  A9 FF        		LDA 	#$FF		;skip if $FF $FF
001ADA  2  CD 6B 07     		CMP 	ASTART
001ADD  2  D0 D6        		BNE 	LOADCHU
001ADF  2  CD 6C 07     		CMP 	ASTART+1
001AE2  2  D0 D1        		BNE 	LOADCHU
001AE4  2  F0 CA        		BEQ 	LOADCHU1
001AE6  2               
001AE6  2  98           ERR1:		TYA
001AE7  2  48           		PHA
001AE8  2  20 0E 1D     		JSR 	FCLOSE
001AEB  2  68           		PLA
001AEC  2  A8           		TAY
001AED  2  60           		RTS
001AEE  2               
001AEE  2  4C 0E 1D     MCLOSE:		JMP 	FCLOSE
001AF1  2               
001AF1  2               
001AF1  2  20 0E 1D     FGOTO:		JSR 	FCLOSE
001AF4  2               ;		SEC
001AF4  2               ;		LDX	#<READYSTR
001AF4  2               ;		LDA	#>READYSTR
001AF4  2               ;		JSR	JPRINTSTR
001AF4  2               ;		JSR	GETCHAR
001AF4  2               
001AF4  2  A9 04        		LDA	#4					;key still pressed
001AF6  2  2C 0F D2     FGOTO1:		BIT	SKSTAT
001AF9  2  F0 FB        		BEQ	FGOTO1					;yes, loop
001AFB  2               
001AFB  2  AD E0 02     		LDA 	FVEC
001AFE  2  8D 79 07     		STA 	JMPPTR
001B01  2  AD E1 02     		LDA 	FVEC+1
001B04  2  8D 7A 07     		STA 	JMPPTR+1
001B07  2  20 78 07     		JSR 	JMPIND
001B0A  2  A9 01        		LDA	#SUCCES
001B0C  2  60           		RTS
001B0D  2               
001B0D  2               ;-------------------------------------------------------------------------------
001B0D  2               ; Binary Save
001B0D  2               ; FROM
001B0D  2               ;  TO
001B0D  2               ; INTO (if zero use FROM/TO as is)
001B0D  2               ; APPEND (Y/N)
001B0D  2               ;-------------------------------------------------------------------------------
001B0D  2  A2 70        SAVE:		LDX	#<FROMSTR
001B0F  2  A9 1E        		LDA	#>FROMSTR
001B11  2  20 80 19     		JSR	JPRINTSTR
001B14  2  20 18 1D     		JSR 	ENTERADR
001B17  2  C9 58        		CMP 	#'X'
001B19  2  D0 03        		BNE	SAVE1
001B1B  2  4C BD 19     		JMP 	MENU
001B1E  2               
001B1E  2  AD 6B 07     SAVE1:		LDA	ASTART
001B21  2  8D 72 07     		STA	FSTART
001B24  2  AD 6C 07     		LDA	ASTART+1
001B27  2  8D 73 07     		STA	FSTART+1
001B2A  2               
001B2A  2               	.IF PLATFORM <= 1
001B2A  2               		SEC
001B2A  2               	.ELSE
001B2A  2  18           		CLC
001B2B  2               	.ENDIF
001B2B  2  A2 79        		LDX	#<TOSTR
001B2D  2  A9 1E        		LDA	#>TOSTR
001B2F  2  20 80 19     		JSR	JPRINTSTR
001B32  2  20 18 1D     		JSR 	ENTERADR
001B35  2  C9 58        		CMP 	#'X'
001B37  2  D0 03        		BNE	SAVE2
001B39  2  4C BD 19     SAVE6:		JMP 	MENU
001B3C  2               
001B3C  2  38           SAVE2:		SEC					;copy ASTART TO FEND
001B3D  2  AD 6B 07     		LDA	ASTART				;FLENGTH = FEND - FSTART
001B40  2  8D 74 07     		STA	FEND
001B43  2  ED 72 07     		SBC	FSTART
001B46  2  8D 76 07     		STA	FLENGTH
001B49  2  AD 6C 07     		LDA	ASTART+1
001B4C  2  8D 75 07     		STA	FEND+1
001B4F  2  ED 73 07     		SBC	FSTART+1
001B52  2  8D 77 07     		STA	FLENGTH+1
001B55  2               
001B55  2  A2 FF        		LDX	#$FF				;init $FF $FF header
001B57  2  8E 70 07     		STX	FHEADER
001B5A  2  8E 71 07     		STX	FHEADER+1
001B5D  2               
001B5D  2  18           		CLC
001B5E  2  A2 83        		LDX	#<INTOSTR
001B60  2  A9 1E        		LDA	#>INTOSTR
001B62  2  20 80 19     		JSR	JPRINTSTR
001B65  2  20 18 1D     		JSR 	ENTERADR
001B68  2  C9 58        		CMP	#'X'
001B6A  2  F0 CD        		BEQ	SAVE6				;jump back to menu
001B6C  2               
001B6C  2  AD 6B 07     		LDA	ASTART				;is INTO zero, do nothing
001B6F  2  0D 6C 07     		ORA	ASTART+1
001B72  2  F0 19        		BEQ	SAVE9
001B74  2               
001B74  2  18           		CLC					;otherwise
001B75  2  AD 6B 07     		LDA	ASTART				;copy ASTART TO FSTART
001B78  2  8D 72 07     		STA	FSTART				;FEND = FSTART + FLENGTH
001B7B  2  6D 76 07     		ADC	FLENGTH
001B7E  2  8D 74 07     		STA	FEND
001B81  2  AD 6C 07     		LDA	ASTART+1
001B84  2  8D 73 07     		STA	FSTART+1
001B87  2  6D 77 07     		ADC	FLENGTH+1
001B8A  2  8D 75 07     		STA	FEND+1
001B8D  2               SAVE9:
001B8D  2               	.IF PLATFORM <= 1
001B8D  2               		SEC
001B8D  2               	.ELSE
001B8D  2  18           		CLC
001B8E  2               	.ENDIF
001B8E  2  A2 58        		LDX	#<(SPECSTR+3)
001B90  2  A9 1E        		LDA	#>(SPECSTR+3)
001B92  2  20 80 19     		JSR	JPRINTSTR
001B95  2               
001B95  2  20 CB 1C     		JSR 	GETSTR
001B98  2  10 03        		BPL	SAVE3
001B9A  2  4C 66 1A     		JMP 	ERR
001B9D  2  20 15 1C     SAVE3:		JSR 	CORRNAME
001BA0  2               
001BA0  2  18           		CLC
001BA1  2  A2 8D        		LDX	#<APPENDSTR
001BA3  2  A9 1E        		LDA	#>APPENDSTR
001BA5  2  20 80 19     		JSR	JPRINTSTR
001BA8  2               
001BA8  2  20 64 1D     		JSR 	GETCHAR
001BAB  2  A8           		TAY
001BAC  2  20 5B 19     		JSR	JPRINT
001BAF  2               
001BAF  2               ;		JSR	DUPDEBUG
001BAF  2               
001BAF  2  A2 10        		LDX 	#$10
001BB1  2  A9 03        		LDA 	#OPEN
001BB3  2  9D 42 03     		STA 	ICCOM,X
001BB6  2  A9 08        		LDA	#8
001BB8  2  C0 59        		CPY	#'Y'
001BBA  2  D0 02        		BNE	SAVE7
001BBC  2  09 01        		ORA	#1
001BBE  2  20 DD 1C     SAVE7:		JSR	FOPEN2
001BC1  2  10 03        		BPL	SAVE4
001BC3  2  4C 66 1A     		JMP	ERR
001BC6  2               
001BC6  2  A9 0B        SAVE4:		LDA	#PUTCHR
001BC8  2  9D 42 03     		STA	ICCOM,X
001BCB  2  A9 06        		LDA	#6
001BCD  2  9D 48 03     		STA	ICBLL,X
001BD0  2  A9 00        		LDA	#0
001BD2  2               	.IF PLATFORM  <= 1
001BD2  2               		STA	ICBAB,X
001BD2  2               		STA	ICBLB,X
001BD2  2               	.ENDIF
001BD2  2  9D 49 03     		STA	ICBLH,X
001BD5  2  A9 70        		LDA	#<FHEADER
001BD7  2  9D 44 03     		STA	ICBAL,X
001BDA  2  A9 07        		LDA	#>FHEADER
001BDC  2  9D 45 03     		STA	ICBAH,X
001BDF  2  20 56 E4     		JSR	CIOV
001BE2  2  30 23        		BMI	SAVECLOSE
001BE4  2               
001BE4  2  AD 72 07     		LDA	FSTART
001BE7  2  9D 44 03     		STA	ICBAL,X
001BEA  2  AD 73 07     		LDA	FSTART+1
001BED  2  9D 45 03     		STA	ICBAH,X
001BF0  2  AD 76 07     		LDA	FLENGTH
001BF3  2  9D 48 03     		STA	ICBLL,X
001BF6  2  AD 77 07     		LDA	FLENGTH+1
001BF9  2  9D 49 03     		STA	ICBLH,X					;ICBLL/H = FLENGTH + 1
001BFC  2  FE 48 03     		INC	ICBLL,X
001BFF  2  D0 03        		BNE	SAVE5
001C01  2  FE 49 03     		INC	ICBLH,X
001C04  2  20 56 E4     SAVE5:		JSR	CIOV
001C07  2  20 0E 1D     SAVECLOSE:	JSR	FCLOSE
001C0A  2  A9 04        		LDA	#4					;key still pressed
001C0C  2  2C 0F D2     SAVE8:		BIT	SKSTAT
001C0F  2  F0 FB        		BEQ	SAVE8					;yes, loop
001C11  2  4C BD 19     		JMP	MENU
001C14  2               
001C14  2  60           LABRTS:		RTS
001C15  2               
001C15  2               	.IF PLATFORM=99
001C15  2               DUPDEBUG:	;LDA	ASTART
001C15  2               		;JSR	JPUTHEX
001C15  2               		;LDA	ASTART+1
001C15  2               		;JSR	JPUTHEX
001C15  2               		;LDA	AEND
001C15  2               		;JSR	JPUTHEX
001C15  2               		;LDA	AEND+1
001C15  2               		;JSR	JPUTHEX
001C15  2               		;LDA	FVEC
001C15  2               		;JSR	JPUTHEX
001C15  2               		;LDA	FVEC+1
001C15  2               		;JSR	JPUTHEX
001C15  2               		;LDA	FINIT
001C15  2               		;JSR	JPUTHEX
001C15  2               		;LDA	FINIT+1
001C15  2               		;JSR	JPUTHEX
001C15  2               		LDA	FSTART+1
001C15  2               		JSR	PUTHEX
001C15  2               		LDA	FSTART
001C15  2               		JSR	PUTHEX
001C15  2               
001C15  2               		LDA	FEND+1
001C15  2               		JSR	PUTHEX
001C15  2               		LDA	FEND
001C15  2               		JSR	PUTHEX
001C15  2               
001C15  2               		LDA	FLENGTH+1
001C15  2               		JSR	PUTHEX
001C15  2               		LDA	FLENGTH
001C15  2               		JSR	PUTHEX
001C15  2               
001C15  2               		RTS
001C15  2               	.ENDIF
001C15  2               
001C15  2  A9 3A        CORRNAME:	LDA 	#':'
001C17  2  CD 01 05     		CMP 	FNAME+1
001C1A  2  F0 F8        		BEQ 	LABRTS
001C1C  2  CD 02 05     		CMP 	FNAME+2
001C1F  2  F0 F3        		BEQ 	LABRTS
001C21  2               
001C21  2  A2 00        		LDX 	#0
001C23  2  BD 00 05     CORRNAM2:	LDA 	FNAME,X
001C26  2  C9 9B        		CMP 	#EOL
001C28  2  F0 03        		BEQ 	CORRNAM1
001C2A  2  E8           		INX
001C2B  2  D0 F6        		BNE 	CORRNAM2
001C2D  2               
001C2D  2  BD 00 05     CORRNAM1:	LDA 	FNAME,X
001C30  2  9D 02 05     		STA 	FNAME+2,X
001C33  2  CA           		DEX
001C34  2  10 F7        		BPL 	CORRNAM1
001C36  2  A9 44        		LDA 	#DRVCHAR
001C38  2  8D 00 05     		STA 	FNAME
001C3B  2  A9 3A        		LDA 	#':'
001C3D  2  8D 01 05     		STA 	FNAME+1
001C40  2  60           		RTS
001C41  2               
001C41  2  AD 6C 07     FGETCHUN:	LDA 	ASTART+1
001C44  2  20 33 19     		JSR 	JPUTHEX
001C47  2  AD 6B 07     		LDA 	ASTART
001C4A  2  20 33 19     		JSR 	JPUTHEX
001C4D  2  A9 2D        		LDA 	#'-'
001C4F  2  20 5B 19     		JSR 	JPRINT
001C52  2  AD 6E 07     		LDA 	AEND+1
001C55  2  20 33 19     		JSR 	JPUTHEX
001C58  2  AD 6D 07     		LDA 	AEND
001C5B  2  20 33 19     		JSR 	JPUTHEX
001C5E  2  A9 9B        		LDA 	#EOL
001C60  2  20 5B 19     		JSR 	JPRINT
001C63  2               
001C63  2  A9 14        		LDA 	#<LABRTS
001C65  2  8D E2 02     		STA 	FINIT
001C68  2  A9 1C        		LDA 	#>LABRTS
001C6A  2  8D E3 02     		STA 	FINIT+1
001C6D  2               
001C6D  2  A2 10        		LDX 	#$10
001C6F  2  38           		SEC
001C70  2               	.IF PLATFORM  <= 1
001C70  2               		LDA	#0
001C70  2               		STA	ICBAB,X
001C70  2               		STA	ICBLB,X
001C70  2               	.ENDIF
001C70  2               
001C70  2  AD 6D 07     		LDA 	AEND
001C73  2  ED 6B 07     		SBC 	ASTART
001C76  2  9D 48 03     		STA 	ICBLL,X
001C79  2  AD 6E 07     		LDA 	AEND+1
001C7C  2  ED 6C 07     		SBC 	ASTART+1
001C7F  2  9D 49 03     		STA 	ICBLH,X
001C82  2  FE 48 03     		INC 	ICBLL,X
001C85  2  D0 03        		BNE 	FGETCHU1
001C87  2  FE 49 03     		INC 	ICBLH,X
001C8A  2               
001C8A  2  AD 6B 07     FGETCHU1:	LDA 	ASTART
001C8D  2  9D 44 03     		STA 	ICBAL,X
001C90  2  AD 6C 07     		LDA 	ASTART+1
001C93  2  9D 45 03     		STA 	ICBAH,X
001C96  2               
001C96  2  4C 06 1D     		JMP 	FGET
001C99  2               ;
001C99  2               ;
001C99  2               ;
001C99  2  A2 10        FGETDIR:	LDX 	#$10
001C9B  2  A9 05        		LDA 	#GETREC
001C9D  2  9D 42 03     		STA 	ICCOM,X
001CA0  2  4C E0 1C     		JMP 	FOPEN3
001CA3  2               
001CA3  2  A2 10        FGETST:		LDX 	#$10				;read 2 bytes to ASTART
001CA5  2  A9 6B        		LDA 	#<ASTART
001CA7  2  9D 44 03     		STA 	ICBAL,X
001CAA  2  A9 07        		LDA 	#>ASTART
001CAC  2  9D 45 03     		STA 	ICBAH,X
001CAF  2  4C BE 1C     		JMP 	FGET2
001CB2  2               
001CB2  2  A2 10        FGETEND:	LDX 	#$10
001CB4  2  A9 6D        		LDA 	#<AEND
001CB6  2  9D 44 03     		STA 	ICBAL,X
001CB9  2  A9 07        		LDA 	#>AEND
001CBB  2  9D 45 03     		STA 	ICBAH,X
001CBE  2               
001CBE  2  A9 02        FGET2:		LDA 	#2
001CC0  2  9D 48 03     		STA 	ICBLL,X
001CC3  2  A9 00        		LDA 	#0
001CC5  2  9D 49 03     		STA 	ICBLH,X
001CC8  2               	.IF PLATFORM  <= 1
001CC8  2               		STA	ICBAB,X
001CC8  2               		STA	ICBLB,X
001CC8  2               	.ENDIF
001CC8  2               
001CC8  2  4C 06 1D     		JMP 	FGET
001CCB  2               
001CCB  2  A2 00        GETSTR:		LDX 	#0
001CCD  2  A9 05        		LDA 	#GETREC
001CCF  2  9D 42 03     		STA 	ICCOM,X
001CD2  2  D0 0C        		BNE 	FOPEN3
001CD4  2               
001CD4  2  A2 10        FOPEN:		LDX 	#$10
001CD6  2  A9 03        		LDA 	#OPEN
001CD8  2  9D 42 03     		STA 	ICCOM,X
001CDB  2  A9 04        FOPEN1:		LDA 	#4
001CDD  2  9D 4A 03     FOPEN2:		STA 	ICAX1,X
001CE0  2  A9 00        FOPEN3:		LDA 	#<FNAME
001CE2  2  9D 44 03     		STA 	ICBAL,X
001CE5  2  A9 05        		LDA 	#>FNAME
001CE7  2  9D 45 03     		STA 	ICBAH,X
001CEA  2  A9 00        		LDA 	#0
001CEC  2               	.IF PLATFORM  <= 1
001CEC  2               		STA	ICBAB,X
001CEC  2               		STA	ICBLB,X
001CEC  2               	.ENDIF
001CEC  2  9D 48 03     		STA 	ICBLL,X
001CEF  2  9D 4B 03     		STA 	ICAX2,X
001CF2  2  A9 01        		LDA 	#1
001CF4  2  9D 49 03     		STA 	ICBLH,X
001CF7  2  4C 56 E4     		JMP 	CIOV
001CFA  2               
001CFA  2  A2 10        FOPENDIR:	LDX 	#$10
001CFC  2  A9 03        		LDA 	#OPEN
001CFE  2  9D 42 03     		STA 	ICCOM,X
001D01  2  A9 06        		LDA 	#6
001D03  2  4C DD 1C     		JMP 	FOPEN2
001D06  2               
001D06  2  A9 07        FGET:		LDA 	#GETCHR
001D08  2  9D 42 03     		STA 	ICCOM,X
001D0B  2  4C 56 E4     		JMP 	CIOV
001D0E  2               
001D0E  2  A2 10        FCLOSE:		LDX 	#$10
001D10  2  A9 0C        FCLOSE1:	LDA 	#CLOSE
001D12  2  9D 42 03     		STA 	ICCOM,X
001D15  2  4C 56 E4     		JMP 	CIOV
001D18  2               
001D18  2  A9 00        ENTERADR:	LDA	#0
001D1A  2  8D 6B 07     		STA	ASTART
001D1D  2  8D 6C 07     		STA	ASTART+1
001D20  2  A9 04        		LDA	#4
001D22  2  8D 6F 07     		STA	CNT
001D25  2               
001D25  2  20 64 1D     ENTERADRC:	JSR	GETCHAR
001D28  2  C9 9B        		CMP	#EOL
001D2A  2  F0 33        		BEQ	ENTERADREND
001D2C  2               
001D2C  2  C9 58        		CMP	#'X'
001D2E  2  D0 01        		BNE	ENTERADRD
001D30  2  60           		RTS
001D31  2               
001D31  2  20 5B 19     ENTERADRD:	JSR	JPRINT
001D34  2  C9 3A        		CMP	#':'
001D36  2  B0 08        		BCS	ENTERADRE
001D38  2  C9 30        		CMP	#'0'
001D3A  2  90 E9        		BCC	ENTERADRC
001D3C  2               
001D3C  2  29 0F        		AND	#%00001111
001D3E  2  B0 0A        		BCS	ENTERADRF
001D40  2               
001D40  2  C9 47        ENTERADRE:	CMP	#'G'
001D42  2  B0 E1        		BCS	ENTERADRC
001D44  2  C9 41        		CMP	#'A'
001D46  2  90 DD        		BCC	ENTERADRC
001D48  2               
001D48  2  E9 37        		SBC	#'7'
001D4A  2  0A           ENTERADRF:	ASL
001D4B  2  0A           		ASL
001D4C  2  0A           		ASL
001D4D  2  0A           		ASL
001D4E  2  A2 04        		LDX	#4
001D50  2  0A           ENTERADRG:	ASL
001D51  2  2E 6B 07     		ROL	ASTART
001D54  2  2E 6C 07     		ROL	ASTART+1
001D57  2  CA           		DEX
001D58  2  D0 F6        		BNE	ENTERADRG
001D5A  2               
001D5A  2  CE 6F 07     		DEC	CNT
001D5D  2  D0 C6        		BNE	ENTERADRC
001D5F  2  A9 9B        ENTERADREND:	LDA	#EOL
001D61  2  4C 5B 19     		JMP	JPRINT
001D64  2               
001D64  2  A9 1D        GETCHAR:	lda	#>(UPPER-1)
001D66  2  48           		pha
001D67  2  A9 72        		lda	#<(UPPER-1)
001D69  2  48           		pha
001D6A  2  AD 25 E4     		lda	$e425
001D6D  2  48           		pha
001D6E  2  AD 24 E4     		lda	$e424
001D71  2  48           		pha
001D72  2  60           		rts
001D73  2               
001D73  2               ;		LDX	#$70
001D73  2               ;		LDA	#GETCHR
001D73  2               ;		STA 	ICCOM,X
001D73  2               ;		LDA 	#0
001D73  2               ;		STA 	ICBLL,X
001D73  2               ;		STA 	ICBLH,X
001D73  2               ;	.IF PLATFORM <= 1
001D73  2               ;		STA 	ICBLB,X
001D73  2               ;	.ENDIF
001D73  2               ;		JSR 	CIOV
001D73  2               
001D73  2  C9 61        UPPER:		cmp	#'a'
001D75  2  90 06        		bcc	UPPEREND
001D77  2  C9 7B        		cmp	#'z'+1
001D79  2  B0 02        		bcs	UPPEREND
001D7B  2  E9 1F        		sbc	#$1F
001D7D  2  60           UPPEREND:	rts
001D7E  2               
001D7E  2               
001D7E  2               ;
001D7E  2               DUPMENU:	;.byte CLS
001D7E  2  9B           		.byte EOL
001D7F  2  46 41 54 2D  		.byte "FAT-1"
001D83  2  31           
001D84  2               	.IF PLATFORM = 4
001D84  2  32           		.byte "2"
001D85  2               	.ELSE
001D85  2               		.byte "6"
001D85  2               	.ENDIF
001D85  2  20 44 4F 53  		.byte " DOS (c) by R. Scholz"
001D89  2  20 28 63 29  
001D8D  2  20 62 79 20  
001D9A  2  9B 9B        		.byte EOL,EOL
001D9C  2  41 20 2D 20  		.byte "A - Display Dir"
001DA0  2  44 69 73 70  
001DA4  2  6C 61 79 20  
001DAB  2  9B           		.byte EOL
001DAC  2  43 20 2D 20  		.byte "C - Change  Dir"
001DB0  2  43 68 61 6E  
001DB4  2  67 65 20 20  
001DBB  2  9B           		.byte EOL
001DBC  2  44 20 2D 20  		.byte "D - Delete  File"
001DC0  2  44 65 6C 65  
001DC4  2  74 65 20 20  
001DCC  2  9B           		.byte EOL
001DCD  2  47 20 2D 20  		.byte "G - Goto    Address"
001DD1  2  47 6F 74 6F  
001DD5  2  20 20 20 20  
001DE0  2  9B           		.byte EOL
001DE1  2  4C 20 2D 20  		.byte "L - Load    File"
001DE5  2  4C 6F 61 64  
001DE9  2  20 20 20 20  
001DF1  2  9B           		.byte EOL
001DF2  2  4D 20 2D 20  		.byte "M - Create  Dir"
001DF6  2  43 72 65 61  
001DFA  2  74 65 20 20  
001E01  2  9B           		.byte EOL
001E02  2  52 20 2D 20  		.byte "R - Rename  File"
001E06  2  52 65 6E 61  
001E0A  2  6D 65 20 20  
001E12  2  9B           		.byte EOL
001E13  2  53 20 2D 20  		.byte "S - Save    File"
001E17  2  53 61 76 65  
001E1B  2  20 20 20 20  
001E23  2  9B           		.byte EOL
001E24  2  58 20 2D 20  		.byte "X - Exit"
001E28  2  45 78 69 74  
001E2C  2  9B 9B        		.byte EOL,EOL
001E2E  2  00           		.byte 0
001E2F  2               
001E2F  2  43 44 4D 52  CMDTABXIO:	.byte "CDMR"
001E33  2  41 47 4C 53  CMDTAB:		.byte "AGLSX"
001E37  2  58           
001E38  2  29 21 22 20  XIOCMD:		.byte CCHADIR, CDELETE, CCREDIR, CRENAME
001E3C  2  2A 1A 12 1A  JMPTAB:		.word DIR-1, GOTOADR-1, LOAD-1, SAVE-1, EXIT-1
001E40  2  7C 1A 0C 1B  
001E44  2  04 1A        
001E46  2               
001E46  2  70 72 65 73  READYSTR:	.byte "press any key.",0
001E4A  2  73 20 61 6E  
001E4E  2  79 20 6B 65  
001E55  2  20 2D 20 46  SPECSTR:	.byte " - FILESPEC:"
001E59  2  49 4C 45 53  
001E5D  2  50 45 43 3A  
001E61  2  00           		.byte 0
001E62  2  45 52 52 4F  ERRSTR:		.byte "ERROR: "
001E66  2  52 3A 20     
001E69  2  00           		.byte 0
001E6A  2  44 3A 2A 2E  DEFSPEC:	.byte DRVCHAR, ":*.*"
001E6E  2  2A           
001E6F  2  9B           		.byte EOL
001E70  2               
001E70  2  20 2D 20 46  FROMSTR:	.byte " - FROM:",0
001E74  2  52 4F 4D 3A  
001E78  2  00           
001E79  2  20 20 20 20  TOSTR:		.byte "      TO:",0
001E7D  2  20 20 54 4F  
001E81  2  3A 00        
001E83  2  20 20 20 20  INTOSTR:	.byte "    INTO:",0
001E87  2  49 4E 54 4F  
001E8B  2  3A 00        
001E8D  2  20 20 41 50  APPENDSTR:	.byte "  APPEND:",0
001E91  2  50 45 4E 44  
001E95  2  3A 00        
001E97  2  20 2D 20 41  GOTOSTR:	.byte " - ADDRESS:"
001E9B  2  44 44 52 45  
001E9F  2  53 53 3A     
001EA2  2  00           		.byte 0
001EA3  2               
001EA3  2  4B 3A 9B     KBDNAME:	.byte	"K:",EOL
001EA6  2               DUPEND		=	*
001EA6  2               
001EA6  1               	.ENDIF
001EA6  1               
