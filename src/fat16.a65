DEBUG .set 0

.macro	cmp_icbalz_y
	.IF PLATFORM=0
		CMP [ICBALZ],Y
	.ELSE
		CMP (ICBALZ),Y
	.ENDIF
.endmacro

.macro	lda_icbalz_y
	.IF PLATFORM=0
		LDA [ICBALZ],Y
	.ELSE
		LDA (ICBALZ),Y
	.ENDIF
.endmacro

.macro	sta_icbalz_y
	.IF PLATFORM=0
		STA [ICBALZ],Y
	.ELSE
		STA (ICBALZ),Y
	.ENDIF
.endmacro

	.IF PLATFORM = 2 || PLATFORM = 4
		.include "atarixl.inc"
		.include "fat16.inc"

EPB	=	$E406		;putbyte

		.ORG FATCODE
	.ENDIF
	
	.IF PLATFORM = 2
		JMP STARTUP	;0
		JMP PRINT	;3
		JMP PUTHEX	;6
		JMP PRINTSTR	;9
		JMP INITFAT
	.ENDIF
	
;-------------------------------------------------------------------------------
; set DOSINI to reset-proof DOS-Initialisation-Vector
; Set DOSVEC to DUP-code
; register D: handler
; set MEMLO for Basic 
;-------------------------------------------------------------------------------
STARTUP:
	.IF PLATFORM = 2 || PLATFORM = 4
		LDA #<INIT
		STA DOSINI
		LDA #>INIT
		STA DOSINI+1
	
	.IF PLATFORM = 4
		LDA #<DUPINIT
		STA DOSVEC
		LDA #>DUPINIT
		STA DOSVEC+1
		
		LDA #<DUPEND
		STA MEMLO
		LDA #>DUPEND
		STA MEMLO+1
	.ELSE
		LDA #<DUPCODE
		STA DOSVEC
		LDA #>DUPCODE
		STA DOSVEC+1
		
		LDA #<$2100
		STA MEMLO
		LDA #>$2100
		STA MEMLO+1
	.ENDIF
	
	
;		LDA #25		; ATMAS-II patches		
;		STA $329F
;		STA $32BF
;		LDA #'B'
;		STA $2A11

INIT:		LDY #<HANDTAB
		LDA #>HANDTAB
		LDX #DRVCHAR
		JSR PHENTV				;init D: Device (not available on ATARI 400/800)
	
		
	.ELSE
;		ldx #0
;HAFIND:		lda HATABS,x
;		beq HAFOUND
;		cmp #DRVCHAR
;		beq HAFOUND
;		inx
;		inx
;		inx
;		cpx #MAXDEV
;		bcc HAFIND
;		rts
;HAFOUND:	lda #DRVCHAR
;		sta HATABS,x
;		lda #<HANDTAB
;		sta HATABS+1,x
;		lda #>HANDTAB
;		sta HATABS+2,x
	.ENDIF
		JSR INITFAT

;TEST:		lda	#0
;		ldx	#2
;		jsr	STAXCCLUS
;TEST1:		jsr	LOAXCCLUS
;		jsr	COMPFAT12
;		lda	SECTOR
;		jsr	PUTHEX
;		jsr	SPACE
;		
;		jsr	LOAXCCLUS
;		jsr	PUTHEX
;		txa
;		jsr	PUTHEX
;		jsr	SPACE
;		
;		lda	FATPTRS+1
;		jsr	PUTHEX
;		lda	FATPTRS
;		jsr	PUTHEX
;		jsr	NEWLINE
;		
;		inc	FCURCLUS
;		bne	TEST1
;		inc	FCURCLUS+1
;		bne	TEST1
		rts
		
;-------------------------------------------------------------------------------
; D: Handler-Table
; Open, Close, Get Put, Status, Special, Init
;-------------------------------------------------------------------------------		
HANDTAB:	.word OPENCHA-1		; open channel
		.word CLOSECHA-1	; close channel
		.word GETCHA-1		; get channel
		.word PUTCHA-1		; put channel
		.word STATUSCHA-1	; status of channel
		.word SPECIAL-1         ; other XIO cmds
		rts
		
STATUSCHA       = OK

;-------------------------------------------------------------------------------
; Handler routine Open-Channel
; opens a FCB file control block for IO
; checks if file or directory to be read
; open file/dir checks if file exists, mustt be updated etc.
;-------------------------------------------------------------------------------
OPENCHA:	JSR OPENFCB
		BMI OPENERR
		JSR CHECKHAN
		BMI OPENERR
		
		LDA ICAX1Z				;check if Open Directory is meant
		AND #6
		CMP #6
		BNE OPENFILE				;OPENFILE OR OPENDI (fall through)

;-------------------------------------------------------------------------------
; open a directory
;-------------------------------------------------------------------------------
OPENDI:		;JSR INITLSEC
		LDA #0
        	STA HILF
		JMP GETFILE				;DIRSTART = 0

;-------------------------------------------------------------------------------
; open a file
;-------------------------------------------------------------------------------
OPENFILE:	LDA #1					;FILE THERE?
		JSR GETFILE			
		BPL OPENEXIS				;YES
			
OPENNEW:	LDA ICAX1Z				;WRITE FILE without R/W or APPEND?
		AND #1+4+8				;
		CMP #8					;only WRITE active
		BEQ OPENNEW3				;yes
OPEN170:	JSR CLOSEFCB
		LDY #170
OPENERR:	RTS

OPENNEW3:	JSR VALIDNAM
		BPL OPENNEW4	
		JMP ERR165

OPENNEW4:	JSR INITDIR

OPENEXIS:	LDA FATPTRS				;remember directory position, FATPTRS...
		STA DIRPTR
		LDA FATPTRS+1
		STA DIRPTR+1

		LDX #3					; ... and SECTOR
SAVEDIR1:	LDA SECTOR,X
		STA DIRSEC,X
		DEX
		BPL SAVEDIR1

		LDX #5					;GET START
		LDY #DCLUS+5				;CLUSTER
OPENF1:		LDA (FATPTRS),Y				;AND FILELEN
		STA FSTRTCL,X				;FROM
		DEY					;DIRENTRY
		DEX			
		BPL OPENF1			
				
		LDA ICAX1Z				;IF READ
		AND #4					;FINISHED
		BNE OPENEND
	
		LDA ICAX1Z				;WRITE + APPEND?
		AND #1		
		BNE OPENAPPND				;YES
	
OPENWRIT:	jsr LOAXSCLUS				;LOAD AX with file start cluster
		jsr FREECLUS				;free all cluster associated with file
		jsr STENDNCLUS				;store FATEND to NEWCLUS
		jsr LOAXSCLUS
		jsr PUTCLUST
		
		LDA #0					;clear FILELEN
		LDX #3
OPENW4:		STA FILELEN,X
		DEX
		BPL OPENW4
	
OPENAPPND:	LDX #3					;
OPENF3:		LDA FILELEN,X				;copy filelen
		STA FRPOS,X				;to file-read-pos
		DEX
		BPL OPENF3	
		
OPENEND:	JMP FSEEK				;seek to FRPOS (either 0 or FILELEN)

;-------------------------------------------------------------------------------
; Handler routine Close-Channel
;-------------------------------------------------------------------------------
CLOSECHA:	JSR SETFCB

		LDA ICAX1Z
		AND #8
		BEQ CLOSE5				;just close FCB if read access

		JSR WRITEFAT
	
		LDX #3					;otherwise update directory 
CLOSE3:		LDA DIRSEC,X				;with file-length
		STA SECTOR,X
		DEX
		BPL CLOSE3
		JSR READSEC
	
		LDA DIRPTR
		STA FATPTRD
		LDA DIRPTR+1
		STA FATPTRD+1
	
		LDY #DLEN+3
		STY DDIRTY
		LDX #3
CLOSE4:		LDA FILELEN,X
		STA (FATPTRD),Y
		DEY
		DEX
		BPL CLOSE4
	
		JMP DELETE8
	
CLOSE5:		JMP DELETE9

;-------------------------------------------------------------------------------
; Handler routine GET-Channel
;-------------------------------------------------------------------------------
GETCHA:		JSR SETFCB
		lda ICAX1Z
		AND #2
		BEQ READBYTE				;if Bit 2 is clear, file access

;-------------------------------------------------------------------------------
; Handler routine GET-Channel directory access
;-------------------------------------------------------------------------------
GETDIR:		LDY HILF				;each call to GETDIR return just one byte
		BPL GETDIR6				;HILF counts the bytes in one dir entry
		LDY #EOF				;HILF initialised to zero in OPENDI
		RTS

GETDIR6:	BNE GETDIR1				; Y > 0, get next byte of dirname
		
		LDA #32					; Y==0, init DIRLINE
		STA DIRLINE+8		
		STA DIRLENG-1		
		LDA #EOL		
		STA DIREOF		
			
		LDX #0					; copy DIR-info
GETDIR3:	LDA (FATPTRS),Y				; from sector-buffer
		STA DIRLINE,X				; into DIRLINE
		INX		
		INY		
		CPY #8					; 8.3 jump over " "
		BNE GETDIR3A
		INX
		
GETDIR3A:	CPY #11
		BNE GETDIR3
	
		LDY #DATTRIB
		LDA (FATPTRS),Y
		LDY #9
		AND #16					;ist directory?
		BEQ GETDLEN				;no, get file length
		
GETDTXT:	LDA DIRTXT,Y				;write "DIR" into
		STA DIRLENG,Y				;output length
		DEY					;pos 9 downto 0
		BPL GETDTXT		
		BMI GETDIR5		
		
GETDLEN:	LDA DECIMAL,Y		
		STA DIRLENG,Y		
		DEY		
		BPL GETDLEN		
		
GETDIR5:	LDY #0		
		
GETDIR1:	INC HILF		
		LDA DIRLINE,Y				;if Y points to end in DIRLINE
		CMP #EOL				;read next dir entry
		BNE GETDIR7
		
		JSR NEXTFILE
		BMI GETDIR9
		
		LDY #0
		STY HILF
	
		LDA (FATPTRS),Y
		BNE GETDIR8

GETDIR9:	DEY
		STY HILF				;NEG.

GETDIR8:	LDA #EOL

GETDIR7:	
	.IF PLATFORM > 0
		CMP #$7E				; "~" in "-"
		BNE GETDIR2
		LDA #'-'
	.ENDIF
GETDIR2:	LDY #1
		RTS	

;		      "0123456789"
DIRTXT:		.byte "       DIR"
;

;-------------------------------------------------------------------------------
; Handler routine GET-Channel file access
; check if we can read an entire sector directly into destination buffer
; if not do a single-byte read
;-------------------------------------------------------------------------------
READBYTE:	JSR CHECKLEN				;still bytes to read available
		BCC READBYT1
		LDY #EOF
		RTS
		
READBYT1:	LDY FATPTRS				;FATPTRS must point to begin of buffer, check LO-byte=0
		BNE READSLOW				;no
			
		LDA ICBLHZ				;still >= 512 bytes to be read?
		CMP #2			
		BCC READSLOW				;no		
		LDA ICCOMZ				;only GETCHAR allowed, not GETREC
		CMP #GETCHR			
		BNE READSLOW			
		LDA FATPTRS+1			
		CMP #>BUFFER				;FATPTRS must point to begin of buffer
		BNE READSLOW			
					
;		SEC					;carry set from prev. CMP, still more than 512 bytes in the files available?
		LDA FILELEN				;filelen can't be greater then 64k (not true!! TODO!)
		SBC FRPOS
		LDA FILELEN+1
		SBC FRPOS+1
		CMP #2
		BCC READSLOW

;		JSR IODUMP

;-------------------------------------------------------------------------------
; copy Buffer to destination and read next one
;-------------------------------------------------------------------------------
READFAST:	LDA BUFFER,Y				;buffer must be page aligned, Y = 0 from above
		sta_icbalz_y
		DEY
		BNE READFAST
		INC ICBAHZ				;increase destination page
	.IF PLATFORM=0
		bne READFA1
		inc ICBABZ
	.ENDIF	
READFA1:	LDA BUFFER+$100,Y
		sta_icbalz_y
		INY
		BNE READFA1

		STA CIOCHR
		INC ICBAHZ				;increase destination page
	.IF PLATFORM=0
		bne READFA3A
		inc ICBABZ
	.ENDIF	
	
READFA3A:
	.IF PLATFORM=0
		lda ICBLHZ
		bne READFA3B
		dec ICBLBZ
READFA3B:	dec ICBLHZ
		bne READFA3C
		dec ICBLBZ
READFA3C:	dec ICBLHZ
	.ELSE
		DEC ICBLHZ				;decrease bytes to read by 512
		DEC ICBLHZ
	.ENDIF
		JSR INCRPOS512				;increase FRPOS by 512

		JSR INCSEC				;read next sector/cluster

		LDA ICBLHZ				;no more to be read?
		ORA ICBLLZ
	.IF PLATFORM=0
		ora ICBLBZ
	.ENDIF
		bne READBYTE
		
;		BEQ READFA4
;		JMP READBYTE
			
READFA4:	INC ICBLLZ				;set buffer length to 1					
		LDA ICBALZ				;decrement buffer address
		BNE READFA5				;since CIO routine always expects one byte
		
	.IF PLATFORM=0
		lda ICBAHZ
		bne READFA6
		dec ICBABZ
	.ENDIF
	
READFA6:	DEC ICBAHZ
READFA5:	DEC ICBALZ
		LDA CIOCHR
		JMP READBYT5				;exit success, Y=1

;-------------------------------------------------------------------------------
; Handler routine GET-Channel file access, read single byte
;-------------------------------------------------------------------------------
READSLOW:	LDY #0
		LDA (FATPTRS),Y
		STA CIOCHR

		JSR INCRPOS
		JSR INCPTR
		BMI READBYT2

		LDA CIOCHR
READBYT5:	LDY #1
READBYT2:	RTS

;-------------------------------------------------------------------------------
; Handler routine PUT-Channel file access
;-------------------------------------------------------------------------------
PUTCHA:		STA CIOCHR				; save byte, could have been called via ICPTLZ
			
		JSR SETFCB			
			
		LDA ICAX1Z				;also READ => UPDATE?
		AND #4					;ceck filelen
		BEQ PUTCHA1				;no
			
PUTUPD:		JSR CHECKLEN				;file-pos less than filelen
		BCC PUTSLOW1				;yes, continue slow
PUTUPD1:	LDY #EOF				;signal error
		RTS			
					
PUTCHA1:	LDY FATPTRS				;points to begin of page?
		BNE PUTSLOW			
		LDA ICBLHZ				;at least 512 bytes To write?
		CMP #2			
		BCC PUTSLOW			
		LDA FATPTRS+1				;points to begin of buffer?
		CMP #>BUFFER			
		BNE PUTSLOW			
		LDA ICCOMZ				;binary put?
		CMP #PUTCHR
		BNE PUTSLOW

;-------------------------------------------------------------------------------
; Handler routine PUT-Channel file access, put entire sector
;-------------------------------------------------------------------------------
PUTFAST:	INC FWBURST
		;LDY #0					;Y zero from above
PUTFAST1:	lda_icbalz_y
		STA BUFFER,Y
		INY
		BNE PUTFAST1
		INC ICBAHZ
PUTFAST2:	lda_icbalz_y
		STA BUFFER+$100,Y
		INY
		BNE PUTFAST2
		
		INY
		STY DDIRTY				;mark as dirty
		
		JSR INCRPOS512
		
		JSR INCFILELE2
		JSR INCFILELE2
		
		SEC
		LDA ICBLLZ
		SBC #$FF
		STA ICBLLZ
		LDA ICBLHZ
		SBC #1
		STA ICBLHZ
	.IF PLATFORM=0
		lda ICBLBZ
		sbc #0
		sta ICBLBZ
	.ENDIF
	
		CLC
		LDA ICBALZ
		ADC #$FF
		STA ICBALZ
		BCC PUTFAST3
		INC ICBAHZ
	.IF PLATFORM=0
		bne PUTFAST3
		inc ICBABZ
	.ENDIF

PUTFAST3:	JMP INCSEC	


;-------------------------------------------------------------------------------
; 1-byte PUT routine if not a whole sector is to be written
;-------------------------------------------------------------------------------
PUTSLOW:	JSR INCFILELEN
PUTSLOW1:	LDA CIOCHR
		LDY #0
		STA (FATPTRS),Y
		INY
		STY DDIRTY
		
		JSR INCRPOS
		JMP INCPTR

;-------------------------------------------------------------------------------
; SPACIAL Handler routine dispatcher
;-------------------------------------------------------------------------------	
SPECIAL:	TSX
                STX STACKP
                
                jsr CHECKHAN				;position to ':'
		bmi SPECIAL3
		
		LDA ICCOMZ				;search for command in table
		LDX #(XFUNCEND-XFUNC)
SPECIAL2:	CMP XFUNC,X
		BEQ SPECIAL1
		DEX
		BPL SPECIAL2
		LDY #132				;command not found
		RTS

SPECIAL1:       LDA XJMPTABH,X				;jump to special-function
		PHA
		LDA XJMPTABL,X
		PHA
SPECIAL3:	RTS

XFUNC:		.byte CDELETE
		.byte CCHADIR
		.byte CRENAME
		.byte CCREDIR
XFUNCEND:	.byte CCREDIR1

	
XJMPTABH:	.byte >(DELETE-1)
		.byte >(CHADIR-1)
		.byte >(RENAME-1)
		.byte >(CREDIR-1)
		.byte >(CREDIR-1)

XJMPTABL:	.byte <(DELETE-1)
		.byte <(CHADIR-1)
		.byte <(RENAME-1)
		.byte <(CREDIR-1)
		.byte <(CREDIR-1)	
		
;-------------------------------------------------------------------------------
; SPECIAL-handler for DELETE file
; todo: directory
;-------------------------------------------------------------------------------
DELETE:		LDA #1					;does file exist?
		JSR GETFILE
		BMI DELETE9				;no or other error, return OK

DELETE2:	LDA FATPTRS				;save pointer into directory
		PHA
		LDA FATPTRS+1
		PHA
	
		LDY #DCLUS				;LOAD AX with first cluster
		LDA (FATPTRS),Y
		TAX
		INY
		LDA (FATPTRS),Y
	
		JSR FREECLUS				;free all cluster
	
		PLA
		STA FATPTRS+1
		PLA
		STA FATPTRS
	
		LDY #DNAME
		LDA #$E5
		STA (FATPTRS),Y
		STA DDIRTY
	
		JSR NEXTFILE
		BPL DELETE2
	
DELETE7:	JSR WRITEFAT
DELETE8:	JSR WRITESEC
DELETE9:	JSR CLOSEFCB
OK:		LDY #1
		CLC
NOTOK:		RTS

;-------------------------------------------------------------------------------
; SPECIAL-handler for CHANGE Directory
;-------------------------------------------------------------------------------
CHADIR:		LDY SAVEY
CHADIR2:	lda_icbalz_y				;is '/' access from ROOT?
		cmp #'/'		
		bne CHADIR3				;no
				
		lda #0					;set DIRCLUS to 0
		sta DIRCLUS		
		sta DIRCLUS+1
		beq CHADIR2				;read next char
		
CHADIR3:	cmp #EOL				;end of filename?
		beq DELETE9				;yes, exit OK
				
CHADIR3C:	lda #3					;read only dirs
		jsr DIRSTART				;copy DIRCLUS to FSTRTCL
		jsr STR2RAW				;generate matching string		
		dey
		sty SAVEY
		
		jsr OPENDIR				;find first directory		
		bcs CHADIR170				;not found
CHADIR3A:	jsr FINDFIL1				;loop until matching dir found
		bmi CHADIR170				;no

CHADIR1:	ldy #DCLUS				;get DIRCLUS from found directory
		lda (FATPTRS),Y
		sta DIRCLUS
		iny
		lda (FATPTRS),Y
		sta DIRCLUS+1
		
CHADIR4:	ldy SAVEY				;go over '/' and change directory again
CHADIR5:	lda_icbalz_y
		cmp #'/'
		bne CHADIR3
		iny
		bne CHADIR5
		
CHADIR170:	jmp OPEN170

;-------------------------------------------------------------------------------
; SPECIAL-handler for RENAME (file / directory)
;-------------------------------------------------------------------------------
RENAME:		ldy SAVEY
RENAME2:	lda_icbalz_y
		CMP #','
		BEQ RENAME1	;FOUND
		CMP #EOL
		BEQ RENAME8
		INY
		BNE RENAME2
RENAME8:	JMP ERR165

RENAME1:	lda #EOL				;',' -> eol
		sta_icbalz_y
		
		INY
		JSR STR2RAW				;convert target string in 8+3

		INC VALIDS
		JSR VALIDNAM
		PHP
		DEC VALIDS
		PLP	
		BMI RENAME8

RENAME4:	LDX #10					;save string in DIRRENA
RENAME3:	LDA DIRTEXT,X
		STA DIRRENA,X
		DEX
		BPL RENAME3

		LDY #0					;convert search string
		jsr STR2RAW
		
		LDA #0
		JSR GETFILE
		BMI RENAME9
		
RENAME7:	LDY #10
		STY DDIRTY
RENAME6:	LDA DIRRENA,Y
		CMP #'?'
		BEQ RENAME5
		STA (FATPTRS),Y
RENAME5:	DEY
		BPL RENAME6

		JSR NEXTFILE
		BPL RENAME7

RENAME9:	JMP DELETE8

;-------------------------------------------------------------------------------
; SPECIAL-handler for CREDIR (create directory)
;-------------------------------------------------------------------------------
CREDIR:		LDA #3
		JSR GETFILE
		BMI CREDIR1				;directory must not exist
		JMP OPEN170

CREDIR1:	JSR VALIDNAM
		BPL CREDIR3
		JMP ERR165

CREDIR3:	LDA #8					;get a free entry and initialize it
		STA ICAX1Z
		JSR INITDIR				;FCURCLUS holds cluster of new directory
	
		LDY #DATTRIB
		LDA #16					;set attribute directory
		STA (FATPTRS),Y
	
		JSR CLRCLUST
		JSR CLU2SEC				
		JSR READSEC
			
		LDX #10
		LDA #32
CREDIR6:	STA BUFFER,X
		STA BUFFER+32,X
		DEX
		BPL CREDIR6
	
		LDA #'.'
		STA BUFFER
		STA BUFFER+32
		STA BUFFER+33
	
		LDA #16
		STA BUFFER+DATTRIB
		STA BUFFER+DATTRIB+32
	
		LDA FCURCLUS
		STA BUFFER+DCLUS
		LDA FCURCLUS+1
		STA BUFFER+DCLUS+1
	
		LDA DIRCLUS
		STA BUFFER+DCLUS+32
		LDA DIRCLUS+1
		STA BUFFER+DCLUS+33

CREDIR4:	JMP DELETE7				;WRITESEC/FAT, CLOSEFCB
	
;
;FSTAT:		;JSR SETFCB
;;		BPL FSTAT2
;;		RTS
;		
;FSTAT2:		LDY #5
;		LDX #3
;FSTAT1:		LDA FILELEN,X
;		sta_icbalz_y
;		DEY
;		DEX
;		BPL FSTAT1
;		JMP OK
	
;-------------------------------------------------------------------------------
; Check if second or third character is ":"
; return Err165 (Bad file name / file name error) if not
;-------------------------------------------------------------------------------
CHECKHAN:	LDY #1
		LDA #':'
		cmp_icbalz_y
		BEQ CHECKHA1
		INY
		cmp_icbalz_y
		BEQ CHECKHA1
ERR165:		JSR CLOSEFCB
		LDY #164				;iny = 165
CHECKHA1:	iny
		STY SAVEY
		RTS



;-------------------------------------------------------------------------------
;GET FCB Structure 0-3 
;Input 	FCBNO in Y
;Return FCB-offset in X
;-------------------------------------------------------------------------------
GETFCB:		LDX #0
GETFCB0:	TYA
		CMP FCB0,X
		BEQ GETFCB9
		TXA
		CLC
		ADC #64
		TAX
		BNE GETFCB0
		LDY #161		;TOO MANY
		RTS
GETFCB9:	LDY #1
		RTS			;OPEN FILES

;-------------------------------------------------------------------------------
; mark current FCB as unassigned
;-------------------------------------------------------------------------------
CLOSEFCB:	LDX FFCBOFF				;get OFFSET of current FCB		
		LDA #$FF				;switch off copy and original FCB
		STA FIOCBNR
		STA FCB0,X
		RTS
		
;-------------------------------------------------------------------------------
; Find an empty FCB in FCB table, clear it and swap-in
;-------------------------------------------------------------------------------
OPENFCB:        LDY #$FF
                JSR GETFCB                              ;get FREE FCB
                BPL OPENFCB1                            ;no free available
                RTS
                
OPENFCB1:       LDA ICIDNO
                STA FCB0,X                              ;X holds offset to FCB0 from GETFCB

                LDA #0                                  ;CLEAR FCB
                LDY #FCBEND-F-1
OPENFCB0:       STA FCB0+2,X
                INX
                DEY
                BNE OPENFCB0

;-------------------------------------------------------------------------------
; swap-out and swap-in from FCB table to current FCB
;-------------------------------------------------------------------------------
SETFCB:		TSX
                INX
                INX
                STX STACKP
                
                LDA FIOCBNR				;optimisation: current FCB
		CMP ICIDNO				;already active?
		BEQ SETFCB9				;yes, do nothing
		
SWAPFCB:	CMP #$FF				;current FCB unassigned?
		BEQ SWAPIN				;yes, just swapin FCB

SEC2FSEC:	LDX #3					;save SECTOR
SEC2FSE1:	LDA SECTOR,X
		STA FSECTOR,X
		DEX
		BPL SEC2FSE1

PTR2FPTR:	LDA FATPTRS				;and FATPTRS
		STA FCURPTR
		LDA FATPTRS+1
		STA FCURPTR+1

		LDY #0					;copy current FCB to FCB-table
		LDX FFCBOFF
SWAPFCB0:	LDA FIOCBNR,Y
		STA FCB0,X
		INX
		INY
		CPY #FCBEND-F+1
		BNE SWAPFCB0

SWAPIN:		LDY ICIDNO
		JSR GETFCB

		LDY #0
SWAPIN0:	LDA FCB0,X
		STA FIOCBNR,Y
		INX
		INY
		CPY #FCBEND-F+1
		BNE SWAPIN0
	
		LDA ICCOMZ				;if not OPEN command, read current sector
		CMP #OPEN				;of file and set PTR
		BEQ SETFCB9
		
		jsr INCSEC5
		LDA FCURPTR
		STA FATPTRS
		LDA FCURPTR+1
		STA FATPTRS+1
		
SETFCB9:	LDY #1
                RTS

;-------------------------------------------------------------------------------
; COPY FCB FSECTOR to SECTOR and FCURPTR to FATPTRS and read SECTOR
;-------------------------------------------------------------------------------
;FSEC2SEC:	LDX #3					
;FSEC2SE1:	LDA FSECTOR,X
;		STA SECTOR,X
;		DEX
;		BPL FSEC2SE1
;
;		RTS
;		JMP READSEC



;-------------------------------------------------------------------------------
; checks if filename contains only valid characters
; returns N=0 if yes
;-------------------------------------------------------------------------------
VALIDNAM:	LDX #10
VALIDNA1:	LDA DIRTEXT,X				;CARD
		CMP #'0'			
		BCC VALIDNA3				;< 0? => check special chars
		CMP #'9'+1				;<= 9? 
		BCC VALIDNA2				;yes OK, next char
		CMP #'A'				;
		BCC VALIDNA3				;< A? => check special chars
		CMP #'Z'+1				;<= Z?
		BCC VALIDNA2				;yes OK, next char

VALIDNA3:	LDY VALIDS				;check for special chars
VALIDNA4:	CMP VALIDCHA,Y
		BEQ VALIDNA2
		DEY
		BPL VALIDNA4
		RTS					;no valid char found, return N=1

VALIDCHA:	.byte " ~!@#$%&()-_^{}'?"		;usually test without "?", so 16+1 bytes!

VALIDNA2:	DEX
		BPL VALIDNA1	;X=$FF
	
		LDA #32		;check if first char != space
		CMP DIRTEXT
		BEQ VALIDNA9
		
;		CMP DIRTEXT+8
;		BEQ VALIDNA9

		INX		;X=0, make sure N=0		
		RTS
		
VALIDNA9:	DEX		;X=$FE, N=1
		RTS

;-------------------------------------------------------------------------------
; initialize a new directory entry (used by OPEN and CREDIR)
; 1. get a new cluster (next cluster xFFF) for the file or dir
; 2. get a free dir entry
; 3. populate entry
;-------------------------------------------------------------------------------
INITDIR:	LDX #2					;start at cluster #2
		LDA #0
		JSR GETFCLUS				;get a free cluster for dir in NEWCLUS
		jsr LOAXNCLUS                           ;save NEWCLUS
		PHA
		TXA
		PHA
	
		JSR FINDFDIR                            ;get deleted ($E5) or free ($00) entry
		BCS INITDIR1				;free entry found
		
		PLA					;no free dir, pop NEWCLUS and bail out of OPEN 
		PLA
		PLA
		PLA
ERR169:		JSR CLOSEFCB				;todo: Cluster not freed!
		LDY #169
		RTS

INITDIR1:
		LDY #0					;DIRNAME IN
		STY DIRFILE				;RESET DIRFILE = all files
INITDIR2:
		LDA DIRTEXT,Y				;DIR ENTRY
		STA (FATPTRS),Y			
		INY			
		CPY #11			
		BNE INITDIR2			
				
		LDA #0					;INITIALIZE
INITDIR3:	STA (FATPTRS),Y				;REST
		INY			
		CPY #32			
		BNE INITDIR3			
				
		STY DDIRTY				;PUT START
		LDY #DCLUS				;CLUSTER
		PLA					;INTO
		STA FCURCLUS			
		STA (FATPTRS),Y				;DIR ENTRY
		INY
		PLA
		STA FCURCLUS+1
		STA (FATPTRS),Y	
		RTS

;-------------------------------------------------------------------------------
; converts given filename-pattern into DIRTEXT 8+3 chars
;-------------------------------------------------------------------------------
STR2RAW:	LDX #11			;fill DIRTEXT
		LDA #32			;with spaces
S2R12:		STA DIRTEXT-1,X
		DEX
		bne S2R12
					
		STX WILD		;x = 0

		LDA #'.'
		cmp_icbalz_y		;first char '.' (local dir)?
;		CMP (ICBALZ),Y
		BNE S2R1			;no, goto S2R1
		STA DIRTEXT			;save in first char of DIRTEXT
		INY					;examine next input char
		cmp_icbalz_y	
;		CMP (ICBALZ),Y		;also '.'?
		BNE S2R1			;no, goto S2R1
		STA DIRTEXT+1		;save in 2nd char of DIRTEXT
		INY					;Y += 2 ?
		INY
		RTS					;return

S2R1:		JSR S2R4		;call S2R4 until 8 chars processed
		BCS S2R2
		CPX #8
		BNE S2R1
S2R2:		CMP #EOL
		BEQ S2R6
		CMP #'/'
		BEQ S2R6
		LDX #8
		LDA #0
		STA WILD
S2R5:		JSR S2R4
		BCS S2R6
		CPX #11
		BNE S2R5
S2R6:		RTS

S2R4:		lda_icbalz_y
;		LDA (ICBALZ),Y
;		JSR PRINT
		BIT WILD		;wildcard active?
		BMI S2R7		;yes => S2R7
		
		INY
		CMP #'*'
		BNE S2R8
		DEC WILD
		BMI S2R7
S2R8:		CMP #'.'
		BNE S2R11
		CPX #8
		BCC S2R3
		CLC
		RTS
S2R11:		CMP #32			;is space?
		BEQ S2R3		;yes => next
		CMP #EOL
		BEQ S2R3
		CMP #'/'
		BEQ S2R3
		CMP #0
		BEQ S2R3
		BNE S2R9
S2R7:		LDA #'?'	
S2R9:		CMP #'a'
		BCC S2R10
		CMP #'z'+1
		BCS S2R10
		SBC #31
S2R10:		STA DIRTEXT,X		;normal character
		INX
		CLC
		RTS
S2R3:		INX
		SEC
		RTS
	
;IODUMP:		LDX ICIDNO
;		LDY #0
;IODUMP1:	LDA IOCB,X
;		JSR PUTHEX
;		INX
;		INY
;		CPY #16
;		BNE IODUMP1
;		LDA #$9B
;		JSR PRINT
;		LDY #EOF
;		RTS

;-------------------------------------------------------------------------------
; Traverse directory and check if filename matches
; 0=ALL, 1=FILES, 2=FREE DIR, 3=DIR
;-------------------------------------------------------------------------------
GETFILE:	jsr DIRSTART				;initialise DIRFILE, FSTRTCL from DIRCLUST
		ldy SAVEY				;Y = 2 or 3 from CHECKHAN 
		jsr STR2RAW				;convert to 11 chars including * to ?
		jsr OPENDIR				;position to first directory entry	
		
FINDFIL1:	ldy #10
FINDFIL3:	lda DIRTEXT,Y
		cmp #'?'				;matches any character
		beq FINDFIL2
		cmp (FATPTRS),Y				;matches character in directory?
		beq FINDFIL2

NEXTFILE:	jsr NEXTDIR				;if not, get next directory entry
		bcc FINDFIL1				;check again
		ldy #170				;no further entry, return EOF
		rts

FINDFIL2:	dey
		bpl FINDFIL3
		ldy #1
FINDFILEND:	rts

;-------------------------------------------------------------------------------
; Find free directory entry starting from DIRCLUS
;-------------------------------------------------------------------------------
FINDFDIR:	LDA #2
		JSR DIRSTART				;fall through to OPENDIR

;-------------------------------------------------------------------------------
; Positions directory-cursor to first entry that matches DIRTEXT via CHECKDIR
; (file/dir or both) or first empty dir
;-------------------------------------------------------------------------------
OPENDIR:	jsr LOAXSCLUS                           ;Start cluster zero, then root Dir
		bne OPENDIR1				;X (FSTRTCL) not zero
		tay					;test A (FSTRTCL+1)
		bne OPENDIR1
		
		JSR CROOT
		JMP CHECKDIR				;loop until first suitable entry is found

OPENDIR1:	jsr INCSEC4                             ;store AX, cluster2sec, reset ptr and readsec
		JMP CHECKDIR


;-------------------------------------------------------------------------------
; positions to next available dir entry via READDIR and CHECKDIR
;-------------------------------------------------------------------------------
NEXTDIR:	jsr READDIR
		bcs NEXTDIR9				;No further Dir, RTS
			
CHECKDIR:	;jsr DUMPSEC
		ldx DIRFILE			

		ldy #DNAME				;check first char of entry-name
		lda (FATPTRS),Y		
		cmp #DEL				;or entry deleted?
		bne NEXTDIR2				;no
		
		cpx #2					;looking for free dir?
		bne NEXTDIR				;no, loop
CHECKDIR1:	;sec					;yes, end C=1, set by cpx and cmp
		rts			
			
NEXTDIR2:	cpx #2					;not empty and looking for free dir?
		beq NEXTDIR				;yes, loop
		
		ldy #DATTRIB			
		lda (FATPTRS),Y				;SKIP
		and #8					;VOLUME
		bne NEXTDIR				;LABEL

		txa					;DIRFILE = 0?
		beq NEXTDIR3				;file/dir found
		
		lda (FATPTRS),Y				;DIR?
		and #16			
		cpx #3
		bne NEXTDIR4				;we are looking for files
		tax					;we are looking for dirs
		bne NEXTDIR3				;dir found
		beq NEXTDIR				;oherwise loop
		
NEXTDIR4:	tax					;looking for files, but dir found
		bne NEXTDIR

NEXTDIR3:	ldy #DLEN+3				;copy 4-byte file length to bin
NEXTDIR1:	lda (FATPTRS),Y
		sta BIN-DLEN,Y
		dey
		cpy #DLEN
		bcs NEXTDIR1

		jsr BIN2DEC				;and convert to decimal	
		clc
NEXTDIR9:	rts


;-------------------------------------------------------------------------------
; adds 32 to the current position of PTR in directory sector
; check FSTARTCL if root directory or not
; read next sector/cluster required
; return C = 1 if end of dir-cluster or zero-entry reached
;
; todo: 
;-------------------------------------------------------------------------------
READDIR:        LDY #DNAME
		LDA (FATPTRS),Y
		BEQ READDIR3                            ;if zero: end of dirs reached

        	CLC
		LDA FATPTRS
		ADC #32
		STA FATPTRS
		LDA FATPTRS+1
		ADC #0
		STA FATPTRS+1		
		CMP #(>BUFFER)+2
		BNE READDIR2		                ;OK => CLC,RTS

		LDA FSTRTCL                             ;if root dir, inc sector
		ORA FSTRTCL+1
		bne READDIR1
	
		JSR INCSEC7                             ;root dir, inc sector, reset ptr, readsec
READDIR2:	CLC
		RTS
		
READDIR1:	JSR INCSEC                              ;inc sector/cluster etc.
		LDA #>FATEND
		CMP FCURCLUS+1
		BNE READDIR2
		LDA #<FATEND
		CMP FCURCLUS
		BNE READDIR2
		
READDIR3:	SEC
		RTS

;-------------------------------------------------------------------------------
; position to start of root-directory
; SECTOR = DIRBASE, FSTRTCL = 0
;-------------------------------------------------------------------------------
CROOT:		LDX #4
CROOT1:		LDA DIRBASE-1,X
		STA SECTOR-1,X
		DEX
		bne CROOT1

;		STX FSTRTCL				;X = 0
;		STX FSTRTCL+1
CROOT2:         JMP INCSEC6                             ;reset ptr, readsec

;-------------------------------------------------------------------------------
; save A in DIRFILE function code)
; copy DIRCLUS to FSTARTCL
; 
; DIRFILE	0=ALL, 1=FILES, 2=FREE DIR, 3=DIR
;-------------------------------------------------------------------------------
DIRSTART:	STA DIRFILE
		LDA DIRCLUS
		STA FSTRTCL
		LDA DIRCLUS+1
		STA FSTRTCL+1
		RTS
		
CHECKLEN:
;		LDX #3
;CL1:		LDA FRPOS,X
;		JSR PUTHEX
;		DEX	
;		BPL CL1
;		LDA #EOL
;		JSR PRINT

		LDX #3
CHECKL2:	LDA FRPOS,X
		CMP FILELEN,X
		BCC CHECKL1
		DEX
		BPL CHECKL2
CHECKL1:	RTS

;-------------------------------------------------------------------------------
; increments 4-byte FILELEN
;-------------------------------------------------------------------------------
INCFILELEN:	INC FILELEN
		BNE INCFILELEX
INCFILELE2:	INC FILELEN+1
		BNE INCFILELEX
		INC FILELEN+2
		BNE INCFILELEX
		INC FILELEN+3
INCFILELEX:	RTS


;-------------------------------------------------------------------------------
; increments 4-byte FRPOS
;-------------------------------------------------------------------------------
INCRPOS:	INC FRPOS
		BEQ INCRPOS2
		rts
		
;-------------------------------------------------------------------------------
; adds 512 to FRPOS 
;-------------------------------------------------------------------------------
INCRPOS512:	JSR INCRPOS2	
INCRPOS2:	INC FRPOS+1
		BNE INCRPOS1
		INC FRPOS+2
		BNE INCRPOS1
		INC FRPOS+3
INCRPOS1:	RTS

;-------------------------------------------------------------------------------
; increments 4-byte SECTOR
;-------------------------------------------------------------------------------
INCSECTO:	ldx #0
INCSECTO2:	inc SECTOR,x
		bne INCSECT1
		inx
		cpx #4
		bne INCSECTO2
INCSECT1:	rts


;-------------------------------------------------------------------------------
; increments file read-pointer
; - reads next sector if at end of read-buffer
; - reads next cluster if end of sectors per cluster
;-------------------------------------------------------------------------------
INCPTR:		INC FATPTRS				;increment buffer-pointer
		BNE INCPTROK				;if not >= Buffer+$200
		INC FATPTRS+1				;nothing else to do
		LDA FATPTRS+1
		CMP #(>BUFFER)+2
		BNE INCPTROK
;
; READ NEXT SECTOR
;
INCSEC:		INC FCURSEC				;otherwise point to next sector
		LDA FCURSEC
		CMP SECCLUS
		BEQ INCSEC3				;new cluster necessary!
				
INCSEC7:	JSR INCSECTO				;just increment sector
		BEQ INCSEC6				;jmp always, reset buffer-ptr and read-sector

;
; READ NEXT CLUSTER
;
INCSEC3:	LDA #0					;reset current sector in file
		STA FCURSEC

		JSR GETNEXTC			        ;get next cluster in AX
		
		CMP #>FATEND				;FAT End marker $xFF0
		BNE INCSEC4
		CPX #<FATEND
		BNE INCSEC4				;not end of clusters
	
		LDA ICAX1Z				;WRITE ACCESS?
		AND #8
		BNE INCSEC1				;yes, acquire new cluster
INCPTROK:	LDY #1					;exit OK
INCPTREX:	RTS
								
INCSEC1:	JSR CHAINCLU				;add a new cluster

		LDA DIRFILE				;Skip if not 
		CMP #2					;GET FREE DIR
		BNE INCSEC5				;
	
		JSR CLRCLUST				;otherwise clear sectors in new cluster
		BEQ INCSEC5				;skip store AX in FCURCLUS
		
INCSEC4:	JSR STAXCCLUS
INCSEC5:	JSR CLU2SEC				;compute sector
INCSEC6:	LDA #<BUFFER				;reset buffer pointer
		STA FATPTRS
		LDA #>BUFFER
		STA FATPTRS+1
		JMP READSEC				;read sector

;-------------------------------------------------------------------------------
; clear data buffer
;-------------------------------------------------------------------------------
CLEARBUF:	LDA #0
		TAX
CLEARBU1:	STA BUFFER,X
		STA BUFFER+$100,X
		INX
		BNE CLEARBU1
		INC DDIRTY				;mark dirty	
		RTS

;-------------------------------------------------------------------------------
; clear cluster
;-------------------------------------------------------------------------------
CLRCLUST:	lda #0
		sta FCURSEC
		jsr CLU2SEC
		
		LDA SECCLUS
		STA FCURSEC

CLRCLUST1:	JSR READSEC
		JSR CLEARBUF	
		JSR INCSECTO
		
		DEC FCURSEC
		BNE CLRCLUST1				;loop FCURSEC times	
		rts

;-------------------------------------------------------------------------------
;
;-------------------------------------------------------------------------------
FSEEK:		LDA FSTRTCL
		STA FCURCLUS
		LDA FSTRTCL+1
		STA FCURCLUS+1
	
		LDX #3
FSEEK2:		LDA FRPOS,X
		STA FVAR32,X
		DEX
		BPL FSEEK2
	
FSEEK1:		LDA #<FVAR32
		STA FATPTRD
		LDA #>FVAR32
		STA FATPTRD+1
		LDA #<BYTCLUS
		STA FATPTRS
		LDA #>BYTCLUS
		STA FATPTRS+1
	
		JSR CMP32	; FATPTRD < FATPTRS?
		BCC FSEEKS	; ja
	
		JSR SBC32
	
		JSR GETNEXTC
		
		CMP #>FATEND
		BNE FSEEK3
		CPX #<FATEND
		BNE FSEEK3
	
		JSR CHAINCLU
		JMP FSEEK1
	
FSEEK3:		JSR STAXCCLUS
		JMP FSEEK1
		
;
; INSIDE CLUSTER
; SECTOR+OFFSET
;
FSEEKS:		LDA #0
		STA FCURSEC
		JSR CLU2SEC
	
;		jsr DUMPSEC
		
		LDA FVAR32+1
		LSR
		STA FCURSEC
		CLC
		ADC SECTOR+1
		STA SECTOR+1
		BCC FSEEKS1
		INC SECTOR+2
		BNE FSEEKS1
		INC SECTOR+3

;		jsr DUMPSEC

		
FSEEKS1:	LDA FVAR32+1
		AND #1
		CLC
		ADC #>BUFFER
		STA FATPTRS+1
		LDA FVAR32
		STA FATPTRS

;		jsr DUMPSEC
;		JSR SEC2FSEC

		JMP READSEC
;		JSR KBGETC
;		RTS


;-------------------------------------------------------------------------------
; LASTSEC = $FFFFFFFF
;-------------------------------------------------------------------------------
INITLSEC:	LDA #$FF
		LDX #3
INITLSEC1:	STA LASTSEC,X
		DEX
		BPL INITLSEC1
		RTS
	
;-------------------------------------------------------------------------------
; LASTFAT = $FFFFFFFF
;-------------------------------------------------------------------------------
INITFSEC:	LDA #$FF
		LDX #3
INITFSEC1:	STA LASTFAT,X
		DEX
		BPL INITFSEC1
		RTS

;-------------------------------------------------------------------------------
; get stuck if FAT16/12 can't be found
;-------------------------------------------------------------------------------	
DIE:	.IF PLATFORM <= 1
		SEC
		RTS
	.ELSE
		jsr PUTHEX
		lda DSTATS
		jsr PUTHEX
DIE1:		jmp DIE1
	.ENDIF
	
;-------------------------------------------------------------------------------
; Init all variables
; read boot sector
; compute FATBASE, DIRBASE, DATBASE, etc.
;-------------------------------------------------------------------------------
INITFAT:	
		LDA #0					;clear 512-byte of variables
		TAX
VCLEAR:		STA V,X
		STA V+256,X
		DEX
		BNE VCLEAR

;		LDA #0					;initialise offset
VSET2:		TAX					;into FCB
		STA FCB0+1,X				;0, 64, 128, 192
		CLC
		ADC #64
		BNE VSET2

		JSR INITLSEC				;set LASTSEC to $FFFFFFFF
		JSR INITFSEC				;set LASTFAT to $FFFFFFFF

		STA FIOCBNR				;all $FF
		STA FCB0
		STA FCB1
		STA FCB2
		STA FCB3


		LDA #<BUFFER
		STA BUFADRL
		LDA #>BUFFER
		STA BUFADRH
		
		LDA #VALIDNA2-VALIDCHA-2
		STA VALIDS
	
;		LDA #'/
;		STA PATH
	
		JSR READBOOT				;read boot sector
		
	.IF PLATFORM <> 4
		CMP #3
		BNE DIE
	.ELSE
		CMP #2
		BNE DIE
	.ENDIF
		
;		JSR DUMPBUF
		
		LDX #10					;copy 11 important bytes / values
VCOPY:		LDA BUFFER+13,X				;from boot sector
		STA V,X					;to FAT variables
		DEX					;(SECCLUS to SECSFAT)
		BPL VCOPY
	
		LDA SECCLUS				;bytes per cluster as 32-byte word
		ASL
		STA BYTCLUS+1
	
		CLC					;compute FATBASE, DIRBASE
		LDA SECTOR
		ADC RESSEC
		STA FATBASE
		STA DIRBASE
		LDA SECTOR+1
		ADC RESSEC+1
		STA FATBASE+1
		STA DIRBASE+1
		BCC DIRBAS
		INC FATBASE+2
		INC DIRBASE+2
		BNE DIRBAS
		INC FATBASE+3
		INC DIRBASE+3
	
DIRBAS:		CLC
		LDX NUMFATS
DIRBAS2:	LDA DIRBASE
		ADC SECSFAT
		STA DIRBASE
		LDA DIRBASE+1
		ADC SECSFAT+1
		STA DIRBASE+1
		BCC DIRBAS1
		INC DIRBASE+2
		BNE DIRBAS1
		INC DIRBASE+3
DIRBAS1:	DEX
		BNE DIRBAS2
	
;		LDY #<DIRBASE	;COPY DIRBASE
;		LDA #>DIRBASE	;TO SECTOR
;		JSR COPY32
	
		LDA NUMDIR	;#ROOTDIRS
		STA DATBASE
		LDA NUMDIR+1
		STA DATBASE+1
	
		LDX #4		; DATBASE = NUMDIR / 16
DATBAS1:	LSR DATBASE+1
		ROR DATBASE
		DEX
		BNE DATBAS1
	
		CLC		; DATBASE += DIRBASE
		LDA DATBASE
		ADC DIRBASE
		STA DATBASE
		LDA DATBASE+1
		ADC DIRBASE+1
		STA DATBASE+1

;		jsr PRINTINFO
		
		CLC
		RTS


		
;-------------------------------------------------------------------------------
; read first sector and see if MBR (FAT-16) or boot-sector (FAT-12)
;-------------------------------------------------------------------------------
READBOOT:	
		JSR CLEARSEC                            ;read MBR or Boot sector
		JSR READSEC				;Fat16, SD-Card: MBR; Fat12 Bootsec 
		
		JSR CHECKFAT
		BEQ READB3				;Fat16 MBR
		CMP #3
		BNE READB2
READB1:		LDA #0
READB2:		RTS
	
READB3:		LDY #<(BUFFER+PART1)
		LDA #>(BUFFER+PART1)
		JSR COPY32
	
		JSR READSEC

;-------------------------------------------------------------------------------
; 0:FAT16 MBR
; 1:NO BOOTSEC/MBR
; 2:BOOTSEC, NO FAT16/Harddrive
; 3:BOOTSEC, FAT16
;-------------------------------------------------------------------------------
CHECKFAT:	LDA BUFFER+$1FE
		CMP #$55				;check sec+$1fe = 55AA
		BNE CHKFATEX1			
		LDA BUFFER+$1FF
		CMP #$AA
		BNE CHKFATEX1				;no boot sector
		LDA BUFFER+$1C2				;check in MBR
		CMP #$0E				;0E Partition
		BEQ CHKFATEX0
		CMP #$06				;06 Partition
		BEQ CHKFATEX0
		LDA BUFFER+$15
		CMP #$F8				;Hard Drive
		BNE CHKFATEX2
;		LDA BUFFER+$37
;		CMP #'A'
;		BNE CHKFAT4
CHKFATEX3:	LDA #3
		RTS
CHKFATEX2:	LDA #2
		RTS
CHKFATEX1:	LDA #1
		RTS
CHKFATEX0:	LDA #0
		RTS


;*******************************************************************************
;*******************************************************************************
; CLUSTER related routines
;*******************************************************************************
;*******************************************************************************


;-------------------------------------------------------------------------------
; compute absolute data-sector-number from FCURCLUS and FCURSEC
;-------------------------------------------------------------------------------
CLU2SEC:	JSR CLEARSEC				;clear SECTOR
		
		SEC					;subtract 2 from current cluster
		LDA FCURCLUS
		SBC #2
		STA SECTOR
		LDA FCURCLUS+1
		SBC #0
		STA SECTOR+1
				
		LDA SECCLUS				;multiply by sec per clusters
CL2SEC2:	LSR
		BEQ CL2SEC1
		ASL SECTOR
		ROL SECTOR+1
		ROL SECTOR+2
		JMP CL2SEC2
	
CL2SEC1:	clc					;add Data-Base
		ldx #0
		ldy #4
CL2SEC1A:	lda SECTOR, x
		adc DATBASE, x
		sta SECTOR, x
		inx
		dey
		bne CL2SEC1A
		
		clc					;add file current sector
		lda SECTOR
		adc FCURSEC
		sta SECTOR
		bcc CL2SEC1B		
		inc SECTOR+1
		bne CL2SEC1B
		inc SECTOR+2
		bne CL2SEC1B
		inc SECTOR+3
CL2SEC1B:	rts

;-------------------------------------------------------------------------------
; load AX with FCURCLUS
;-------------------------------------------------------------------------------
LOAXCCLUS:	ldx FCURCLUS
		lda FCURCLUS+1
		rts

;-------------------------------------------------------------------------------
; store AX in FCURCLUS
;-------------------------------------------------------------------------------
STAXCCLUS:	stx FCURCLUS
		sta FCURCLUS+1
		rts

;-------------------------------------------------------------------------------
; load AX with NEWCLUS
;-------------------------------------------------------------------------------
LOAXNCLUS:	ldx NEWCLUS
		lda NEWCLUS+1
		rts

;-------------------------------------------------------------------------------
; load AX with FSTRTCL
;-------------------------------------------------------------------------------
LOAXSCLUS:	lda FSTRTCL+1
		ldx FSTRTCL
		rts

;-------------------------------------------------------------------------------
; store FATEND in NEWCLUS
;-------------------------------------------------------------------------------
STENDNCLUS:	ldy #<FATEND
		sty NEWCLUS
		ldy #>FATEND
		sty NEWCLUS+1
		rts
;-------------------------------------------------------------------------------
; GET FREE CLUSTER SEARCHING FROM
;
; X:CLUST:L
; A:CLUST:H
;
; AND INITIALIZE TO $xFFF
;
; NEWCLUS	: HOLDS NEW CLUSTER-NO.
;-------------------------------------------------------------------------------
GETFCLUS:	stx NEWCLUS
		sta NEWCLUS+1
		
GETFCLUS2:	jsr LOAXNCLUS
		jsr GETCLUST

		tay					;high-byte zero?
		bne GETFCLUS1				;no, increment
		txa                                     ;low-byte zero?
		bne GETFCLUS1				;no, increment

		jsr LOAXNCLUS                           ;found free cluster
		tay
		pha
		txa
		pha
		tya
		
		jsr STENDNCLUS				;store FATEND to NEWCLUS via Y
		jsr PUTCLUST
		pla
		sta NEWCLUS
		pla
		sta NEWCLUS+1
		rts
		
GETFCLUS1:	inc NEWCLUS
		bne GETFCLUS2
		inc NEWCLUS+1
		jmp GETFCLUS2

;-------------------------------------------------------------------------------
; GET FREE CLUSTER
; INIT TO $FFFF
; CHAIN WITH CURCLUS
;-------------------------------------------------------------------------------
CHAINCLU:	jsr LOAXCCLUS				;load AX with FCURCLUS			
		jsr GETFCLUS				;get free cluster in NEWCLUST
		jsr LOAXCCLUS				;load ax again run into PUTCLUST
		jsr PUTCLUST				;put NEWCLUST in current cluster
		jsr LOAXNCLUS				;copy NEWCLUS to FCURCLUS
		jmp STAXCCLUS
		
;-------------------------------------------------------------------------------
; Put cluster-number in NEWCLUS to cluster pointed to by 
; X:	CLUST:L
; A:	CLUST:H
; even		odd
; 03 21		06 54
; Byte	Byte	Byte
; NN	NN	NN
; 21	43	65
;-------------------------------------------------------------------------------
PUTCLUST:
	.IF PLATFORM = 4

		jsr COMPFAT12
		
		lda #$FF				
		sta FDIRTY
		
		bcs PUTCODD

		lda NEWCLUS
		sta (FATPTRS), y
		jsr INCFATBYTE
		lda (FATPTRS), y
		and #240				;mask out lower nibble
		ora NEWCLUS+1				;or-in lower nibble
		sta (FATPTRS), y
		rts
		
PUTCODD:	lda (FATPTRS), y
		and #15					;mask out high nibble
		sta (FATPTRS), y
		lda NEWCLUS
		asl
		asl
		asl
		asl
		ora (FATPTRS), y			;or in low nibble 
		sta (FATPTRS), y			

		jsr INCFATBYTE
	
		lda NEWCLUS
		sta SHIFT
		lda NEWCLUS + 1
		asl SHIFT
		rol
		asl SHIFT
		rol
		asl SHIFT
		rol
		asl SHIFT
		rol
		sta (FATPTRS), y
		rts
		
;-------------------------------------------------------------------------------
; Point FATPTRS to cluster in AX and read FAT sector if needed
; Carry holds even/odd cluster
; Y: 0
;-------------------------------------------------------------------------------
COMPFAT12:	tay					;copy for later use
		lsr					;SECTOR = AX / 2
		sta FATPTRS+1
		txa
		ror
		sta FATPTRS
		php					;save carry for even/odd
		
		clc
		txa
		adc FATPTRS
		sta FATPTRS
		tya
		adc FATPTRS+1
		lsr
		sta SECTOR
		inc SECTOR				;HACK! add FATBASE actually (usually 1)
		lda #0
		sta SECTOR+1
		rol
		adc #>FATBUF
		sta FATPTRS+1
		
		jsr READFAT
		
		plp					;restore carry
		ldy #0					;return N=0
		rts
	.ELSE
		jsr COMPFAT16
		lda NEWCLUST
		sta (FATPTRS),Y
		iny
		lda NEWCLUST+1
		sta (FATPTRS),Y
		rts

COMPFAT16:
		CLC
		STA SECTOR
		ADC FATBASE
		STA SECTOR
		LDA FATBASE+1
		ADC #0
		STA SECTOR+1
		LDA FATBASE+2
		ADC #0
		STA SECTOR+2
		LDA FATBASE+3
		ADC #0
		STA SECTOR+3	
		TXA					;save X
		PHA
		JSR READFAT
	
		LDA #<FATBUF
		STA FATPTRS
		LDA #>FATBUF
		STA FATPTRS+1
	
		PLA					;get former X
		ASL
		BCC COMPFAT16A
		INC FATPTRS+1
COMPFAT16A:	tay
		rts
	.ENDIF
	
;-------------------------------------------------------------------------------
; get next cluster from FCURCLUS in AX
;-------------------------------------------------------------------------------
GETNEXTC:       jsr LOAXCCLUS
	
;-------------------------------------------------------------------------------
; X:	CLUST:L
; A:	CLUST:H
; returns cluster-number stored at cluster AX in AX
;-------------------------------------------------------------------------------
GETCLUST:

	.IF PLATFORM = 4
;-------------------------------------------------------------------------------
; GETCLUST for FAT-12:
;	FATSEC = (A*256+X) * 3 / 2 (1.5)
;-------------------------------------------------------------------------------	
		jsr COMPFAT12
		bcs GETCODD
		
GETCEVEN:	lda (FATPTRS), y
		jsr INCFATBYTE				;preserves A
		tax
GETCEVEN1:	lda (FATPTRS), y
		and #15
		rts
		
GETCODD:	lda (FATPTRS),y 
		sta SHIFT
		jsr INCFATBYTE
		lda (FATPTRS),y
		lsr
		ror SHIFT
		lsr
		ror SHIFT
		lsr
		ror SHIFT
		lsr
		ror SHIFT
		ldx SHIFT
		rts


;-------------------------------------------------------------------------------	
; increment pointer into FAT and check for overflow
; read new FAT sector if neeed
;-------------------------------------------------------------------------------	
INCFATBYTE:	inc FATPTRS
		bne INCFATBYTE1				;1ff?
		
		pha
		lda FATPTRS+1
		cmp #>FATBUF				;first page of buffer?
		beq INCFATBYTE2                         ;yes, increment
		
		inc SECTOR                              ;no, read next FAT sector
		jsr READFAT
		
		ldy #0                                  ;reset Y and PTR to start of buffer
		lda #(>FATBUF) - 1
		sta FATPTRS+1		
INCFATBYTE2:	inc FATPTRS+1
                pla
INCFATBYTE1:	rts

	.ELSE
;-------------------------------------------------------------------------------
; GETCLUST for FAT-16:
;-------------------------------------------------------------------------------
		jsr COMPFAT16
		LDA (FATPTRS),Y
		TAX
		INY
		LDA (FATPTRS),Y
		RTS
	.ENDIF

;-------------------------------------------------------------------------------
; free all cluster from cluster AX to last in chain ($xFFF)
;-------------------------------------------------------------------------------
FREECLUS:	ldy #0					;NEWCLUST = 0
		sty NEWCLUS
		sty NEWCLUS+1

FREECLUS1:	jsr STAXCCLUS				;store AX in FCURCLUS
		jsr GETCLUST				;get next cluster in AX
		pha					;store on stack
		txa
		pha
		jsr LOAXCCLUS
		jsr PUTCLUST				;set cluster to zereo (free)
		pla					;get next cluster from stack
		tax
		pla		
		cmp #>FATEND				;next cluster is FATEND
		bne FREECLUS1				;return
		cpx #<FATEND
		bne FREECLUS1
		rts
		


;*******************************************************************************
;*******************************************************************************
; DATA- and FAT-sector SIO routines 
;*******************************************************************************
;*******************************************************************************

	
;-------------------------------------------------------------------------------
; write FAT if FDIRTY <> 0
;-------------------------------------------------------------------------------
WRITEFAT:	LDA FDIRTY
		BNE WRITEFA1
                RTS
                
WRITEFA1:	LDX #<LASTFAT
		LDA #>LASTFAT
		JSR SETSEC				;set sector-number in floppy/drive

        	JSR SETWRITE				;set DSTATS and DCOMND
		LDA #0					;reset dirty
		STA FDIRTY
		BEQ RWFAT				;execute SIO command

;-------------------------------------------------------------------------------
; read a FAT sector. 
; if new sector to read, check if old one is dirty
; write old FAT sector if dirty
;-------------------------------------------------------------------------------
READFAT:	LDX #3
READFAT3:	LDA SECTOR,X				;compare SECTOR with LASTFAT
		CMP LASTFAT,X
		BNE READFAT2
		DEX
		BPL READFAT3				;if equal
		RTS					;sector already read, nothing to do

READFAT2:	JSR WRITEFAT				;write old sector if dirty

		LDX #3					;copy sector to LASTFAT
READFAT4:	LDA SECTOR,X
		STA LASTFAT,X
		DEX
		BPL READFAT4

		LDX #<SECTOR				;set sector to floppy/drive
		LDA #>SECTOR
		JSR SETSEC

READFAT1:	JSR SETREAD				;set DSTATS and DCOMND

RWFAT:		LDA #<FATBUF
		STA DBUFLO
		LDA #>FATBUF
		STA DBUFLO+1
		JMP RWSEC1

;-------------------------------------------------------------------------------
; write a Data sector if DDIRTY <> 0
;-------------------------------------------------------------------------------
WRITESEC:	LDA DDIRTY
		BNE WRITESE1
		RTS
		
WRITESE1:	LDX #<LASTSEC
		LDA #>LASTSEC
		JSR SETSEC
        	JSR SETWRITE
		LDA #0
		STA DDIRTY
		BEQ RWSEC

;-------------------------------------------------------------------------------
; read a data sector, save old sector if dirty
;-------------------------------------------------------------------------------
READSEC:	LDX #3
READSEC3:	LDA SECTOR,X
		CMP LASTSEC,X
		BNE READSEC2
		DEX
		BPL READSEC3
		RTS

READSEC2:	JSR WRITESEC
		
		LDX #3					;set LASTSEC TO SECTOR
READSEC4:	LDA SECTOR,X
		STA LASTSEC,X
		DEX
		BPL READSEC4

READSECF:	LDX #0
		LDA FWBURST				;write Burst active?
		STX FWBURST		
		BEQ READSECF1				;no ->
		LDA ICBLHZ				;still $200 to read?
		CMP #2		
		BCC READSECF1				;no ->
		BNE READSECF2				;greater, no read
		LDA ICBLLZ				;we have substracted only $1ff
		BEQ READSECF1				;so, if lenght-LO = 0 then end is reached.
READSECF2:	RTS

READSECF1:	LDX #<SECTOR
		LDA #>SECTOR
		JSR SETSEC

READSEC1:	JSR SETREAD

RWSEC:		LDA BUFADRL
		STA DBUFLO
		LDA BUFADRH
		STA DBUFHI

	.IF PLATFORM <= 1
RWSEC1:		LDX DBUFLO
		LDA DBUFLO+1
		CPY #$80		; $40 = read; $80 = write
		beq RWSEC2
		jmp readSector
RWSEC2:		jmp writeSector
	.ELSE	
RWSEC1:
		LDA #0			; 2*256 / 512 bytes
		STA DBYTLO	
		LDA #2
		STA DBYTLO+1
	.IF PLATFORM = 4
		bit DSTATS              ;SALLY can recieve only 256byte chunks
		bpl RWSEC3		;read, get 512 bytes
		dec DBYTLO+1		;write put 2 * 256 bytes
		jsr CALLSIO
		jsr SETWRITE
		inc DBUFHI
	.ENDIF
RWSEC3:		JMP CALLSIO
	.ENDIF
	
	
SETREAD:
	.IF PLATFORM <= 1
		LDY #$40
	.ELSE
		LDA #$40
		STA DSTATS
		LDA #'R'
		STA DCOMND
	.ENDIF
		RTS

SETWRITE:
	.IF PLATFORM <= 1
		LDY #$80
	.ELSE
		LDA #$80
		STA DSTATS
		LDA #'P'
		STA DCOMND
	.ENDIF
		RTS
;
;
;
	.IF PLATFORM <= 1
SETSEC:		jmp setSector
	.ELSE	
SETSEC:		STX DBUFLO
		STA DBUFLO+1
		LDA #$31
		STA DDEVIC
		LDA #2
		STA DUNIT
	
		JSR SETWRITE
	
		LDA #4
		STA DBYTLO
		ASL
		STA DTIMLO
		LDA #0
		STA DBYTLO+1
		STA DAUX1
		STA DAUX2                       ;fall through
	.ENDIF

CALLSIO:        JSR SIOV
                BPL CALLSIO1
                LDX STACKP
                TXS
CALLSIO1:       RTS
;*******************************************************************************
;*******************************************************************************
; debug and helper routines
;*******************************************************************************
;*******************************************************************************


;-------------------------------------------------------------------------------
; convert 32 bit number to 10-byte text, do not display leading zeros
; from BIN 4-bytes
;   to BCD 5-bytes
;   to DECIMAL 10-bytes 
;-------------------------------------------------------------------------------
BIN2DEC:	LDA #0			;clear 5-byte BCD (=10 nibbles)
		LDX #4
BIN2DEC1:	STA BCD,X
		DEX
		BPL BIN2DEC1

		LDX #32
		SED
BIN2DEC2:	ASL BIN
		ROL BIN+1
		ROL BIN+2
		ROL BIN+3

		LDY #5
BIN2DEC3:	LDA BCD-1,Y
		ADC BCD-1,Y
		STA BCD-1,Y
		DEY
		BNE BIN2DEC3
		
		DEX
		BNE BIN2DEC2
		
		CLD				
		STY NODISPL		;X, Y = 0

BIN2DEC4:	LDA BCD,X
		PHA
		LSR
		LSR
		LSR
		LSR
		JSR BIN2INC
		PLA
		AND #15
		JSR BIN2INC
		INX
		CPX #5
		BNE BIN2DEC4
		RTS

BIN2INC:	BNE BIN2INC1		; no '0' => print it? 	
		BIT NODISPL		; print if nodisplay negativ
		BMI BIN2INC2	
		CPY #9			; print last digit in any case
		BEQ BIN2INC2
		LDA #32			; else print space
		BNE BIN2INC3

BIN2INC1:	DEC NODISPL
BIN2INC2:	EOR #'0'
BIN2INC3:	STA DECIMAL,Y
		INY
		RTS

;-------------------------------------------------------------------------------
; subtract 32-byte word: FATPTRD = FATPTRD - FATPTRS
;-------------------------------------------------------------------------------
SBC32:		LDY #0
		SEC
SBC32A:		LDA (FATPTRD),Y
		SBC (FATPTRS),Y
		STA (FATPTRD),Y
		INY
		CPY #4
		BCC SBC32A
		RTS

;-------------------------------------------------------------------------------
; FATPTRD - FATPTRS (compare)
;-------------------------------------------------------------------------------
CMP32:		LDY #3
CMP32A:		LDA (FATPTRD),Y
		CMP (FATPTRS),Y
		BNE CMP32B
		DEY
		BPL CMP32A	
CMP32B:		RTS

;-------------------------------------------------------------------------------
; copy from PTR in AY from FATPTRS to FATPTRD
;-------------------------------------------------------------------------------
COPY32:		STY FATPTRS
		STA FATPTRS+1
COPY32B:	LDY #3
COPY32A:	LDA (FATPTRS),Y
		STA (FATPTRD),Y
		DEY
		BPL COPY32A
		RTS

CLEARSEC:	lda #0
		sta SECTOR
		sta SECTOR+1
		sta SECTOR+2
		sta SECTOR+3
		rts
		
;		LDY #<SECTOR				;Clear SECTOR via
;		LDA #>SECTOR				;FATPTRD
;
;;-------------------------------------------------------------------------------
;; clear long-word AY -> FATPTRD
;;-------------------------------------------------------------------------------
;CLEAR32:	STY FATPTRD
;		STA FATPTRD+1
;		LDA #0
;FILL32:		LDY #3
;CL32A:		STA (FATPTRD),Y
;		DEY
;		BPL CL32A
;		RTS

;-------------------------------------------------------------------------------
; print A hexadecimal, retain AXY
;-------------------------------------------------------------------------------
PUTHEX:		PHA
		TXA
		PHA
		TYA
		PHA
		
	.IF PLATFORM = 2 || PLATFORM = 4
		TSX
		LDA $103,X
	.ELSE
		LDA 3,s
	.ENDIF
		PHA
		LSR
		LSR
		LSR
		LSR
		JSR PUTNIB
		
		PLA
		AND #15
		JSR PUTNIB

		PLA
		TAY
		PLA
		TAX
		PLA
		RTS	

PUTNIB:		CMP #10
		BCC PUTNIB1
		ADC #6
PUTNIB1:	ADC #48
		JMP EOUTCH
		
PRINT:		PHA
		TXA
		PHA
		TYA
		PHA
	.IF PLATFORM = 2 || PLATFORM = 4
		TSX
		LDA $103,X
		CMP #$0A
		BNE PR1
		LDA #EOL
	.ELSE
		lda 3,s
	.ENDIF
PR1:		JSR EOUTCH
		PLA
		TAY
		PLA
		TAX
		PLA
		RTS

SPACE:		pha
		lda #32
		bne NEWLINE1
		
NEWLINE:	PHA
		LDA #EOL
NEWLINE1:	JSR PRINT
		PLA
		RTS
; 
;
;		
PRINTSTR:	TAY
		LDA FATPTRS
		PHA
		LDA FATPTRS+1
		PHA
		
		STX FATPTRS
		STY FATPTRS+1
		LDY #0
		BCC PRINTSTR2

		JSR NEWLINE

PRINTSTR2:	LDA (FATPTRS),Y
		BEQ PRINTSTR1
		JSR PRINT
		INY
		BNE PRINTSTR2	;do not print more than 256 chars
PRINTSTR1:	PLA
		STA FATPTRS+1
		PLA
		STA FATPTRS
		RTS

	.IF DEBUG = 1
PRINTINFO:
	.IF PLATFORM = 2 || PLATFORM = 4
		LDA #4					;key still pressed
		BIT SKSTAT			
		BNE PRINTINFO4				;no, leave
		LDA KBCODE				;help key?
		CMP #17			
		BEQ PRINTINFO6				;yes print
PRINTINFO4:	RTS
	.ENDIF
	
PRINTINFO6:	SEC
		LDX #<MSG0
		LDA #>MSG0
		JSR PRINTSTR
		LDA SECCLUS
		JSR PUTHEX

		SEC
		LDX #<MSG1
		LDA #>MSG1
		JSR PRINTSTR
		LDA RESSEC+1
		JSR PUTHEX
		LDA RESSEC
		JSR PUTHEX
		
		SEC
		LDX #<MSG2
		LDA #>MSG2
		JSR PRINTSTR
		LDA NUMFATS
		JSR PUTHEX

		SEC
		LDX #<MSG3
		LDA #>MSG3
		JSR PRINTSTR
		LDA NUMDIR+1
		JSR PUTHEX
		LDA NUMDIR
		JSR PUTHEX

		SEC
		LDX #<MSG4
		LDA #>MSG4
		JSR PRINTSTR
		LDA SECSFAT+1
		JSR PUTHEX
		LDA SECSFAT
		JSR PUTHEX
		
		SEC
		LDX #<MSG5
		LDA #>MSG5
		JSR PRINTSTR
		LDX #3
PRINTINFO7:	LDA SECTOR,X
		JSR PUTHEX
		DEX
		BPL PRINTINFO7

		SEC
		LDX #<MSG6
		LDA #>MSG6
		JSR PRINTSTR
		LDX #3
PRINTINFO1:	LDA FATBASE,X
		JSR PUTHEX
		DEX
		BPL PRINTINFO1
		
		SEC
		LDX #<MSG7
		LDA #>MSG7
		JSR PRINTSTR
		LDX #3
PRINTINFO2:	LDA DIRBASE,X
		JSR PUTHEX
		DEX
		BPL PRINTINFO2

		SEC
		LDX #<MSG8
		LDA #>MSG8
		JSR PRINTSTR
		LDX #3
PRINTINFO3:	LDA DATBASE,X
		JSR PUTHEX
		DEX
		BPL PRINTINFO3

	.IF PLATFORM = 2 || PLATFORM = 4
		LDA #4
PRINTINFO5:	BIT SKSTAT
		BEQ PRINTINFO5
	.ENDIF

		JMP NEWLINE

MSG0:		.byte "Sectors per cluster: $",0
MSG1:		.byte "Reserved sectors   : $",0
MSG2:		.byte "Number of FATs     : $",0
MSG3:		.byte "Number of root-entr: $",0
MSG4:		.byte "Sectors per FAT    : $",0
MSG5:		.byte "FAT-16 boot sector : $",0
MSG6:		.byte "FAT base           : $",0
MSG7:		.byte "DIR base           : $",0
MSG8:		.byte "DAT base           : $",0

	.ENDIF
	
;-------------------------------------------------------------------------------
; print character via Editor handler routine at $E406
;-------------------------------------------------------------------------------
EOUTCH:		TAX
		LDA EPB+1
		PHA
		LDA EPB
		PHA
		TXA
		RTS

;-------------------------------------------------------------------------------
; print SECTOR 
;-------------------------------------------------------------------------------
;DUMPSEC:	pha
;		txa
;		pha
;		ldx #3
;DUMPSEC1:	lda SECTOR,x
;		jsr PUTHEX
;		dex
;		bpl DUMPSEC1
;		lda #EOL
;		jsr PRINT
;		pla
;		tax
;		pla
;		rts
		
;-------------------------------------------------------------------------------
; DEBUG FATPTRS
;-------------------------------------------------------------------------------
;DUMPPTR:	LDA FATPTRS+1
;		JSR PUTHEX
;		LDA FATPTRS
;		JSR PUTHEX
;		JMP SPACE
		
;DUMPBUF:	jsr DUMP256
;		lda #4					;key still pressed
;DUMPBUF3:	bit SKSTAT			
;		bne DUMPBUF3				;no
;		inc DUMPBUF2+2
;		jsr DUMP256
;		dec DUMPBUF2+2
;		lda #4					;key still pressed
;DUMPBUF4:	bit SKSTAT			
;		bne DUMPBUF4				;no
;		rts
;		
;DUMP256:	ldx #0
;DUMPBUF1:	txa
;		and #15
;		bne DUMPBUF2
;		jsr NEWLINE
;DUMPBUF2:	lda BUFFER, x
;		jsr PUTHEX
;		inx
;		bne DUMPBUF1		
;		jmp NEWLINE

	.IF PLATFORM = 4
		.include "dup.a65"
	.ENDIF