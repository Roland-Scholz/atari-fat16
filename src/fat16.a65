DEBUG .set 0

.macro	cmp_icbalz_y
	.IF PLATFORM=0
		CMP [ICBALZ],Y
	.ELSE
		CMP (ICBALZ),Y
	.ENDIF
.endmacro

.macro	lda_icbalz_y
	.IF PLATFORM=0
		LDA [ICBALZ],Y
	.ELSE
		LDA (ICBALZ),Y
	.ENDIF
.endmacro

.macro	sta_icbalz_y
	.IF PLATFORM=0
		STA [ICBALZ],Y
	.ELSE
		STA (ICBALZ),Y
	.ENDIF
.endmacro

	.IF PLATFORM = 2 || PLATFORM = 4
		.include "atarixl.inc"
		.include "fat16.inc"

EPB	=	$E406		;putbyte

		.ORG FATCODE
		
		JMP STARTUP	;0
		JMP PRINT	;3
		JMP PUTHEX	;6
		JMP PRINTSTR	;9
		JMP INITFAT
	.ENDIF
	
;-------------------------------------------------------------------------------
; set DOSINI to reset-proof DOS-Initialisation 
; set DOSVEC to DUP-code
; register D: handler
; set MEMLO for Basic 
;-------------------------------------------------------------------------------
STARTUP:
	.IF PLATFORM = 2 || PLATFORM = 4
		LDA #<INIT
		STA DOSINI
		LDA #>INIT
		STA DOSINI+1
	
		LDA #<DUPCODE
		STA DOSVEC
		LDA #>DUPCODE
		STA DOSVEC+1
	
;		LDA #25		; ATMAS-II patches		
;		STA $329F
;		STA $32BF
;		LDA #'B'
;		STA $2A11

INIT:		LDY #<HANDTAB
		LDA #>HANDTAB
		LDX #DRVCHAR
		JSR PHENTV				;init D: Device (not available on ATARI 400/800)
	
		LDA #<$1F90
		STA MEMLO
		LDA #>$1F90
		STA MEMLO+1
		
	.ELSE
;		ldx #0
;HAFIND:		lda HATABS,x
;		beq HAFOUND
;		cmp #DRVCHAR
;		beq HAFOUND
;		inx
;		inx
;		inx
;		cpx #MAXDEV
;		bcc HAFIND
;		rts
;HAFOUND:	lda #DRVCHAR
;		sta HATABS,x
;		lda #<HANDTAB
;		sta HATABS+1,x
;		lda #>HANDTAB
;		sta HATABS+2,x
	.ENDIF
		JMP INITFAT

;-------------------------------------------------------------------------------
; D: Handler-Table
; Open, Close, Get Put, Status, Special, Init
;-------------------------------------------------------------------------------		
HANDTAB:	.word OPENCHA-1		; open channel
		.word CLOSECHA-1	; close ...
		.word GETCHA-1		; get channel
		.word PUTCHA-1		; put channel
		.word STATUSCHA-1	; status of channel
		.word SPECIAL-1
		rts

;-------------------------------------------------------------------------------
; 		DIRFILE	0=ALL, 1=FILES, 2=FREE DIR,
;			3=DIR
;-------------------------------------------------------------------------------
DIRSTART:	STA DIRFILE
		LDA DIRCLUS
		STA FSTRTCL
		LDA DIRCLUS+1
		STA FSTRTCL+1
		RTS

;-------------------------------------------------------------------------------
; Check if second or third character is ":"
; return Err165 (Bad file name / file name error) if not
;-------------------------------------------------------------------------------
CHECKHAN:	LDY #1
		LDA #':'
		cmp_icbalz_y
		BEQ CHECKHA1
		INY
		cmp_icbalz_y
		BEQ CHECKHA1
ERR165:		JSR CLOSEFCB
		LDY #165
CHECKHA1:	RTS

;-------------------------------------------------------------------------------
; Traverse directory and check if filename matches
;-------------------------------------------------------------------------------
GETFILE:	
		jsr DIRSTART				;initialise DIRFILE, FSTRTCL
		jsr CHECKHAN
		bmi FINDFILEND
		
		iny					;Y = 2 or 3 from CHECKHAN 
		jsr STR2RAW				;convert to 11 chars including * to ?
		jsr OPENDIR				;position to first directory entry	
		
FINDFIL1:	ldy #10
FINDFIL3:	lda DIRTEXT,Y
		cmp #'?'				;matches any character
		beq FINDFIL2
		cmp (FATPTRS),Y				;matches character in directory?
		beq FINDFIL2

NEXTFILE:	jsr NEXTDIR				;if not, get next directory entry
		bcc FINDFIL1				;check again
		ldy #170				;no further entry, return EOF
		rts

FINDFIL2:	dey
		bpl FINDFIL3
		ldy #1
FINDFILEND:	rts

;-------------------------------------------------------------------------------
;GET FCB Structure 0-3 
;Input 	FCBNO in A
;Return FCB-offset in X
;-------------------------------------------------------------------------------
GETFCB:		STA FCBCODE
		LDX #0
GETFCB0:	LDA FCBCODE
		CMP FCB0,X
		BEQ GETFCB9
		TXA
		CLC
		ADC #64
		TAX
		BNE GETFCB0
		LDY #161		;TOO MANY
		RTS
GETFCB9:	LDY #1
		RTS			;OPEN FILES

;-------------------------------------------------------------------------------
; mark current FCB as unassigned
;-------------------------------------------------------------------------------
CLOSEFCB:
		LDX FFCBOFF				;get OFFSET of current FCB		
		LDA #$FF				;switch off copy and original FCB
		STA FIOCBNR
		STA FCB0,X
		RTS

;-------------------------------------------------------------------------------
; swap-out and swap-in from FCB table to current FCB
;-------------------------------------------------------------------------------
SETFCB:		LDA FIOCBNR				;optimisation: current FCB
		CMP ICIDNO				;already active?
		BEQ SETFCB9				;yes, do nothing
		
SWAPFCB:	CMP #$FF				;current FCB unassigned?
		BEQ SWAPIN				;yes, just swapin FCB

SEC2FSEC:	LDX #3					;save SECTOR
SEC2FSE1:	LDA SECTOR,X
		STA FSECTOR,X
		DEX
		BPL SEC2FSE1

PTR2FPTR:	LDA FATPTRS				;and FATPTRS
		STA FCURPTR
		LDA FATPTRS+1
		STA FCURPTR+1

		LDY #0					;copy current FCB to FCB-table
		LDX FFCBOFF
SWAPFCB0:	LDA FIOCBNR,Y
		STA FCB0,X
		INX
		INY
		CPY #FBLKEND-F+1
		BNE SWAPFCB0

SWAPIN:		LDA ICIDNO
		JSR GETFCB

		LDY #0
SWAPIN0:	LDA FCB0,X
		STA FIOCBNR,Y
		INX
		INY
		CPY #FBLKEND-F+1
		BNE SWAPIN0
	
		LDA ICCOMZ				;if not OPEN command, read current sector
		CMP #OPEN				;of file
		BNE FSEC2SEC
SETFCB9:	RTS
		
FSEC2SEC:	LDX #3					
FSEC2SE1:	LDA FSECTOR,X
		STA SECTOR,X
		DEX
		BPL FSEC2SE1

FPTR2PTR:	LDA FCURPTR
		STA FATPTRS
		LDA FCURPTR+1
		STA FATPTRS+1

		JMP READSEC

;-------------------------------------------------------------------------------
; Find an empty FCB in FCB table and swap-in 
;-------------------------------------------------------------------------------
OPENFCB:	LDA #$FF
		JSR GETFCB				;get FREE FCB
		BMI OPENFCB2				;no free available

OPENFCB1:	LDA ICIDNO
		STA FCB0,X

		LDA #0					;CLEAR FCB
		LDY #FBLKEND-F-1
OPENFCB0:	STA FCB0+2,X
		INX
		DEY
		BNE OPENFCB0

		JSR SETFCB				;copy FCB from table to current FCB
		LDY #1
OPENFCB2:	RTS

;-------------------------------------------------------------------------------
; checks if filenmae contains only valid characters
; returns N=0 if yes
;-------------------------------------------------------------------------------
VALIDNAM:	LDX #10
VALIDNA1:	LDA DIRTEXT,X				;CARD
		CMP #'0'			
		BCC VALIDNA3				;< 0? => check special chars
		CMP #'9'+1				;<= 9? 
		BCC VALIDNA2				;yes OK, next char
		CMP #'A'				;
		BCC VALIDNA3				;< A? => check special chars
		CMP #'Z'+1				;<= Z?
		BCC VALIDNA2				;yes OK, next char

VALIDNA3:	LDY VALIDS				;check for special chars
VALIDNA4:	CMP VALIDCHA,Y
		BEQ VALIDNA2
		DEY
		BPL VALIDNA4
		RTS					;no valid char found, return N=1

VALIDCHA:	.byte " ~!@#$%&()-_^{}'?"		;usually test without "?", so 16+1 bytes!

VALIDNA2:	DEX
		BPL VALIDNA1	;X=$FF
	
		LDA #32		;check if first char != space
		CMP DIRTEXT
		BEQ VALIDNA9
		
;		CMP DIRTEXT+8
;		BEQ VALIDNA9

		INX		;X=0, make sure N=0		
		RTS
		
VALIDNA9:	DEX		;X=$FE, N=1
		RTS

;-------------------------------------------------------------------------------
; looks for a free cluster
;-------------------------------------------------------------------------------
INITDIR:	LDX #2					;start at cluster #2
		LDA #0
		JSR GETFCLUS				;get a free cluster for dir
		LDA NEWCLUS+1				;save NEWCLUS
		PHA
		LDA NEWCLUS
		PHA
	
		JSR FINDFDIR
		BCS INITDIR1
		PLA					;no free dir, pop NEWCLUS and bail out of OPEN 
		PLA
		PLA
		PLA
ERR169:		JSR CLOSEFCB				;Cluster not freed!
		LDY #169
		RTS

INITDIR1:
		LDY #0		;DIRNAME IN
		STY DIRFILE	;RESET DIRFILE
INITDIR2:
		LDA DIRTEXT,Y	;DIR ENTRY
		STA (FATPTRS),Y
		INY
		CPY #11
		BNE INITDIR2
	
		LDA #0		;INITIALIZE
INITDIR3:	STA (FATPTRS),Y	;REST
		INY
		CPY #32
		BNE INITDIR3
	
		STY DDIRTY	;PUT START
		LDY #DCLUS	;CLUSTER
		PLA		;INTO
		STA FCURCLUS
;		JSR PUTHEX
		STA (FATPTRS),Y	;DIR ENTRY
		INY
		PLA
		STA FCURCLUS+1
;		JSR PUTHEX
		STA (FATPTRS),Y
	
;		BRK
		RTS
		
;-------------------------------------------------------------------------------
; OPENCHA - Open Channel
; opens a FCB file control block for IO
;-------------------------------------------------------------------------------
OPENCHA:	JSR OPENFCB
		BMI OPENERR
;		RTS

;		LDA #$FF
;		STA FBURST

		LDA ICAX1Z				;check if Open Directory is meant
		AND #6
		CMP #6
		BNE OPENFILE

OPENDI:		JSR INITLSEC
		LDA #0
		STA HILF
		JMP GETFILE

OPENFILE:	LDA #1					;FILE THERE?
		JSR GETFILE			
		BPL OPENEXIS				;YES
			
OPENNEW:	LDA ICAX1Z				;WRITE FILE?
		AND #1+4+8				;NO READ OR
		CMP #8					;APPEND
		BEQ OPENNEW3
OPEN170:	JSR CLOSEFCB
		LDY #170
OPENERR:	RTS

OPENNEW3:	JSR VALIDNAM
		BPL OPENNEW4	
		JMP ERR165

OPENNEW4:	JSR INITDIR

OPENEXIS:
;-------------------------------------------------------------------------------
; remember directory position (FATPTRS and SECTOR)
;-------------------------------------------------------------------------------
SAVEDIR:	LDA FATPTRS
		STA DIRPTR
		LDA FATPTRS+1
		STA DIRPTR+1

		LDX #3
SAVEDIR1:	LDA SECTOR,X
		STA DIRSEC,X
		DEX
		BPL SAVEDIR1

		LDX #5		;GET START
		LDY #DCLUS+5	;CLUSTER
OPENF1:		LDA (FATPTRS),Y	;AND FILELEN
		STA FSTRTCL,X	;FROM
		DEY		;DIRENTRY
		DEX
		BPL OPENF1
	
;		LDX #15		INITIALIZE
;		LDA #0		REST
;		STA FCURSEC
;OPENF2		STA FBYT2RD,X
;		DEX
;		BNE OPENF2
	
		LDA ICAX1Z	;IF READ
		AND #4		;FINISHED
		BNE OPENEND
	
;		LDA #'*'
;		JSR PRINT
		
		LDA ICAX1Z	;APPEND?
		AND #1		
		BEQ OPENWRIT	;NO
	
		LDX #3		;if append
OPENF3:		LDA FILELEN,X	;copy filelen
		STA FRPOS,X	;to file-read-pos
		DEX
		BPL OPENF3
		
		JMP OPENEND
	
OPENWRIT:
		LDY #$FF
		LDX FSTRTCL
		LDA FSTRTCL+1
		JSR DELCLUS
	
		LDA #0
		LDX #3
OPENW4:		STA FILELEN,X
		DEX
		BPL OPENW4
	
OPENEND:	JSR FSEEK
		LDY #1
		RTS
;
;
;
DELCLUS:	STY HILF

DELCLUS1:	CMP #$FF
		BNE DELCLUS2
		CPX #$FF
		BNE DELCLUS2
		RTS

DELCLUS2:	JSR GETCLUST
		PHA
		STY FDIRTY
		LDA HILF
		STA (FATPTRS),Y
		DEY
		STA (FATPTRS),Y
		PLA
	
		LDY HILF
		BEQ DELCLUS1
		INC HILF
		BEQ DELCLUS1
;
;
;
FINDFDIR:	LDA #2
		JSR DIRSTART
		JSR OPENDIR
		BCS FINDFDI1
FINDFDI2:
		JSR NEXTDIR
		BCC FINDFDI2
FINDFDI1:	RTS


STR2RAW:	LDX #10			;fill DIRTEXT
		LDA #32			;with spaces
S2R12:		STA DIRTEXT,X
		DEX
		BPL S2R12
	
		INX			;x = 0
		STX WILD

		LDA #'.'
		cmp_icbalz_y		;first char '.' (local dir)?
;		CMP (ICBALZ),Y
		BNE S2R1			;no, goto S2R1
		STA DIRTEXT			;save in first char of DIRTEXT
		INY					;examine next input char
		cmp_icbalz_y	
;		CMP (ICBALZ),Y		;also '.'?
		BNE S2R1			;no, goto S2R1
		STA DIRTEXT+1		;save in 2nd char of DIRTEXT
		INY					;Y += 2 ?
		INY
		RTS					;return

S2R1:		JSR S2R4		;call S2R4 until 8 chars processed
		BCS S2R2
		CPX #8
		BNE S2R1
S2R2:		CMP #EOL
		BEQ S2R6
		CMP #'/'
		BEQ S2R6
		LDX #8
		LDA #0
		STA WILD
S2R5:		JSR S2R4
		BCS S2R6
		CPX #11
		BNE S2R5
S2R6:		RTS

S2R4:		lda_icbalz_y
;		LDA (ICBALZ),Y
;		JSR PRINT
		BIT WILD		;wildcard active?
		BMI S2R7		;yes => S2R7
		
		INY
		CMP #'*'
		BNE S2R8
		DEC WILD
		BMI S2R7
S2R8:		CMP #'.'
		BNE S2R11
		CPX #8
		BCC S2R3
		CLC
		RTS
S2R11:		CMP #32			;is space?
		BEQ S2R3		;yes => next
		CMP #EOL
		BEQ S2R3
		CMP #'/'
		BEQ S2R3
		CMP #0
		BEQ S2R3
		BNE S2R9
S2R7:		LDA #'?'	
S2R9:		CMP #'a'
		BCC S2R10
		CMP #'z'+1
		BCS S2R10
		SBC #31
S2R10:		STA DIRTEXT,X		;normal character
		INX
		CLC
		RTS
S2R3:		INX
		SEC
		RTS

;
;
;
CLOSECHA:	JSR SETFCB

		LDA ICAX1Z
		AND #8
		BEQ CLOSE5
	
		JSR WRITEFAT
	
		LDX #3
CLOSE3:		LDA DIRSEC,X
		STA SECTOR,X
		DEX
		BPL CLOSE3
		JSR READSEC
	
		LDA DIRPTR
		STA FATPTRD
		LDA DIRPTR+1
		STA FATPTRD+1
	
		LDY #DLEN+3
		STY DDIRTY
		LDX #3
CLOSE4:		LDA FILELEN,X
;		JSR PUTHEX
		STA (FATPTRD),Y
		DEY
		DEX
		BPL CLOSE4
	
		JSR WRITESEC
	
CLOSE5:		JSR CLOSEFCB
		JMP OK

;
;
;
;
; PUTCHANNEL
;
PUTCHA:		STA CIOCHR	; save byte, could have been called via ICPTLZ

		JSR SETFCB

		LDA ICAX1Z	;UPDATE?
		AND #4		;CECK
		BEQ PUTCHA1	;FILELEN

PUTUPD:		JSR CHECKLEN	;file-pos less than filelen
		BCC PUTSLOW1	;yes, continue slow
PUTUPD1:	LDY #EOF	;signal error
		RTS
		
PUTCHA1:	LDA FATPTRS	;points to begin of page?
		BNE PUTSLOW
		LDA ICBLHZ	;at least 512 bytes To write?
		CMP #2
		BCC PUTSLOW
		LDA FATPTRS+1	;points to begin of buffer?
		CMP #>BUFFER
		BNE PUTSLOW
		LDA ICCOMZ	;binary put?
		CMP #PUTCHR
		BNE PUTSLOW

PUTFAST:	INC FWBURST
		LDY #0
PUTFAST1:	lda_icbalz_y
;		LDA (ICBALZ),Y
		STA BUFFER,Y
		INY
		BNE PUTFAST1
		INC ICBAHZ
PUTFAST2:	lda_icbalz_y
;		LDA (ICBALZ),Y
		STA BUFFER+$100,Y
		INY
		BNE PUTFAST2
		
		INY
		STY DDIRTY
		
		JSR INCRPOS2
		JSR INCRPOS2
		
		JSR INCFILELE2
		JSR INCFILELE2
		
		SEC
		LDA ICBLLZ
		SBC #$FF
		STA ICBLLZ
		LDA ICBLHZ
		SBC #1
		STA ICBLHZ
	.IF PLATFORM=0
		lda ICBLBZ
		sbc #0
		sta ICBLBZ
	.ENDIF
	
		CLC
		LDA ICBALZ
		ADC #$FF
		STA ICBALZ
		BCC PUTFAST3
		INC ICBAHZ
	.IF PLATFORM=0
		bne PUTFAST3
		inc ICBABZ
	.ENDIF

PUTFAST3:	JMP INCSEC	


PUTSLOW:	JSR INCFILELEN
PUTSLOW1:	LDA CIOCHR
		LDY #0
		STA (FATPTRS),Y
		INY
		STY DDIRTY
		
		JSR INCRPOS
		JMP INCPTR


INCFILELEN:	INC FILELEN
		BNE INCFILELEX
INCFILELE2:	INC FILELEN+1
		BNE INCFILELEX
		INC FILELEN+2
		BNE INCFILELEX
		INC FILELEN+3
INCFILELEX:	RTS

;
; Get Character HTABS-Handler Rountine
;
GETCHA:		JSR SETFCB
		LDX ICIDNO
		LDA ICAX1,X
		AND #2
		BNE GETDIR	;if Bit 1 set, dir access

GETBYTE:	JMP READBYTE

GETDIR:		;lda #'*'
		;jsr PRINT
		
		LDY HILF	;each call to GETDIR return just one byte
		BPL GETDIR6	;HILF counts the bytes in one dir entry
		;lda #'E'
		;jsr PRINT
		LDY #EOF
		RTS

GETDIR6:	BNE GETDIR1		; Y > 0, get next Dir

		LDA #32			; Y==0, init DIRLINE
		STA DIRLINE+8
		STA DIRLENG-1
		LDA #EOL
		STA DIREOF
	
		LDX #0			; copy DIR-info
GETDIR3:	LDA (FATPTRS),Y		; from sector-buffer
		STA DIRLINE,X		; into DIRLINE
		INX
		INY
		CPY #8			; 8.3 jump over " "
		BNE GETDIR3A
		INX
		
GETDIR3A:	CPY #11
		BNE GETDIR3
	
		LDY #DATTRIB
		LDA (FATPTRS),Y
		LDY #9
		AND #16			;ist directory?
		BEQ GETDLEN		;no, get file length

GETDTXT:	LDA DIRTXT,Y		;write "DIR" into
		STA DIRLENG,Y		;output length
		DEY			;pos 9 downto 0
		BPL GETDTXT
		BMI GETDIR5

GETDLEN:	LDA DECIMAL,Y
		STA DIRLENG,Y
		DEY
		BPL GETDLEN

GETDIR5:	LDY #0

GETDIR1:	;lda #'1'
		;jsr PRINT

		INC HILF
		LDA DIRLINE,Y		;if Y points to end in DIRLINE
		CMP #EOL		;read next dir entry
		BNE GETDIR7

		;lda #'2'
		;jsr PRINT
		
		JSR NEXTFILE
		BMI GETDIR9

		;lda #'D'
		;jsr PRINT
		
		LDY #0
		STY HILF
	
		LDA (FATPTRS),Y
		BNE GETDIR8

GETDIR9:	;lda #'9'
		;jsr PRINT

		DEY
		STY HILF		;NEG.

GETDIR8:	LDA #EOL

GETDIR7:	
	.IF PLATFORM > 0
		CMP #$7E		; "~" in "-"
		BNE GETDIR2
		LDA #'-'
	.ENDIF
GETDIR2:	;pha
		;lda #'#'
		;jsr PRINT
		;pla
		LDY #1
		RTS	

;
;	     1234567890123
;DIRLINE	.byte "             "
;DIRLENG	.byte "           "
;	.byte EOL
;		      "0123456789"
DIRTXT:		.byte "       DIR"
;
NEXTDIR:	;lda #'N'
		;jsr PRINT
		
		JSR READDIR
		BCS NEXTDIR9	;No further Dir, RTS

CHECKDIR:	
;		jsr NEWLINE
;		
;		ldy #0
;ch1:		lda (FATPTRS),Y
;		jsr PUTHEX
;		lda #' '
;		jsr PRINT
;		iny
;		cpy #16
;		bne ch1
;		
;		lda #' '
;		jsr PRINT
;		
;		ldy #0
;ch2:		lda (FATPTRS),Y
;		jsr PRINT
;		iny
;		cpy #8
;		bne ch2
;		jsr NEWLINE
		
		LDY #DNAME
		LDX DIRFILE
		LDA (FATPTRS),Y
	
		CMP #DEL	;ENTRY
		BNE NEXTDIR2	;DELETED?
		CPX #2		;AND
		BNE NEXTDIR	;DIRFILE=2
		SEC		;END C=1
		RTS

NEXTDIR2:	;lda #'2'
		;jsr PRINT
		
		LDY #DATTRIB
		LDA (FATPTRS),Y	;SKIP
		AND #8		;VOLUME
		BNE NEXTDIR	;LABEL
	
		LDA (FATPTRS),Y	;DIR?
		AND #16
		CPX #0		;DIRFILE<>0
		BEQ NEXTDIR3	;SKIP DIRS
		CPX #3
		BNE NEXTDIR4
		TAX
		BNE NEXTDIR3
		BEQ NEXTDIR
NEXTDIR4:
		TAX
		BNE NEXTDIR

NEXTDIR3:
;		LDY #0
;ND1:		LDA (FATPTRS),Y
;		JSR PRINT
;		INY
;		CPY #11
;		BNE ND1

		LDY #DLEN+3
		LDX #3
NEXTDIR1:
		LDA (FATPTRS),Y
		STA BIN,X
		DEY
		DEX
		BPL NEXTDIR1

		JSR BIN2DEC
;		lda #'B'
;		jsr PRINT		
		CLC
NEXTDIR9:	RTS

STATUSCHA:	JMP OK

SPECIAL:	LDA ICCOMZ
		LDX #(XFUNCEND-XFUNC)
SPECIAL2:	CMP XFUNC,X
		BEQ SPECIAL1
		DEX
		BPL SPECIAL2
		LDY #132
		RTS

SPECIAL1:	TXA
		ASL			;* 2
		STA HILF		;store found X-pos
		
		LDA ICCOMZ
		CMP #CFSTAT		;no OPENFCB for FSTAT
		BEQ SPECIAL3
		
		JSR OPENFCB
		BMI SPECIAL9		;no free FCB 
SPECIAL3:
;		LDA #$FF
;		STA FBURST
		LDX HILF		;reload X-pos
		LDA XJMPTAB+1,X		;jump to special-function
		PHA
		LDA XJMPTAB,X
		PHA
SPECIAL9:
		RTS

XFUNC:		.byte CDELETE
		.byte CCHADIR
		.byte CRENAME
		.byte CFSTAT
XFUNCEND:	.byte CCREDIR

	
XJMPTAB:	.word DELETE-1
		.word CHADIR-1
		.word RENAME-1
		.word FSTAT-1
		.word CREDIR-1
;
;
;

;
;
;
FSTAT:		;JSR SETFCB
;		BPL FSTAT2
;		RTS
		
FSTAT2:		LDY #5
		LDX #3
FSTAT1:		LDA FILELEN,X
		sta_icbalz_y
		DEY
		DEX
		BPL FSTAT1
		JMP OK
		
RENAME:		LDY #0
RENAME2:	lda_icbalz_y
;		LDA (ICBALZ),Y
		CMP #','
		BEQ RENAME1	;FOUND
		CMP #EOL
		BEQ RENAME8
		INY
		BNE RENAME2
RENAME8:	JMP ERR165

RENAME1:	INY
		JSR STR2RAW
		INC VALIDS
		JSR VALIDNAM
		PHP
		DEC VALIDS
		PLP	
		BPL RENAME4
		JMP ERR165

RENAME4:	LDX #10
RENAME3:	LDA DIRTEXT,X
		STA DIRRENA,X
		DEX
		BPL RENAME3

		LDA #1
		JSR GETFILE
		BMI RENAME9

RENAME7:	LDY #10
RENAME6:	LDA DIRRENA,Y
		CMP #'?'
		BEQ RENAME5

;		TAX
;		LDA (FATPTRS),Y
;		JSR PRINT
;		TXA

		STA (FATPTRS),Y
		STA DDIRTY
RENAME5:	DEY
		BPL RENAME6

		JSR NEXTFILE
		BPL RENAME7

RENAME9:	JMP DELETE8
;
;
;
CREDIR:		LDA #3
		JSR GETFILE
		BMI CREDIR1
		JMP OPEN170

CREDIR1:	JSR VALIDNAM
		BPL CREDIR3
		JMP ERR165

CREDIR3:	LDA #8
		STA ICAX1Z
		JSR INITDIR
	
		LDY #DATTRIB
		LDA #16		;ATTR-DIR
		STA (FATPTRS),Y
	
		LDA #0
		STA FCURSEC
		JSR CLU2SEC
				
CREDIR2:	JSR READSEC
		JSR CLEARBUF
		
		LDA FCURSEC
		BNE CREDIR5
	
		LDX #10
		LDA #32
CREDIR6:	STA BUFFER,X
		STA BUFFER+32,X
		DEX
		BPL CREDIR6
	
		LDA #'.'
		STA BUFFER
		STA BUFFER+32
		STA BUFFER+33
	
		LDA #16
		STA BUFFER+DATTRIB
		STA BUFFER+DATTRIB+32
	
		LDA FCURCLUS
		STA BUFFER+DCLUS
		LDA FCURCLUS+1
		STA BUFFER+DCLUS+1
	
		LDA DIRCLUS
		STA BUFFER+DCLUS+32
		LDA DIRCLUS+1
		STA BUFFER+DCLUS+33

CREDIR5:	INC FCURSEC
		LDA FCURSEC
		CMP SECCLUS
		BEQ CREDIR4
	
		JSR INCSECTO
		JMP CREDIR2

CREDIR4:	JSR WRITESEC
		JSR WRITEFAT
		JMP DELETE8
;
;
;
CHADIR:		JSR CHECKHAN
		BPL CHADIR2
		RTS

CHADIR2:	LDA DIRCLUS		;push DIRCLUS to stack
		PHA
		LDA DIRCLUS+1
		PHA
		INY
		lda_icbalz_y		;is '/' access from ROOT?
;		LDA (ICBALZ),Y
		CMP #'/'
		BNE CHADIR3		;no
		
		LDA #0			;set DIRCLUS to 0
		STA DIRCLUS
		STA DIRCLUS+1
		INY			;yes
		lda_icbalz_y		;get next char
;		LDA (ICBALZ),Y

CHADIR3:	CMP #EOL		;end of filename?
		BNE CHADIR3C		;no
		PLA			;otherwise pop DIRCLUS from stack
		PLA			;and exit
CHADIREND:	JMP DELETE9		;EXIT
		
CHADIR3C:	LDA #3			;read only dirs
		JSR DIRSTART		;copy DIRCLUS to FSTRTCL
		JSR STR2RAW	
		DEY
		STY SAVEY
		
		JSR OPENDIR		
		BCC CHADIR3A
CHADIR3B:	PLA
		STA DIRCLUS+1
		PLA
		STA DIRCLUS
		JMP OPEN170
CHADIR3A:	JSR FINDFIL1
		BMI CHADIR3B

CHADIR1:	LDY #DCLUS
		LDA (FATPTRS),Y
;		JSR PUTHEX
		STA DIRCLUS
		INY
		LDA (FATPTRS),Y
;		JSR PUTHEX
		STA DIRCLUS+1
;		JSR KBGETC
		
CHADIR4:	LDY SAVEY
CHADIR5:	lda_icbalz_y
;		LDA (ICBALZ),Y
		CMP #'/'
		BNE CHADIR3
		INY
		JMP CHADIR5
;
;
;
DELETE:		LDA #0
		JSR GETFILE
		BMI DELETE9

DELETE2:	LDA FATPTRS
		PHA
		LDA FATPTRS+1
		PHA
	
		LDY #DCLUS
		LDA (FATPTRS),Y
		TAX
		INY
		LDA (FATPTRS),Y
	
		LDY #0
		JSR DELCLUS
	
		PLA
		STA FATPTRS+1
		PLA
		STA FATPTRS
	
		LDY #DNAME
		LDA #$E5
		STA (FATPTRS),Y
		STA DDIRTY
	
		JSR NEXTFILE
		BPL DELETE2
	
		JSR WRITEFAT
DELETE8:	JSR WRITESEC

DELETE9:	JSR CLOSEFCB
;		JMP OK	

OK:		LDY #1
		CLC
NOTOK:		RTS

;IODUMP:		LDX ICIDNO
;		LDY #0
;IODUMP1:	LDA IOCB,X
;		JSR PUTHEX
;		INX
;		INY
;		CPY #16
;		BNE IODUMP1
;		LDA #$9B
;		JSR PRINT
;		LDY #EOF
;		RTS

;
;
;
OPENDIR:	LDA FSTRTCL
		STA FCURCLUS
		ORA FSTRTCL+1
		BNE OPENDIR1
	
		JSR CROOT
		JMP CHECKDIR

OPENDIR1:	LDA FSTRTCL+1
		STA FCURCLUS+1
		LDA #0
		LDX #3
OPENDIR2:	STA FVAR32,X
		DEX
		BPL OPENDIR2
		
;		LDA FSTRTCL
;		JSR PUTHEX
;		LDA FSTRTCL+1
;		JSR PUTHEX
;		JSR KBGETC
		
		JSR FSEEK1
		JMP CHECKDIR
;
;
;
READDIR:	;lda FATPTRS+1
		;jsr PUTHEX
		;lda FATPTRS
		;jsr PUTHEX
		;lda #' '
		;jsr PRINT

		LDY #DNAME
		LDA (FATPTRS),Y
		BEQ READDIR9

CDIR3:		CLC
		LDA FATPTRS
		ADC #32
		STA FATPTRS
		LDA FATPTRS+1
		ADC #0
		STA FATPTRS+1		
		CMP #(>BUFFER)+2
		BNE READDIR8		;OK => CLC,RTS

		LDA FSTRTCL
		ORA FSTRTCL+1
		BEQ CDIR4
	
		JSR INCSEC
	
;		LDA #'I
;		JSR PRINT
;		LDA FCURCLUS
;		JSR PUTHEX
;		LDA FCURCLUS+1
;		JSR PUTHEX
	
		LDA #$FF
		CMP FCURCLUS+1
		BNE READDIR8
		CMP FCURCLUS
		BNE READDIR8
		BEQ READDIR9
	
CDIR4:		JSR INCSECTO
		JSR CROOT2
READDIR8:	CLC
		RTS
READDIR9:	SEC
		RTS
;
;
;
CROOT:		LDX #3
CROOT1:		LDA DIRBASE,X
		STA SECTOR,X
		DEX
		BPL CROOT1
		INX
		STX FSTRTCL
		STX FSTRTCL+1
CROOT2:		LDA #<BUFFER
		STA FATPTRS
		LDA #>BUFFER
		STA FATPTRS+1
		JMP READSEC

CHECKLEN:
;		LDX #3
;CL1:		LDA FRPOS,X
;		JSR PUTHEX
;		DEX	
;		BPL CL1
;		LDA #EOL
;		JSR PRINT

		LDX #3
CHECKL2:	LDA FRPOS,X
		CMP FILELEN,X
		BCC CHECKL1
		DEX
		BPL CHECKL2
CHECKL1:	RTS
;
;
;
READSLOW:
;		BIT FBURST	;burst off?
;		BMI READSLO1	;yes
;		DEC FBURST	;turn it off
		
;		JSR READSEC	;read sector
		
READSLO1:
;		LDA FATPTRS
;		JSR PUTHEX
;		LDA FATPTRS+1
;		JSR PUTHEX
		LDY #0
		LDA (FATPTRS),Y
		STA CIOCHR

		JSR INCRPOS
		JSR INCPTR

READBYT4:
;		JSR CHECKLEN
		LDA CIOCHR
;		BCS READBYT3
READBYT5:	LDY #1
		RTS
;READBYT3:	LDY #3
;		RTS

READBYTE:	JSR CHECKLEN
		BCC READBYT1
;		LDX ICIDNO
;		LDA FRPOS
;		JSR PUTHEX
;		STA ICBLLZ
;		STA ICBLL,X		
;		LDA FRPOS+1
;		JSR PUTHEX
;		STA ICBLHZ
;		STA ICBLH,X		

		LDY #EOF
		RTS
		
READBYT1:	
		LDY FATPTRS	;FATPTRS must point to begin of buffer, check LO-byte=0
		BNE READSLOW
;		TAY		;Y=0
		LDA ICBLHZ	;still >= 512 bytes to be read?
		CMP #2
		BCC READSLOW
		LDA ICCOMZ	;only GETCHAR allowed
		CMP #GETCHR
		BNE READSLOW
		LDA FATPTRS+1
		CMP #>BUFFER	;FATPTRS must point to begin of buffer
		BNE READSLOW
		
;		SEC		;still more than 512 bytes in the files available?
		LDA FILELEN	;filelen can't be greater then 64k
		SBC FRPOS
		LDA FILELEN+1
		SBC FRPOS+1
		CMP #2
		BCC READSLOW

;		JSR IODUMP

READFAST:
;		BIT FBURST	;Burst OFF?
;		BMI READFA2	;yes

;		STY FBURST	;Y=0
		
;		JSR INITLSEC
		
;		LDA ICBALZ
;		STA BUFADRL
;		LDA ICBAHZ
;		STA BUFADRH
;		JSR READSECF
;		LDA #<BUFFER
;		STA BUFADRL
;		LDA #>BUFFER
;		STA BUFADRH

;		INC ICBAHZ
;		LDY #$FF
;		LDA (ICBALZ),Y
;		JMP READFA3

READFA2:	LDA BUFFER,Y
		sta_icbalz_y
;		STA (ICBALZ),Y
		DEY
		BNE READFA2
		INC ICBAHZ
	.IF PLATFORM=0
		bne READFA1
		inc ICBABZ
	.ENDIF	
READFA1:	LDA BUFFER+$100,Y
		sta_icbalz_y
;		STA (ICBALZ),Y
		INY
		BNE READFA1

READFA3:	STA CIOCHR
		INC ICBAHZ
	.IF PLATFORM=0
		bne READFA3A
		inc ICBABZ
	.ENDIF	
	
READFA3A:
	.IF PLATFORM=0
		lda ICBLHZ
		bne READFA3B
		dec ICBLBZ
READFA3B:	dec ICBLHZ
		bne READFA3C
		dec ICBLBZ
READFA3C:	dec ICBLHZ
	.ELSE
		DEC ICBLHZ
		DEC ICBLHZ
	.ENDIF
		JSR INCRPOS2
		JSR INCRPOS2

		JSR INCSEC

		LDA ICBLHZ
		ORA ICBLLZ
	.IF PLATFORM=0
		ora ICBLBZ
	.ENDIF
		BEQ READFA4
		JMP READBYTE
		
READFA4:	INC ICBLLZ	;set buffer length to 1
		
		LDA ICBALZ	;decrement buffer address
		BNE READFA5
		
	.IF PLATFORM=0
		lda ICBAHZ
		bne READFA6
		dec ICBABZ
	.ENDIF
	
READFA6:	DEC ICBAHZ
READFA5:	DEC ICBALZ
		LDA CIOCHR
		JMP READBYT5	;exit success, Y=1

		
INCRPOS:	INC FRPOS
		BNE INCRPOS1
INCRPOS2:	INC FRPOS+1
		BNE INCRPOS1
		INC FRPOS+2
		BNE INCRPOS1
		INC FRPOS+3
INCRPOS1:	RTS


INCSECTO:	ldx #0
INCSECTO2:	inc SECTOR,x
		bne INCSECT1
		inx
		cpx #4
		bne INCSECTO2
INCSECT1:	rts

;
; convert 32 bit number to 10-byte text, do not display leading zeros
;
BIN2DEC:	LDA #0			;clear 5-byte BCD (=10 nibbles)
		LDX #4
BIN2DEC1:	STA BCD,X
		DEX
		BPL BIN2DEC1

		LDX #32
		SED
BIN2DEC2:	ASL BIN
		ROL BIN+1
		ROL BIN+2
		ROL BIN+3

		LDY #5
BIN2DEC3:	LDA BCD-1,Y
		ADC BCD-1,Y
		STA BCD-1,Y
		DEY
		BNE BIN2DEC3
		
		DEX
		BNE BIN2DEC2
		
		CLD				
		STY NODISPL		;X, Y = 0

BIN2DEC4:	LDA BCD,X
		LSR
		LSR
		LSR
		LSR
		JSR BIN2INC
		LDA BCD,X
		AND #15
		JSR BIN2INC
		INX
		CPX #5
		BNE BIN2DEC4
		RTS

BIN2INC:	BNE BIN2INC1		; no '0' => print it? 	
		BIT NODISPL		; print if nodisplay negativ
		BMI BIN2INC2	
		CPY #9			; print last digit in any case
		BEQ BIN2INC2
		LDA #32			; else print space
		BNE BIN2INC3

BIN2INC1:	DEC NODISPL
BIN2INC2:	EOR #'0'
BIN2INC3:	STA DECIMAL,Y
		INY
		RTS


;-------------------------------------------------------------------------------
; increments file read-pointer
; - reads next sector if at end of read-buffer
; - reads next cluster if end of sectors per cluster
;-------------------------------------------------------------------------------
INCPTR:		INC FATPTRS				;increment buffer-pointer
		BNE INCPTR9				;if not >= Buffer+$200
		INC FATPTRS+1				;nothing else to do
		LDA FATPTRS+1
		CMP #(>BUFFER)+2
		BNE INCPTR9
;
; READ NEXT SECTOR
;
INCSEC:		INC FCURSEC				;otherwise point to next sector
		LDA FCURSEC
		CMP SECCLUS
		BEQ INCSEC3				;new cluster necessary!
				
		JSR INCSECTO				;just increment sector
		JMP INCPTR8				;reset buffer-ptr and read-sector

;
; READ NEXT CLUSTER
;
INCSEC3:	LDA #0					;reset current sector in file
		STA FCURSEC
	
		JSR GETNEXTC				;get next cluster in AX and FCURCLUS
		
	.IF PLATFORM = 4
		CMP #$0F				;FAT-12 END-Marker = $FF0
	.ELSE
		CMP #$FF
	.ENDIF
		BNE INCSEC5
		CPX #$FF
		BNE INCSEC5				;not end of clusters
	
;		TAY					;?
		LDA ICAX1Z				;READ ACCESS?
		AND #8			
		BNE INCSEC1				;no, acquire new cluster
INCPTR9:	RTS
								
INCSEC1:	JSR CHAINCLU				;add a new cluster

		LDA DIRFILE				;Skip if not 
		CMP #2					;GET FREE DIR
		BNE INCSEC5				;
	
		JSR CLU2SEC				;otherwise clear sectors in new cluster
	
		LDA SECCLUS
		STA FCURSEC

INCSEC2:	JSR READSEC
		JSR CLEARBUF
		JSR WRITESEC
	
		JSR INCSECTO
	
		DEC FCURSEC
		BNE INCSEC2

INCSEC5:	JSR CLU2SEC				;computer sector
INCPTR8:	LDA #0					;reset buffer pointer
		STA FATPTRS
		LDA #>BUFFER
		STA FATPTRS+1
		
		JMP READSEC				;read sector

;
;
;
CLEARBUF:	LDA #0
		TAX
CLEARBU1:	STA BUFFER,X
		STA BUFFER+$100,X
		INX
		BNE CLEARBU1
		INC DDIRTY				;mark dirty	
		RTS

;-------------------------------------------------------------------------------
;
;-------------------------------------------------------------------------------
FSEEK:		LDA FSTRTCL
		STA FCURCLUS
		LDA FSTRTCL+1
		STA FCURCLUS+1
	
		LDX #3
FSEEK2:		LDA FRPOS,X
		STA FVAR32,X
		DEX
		BPL FSEEK2
	
FSEEK1:		LDA #<FVAR32
		STA FATPTRD
		LDA #>FVAR32
		STA FATPTRD+1
		LDA #<BYTCLUS
		STA FATPTRS
		LDA #>BYTCLUS
		STA FATPTRS+1
	
		JSR CMP32	; FATPTRD < FATPTRS?
		BCC FSEEKS	; ja
	
		JSR SBC32
	
		LDA FCURCLUS
		PHA
		LDA FCURCLUS+1
		PHA
		JSR GETNEXTC
	
		CMP #$FF
		BNE FSEEK3
		CPX #$FF
		BNE FSEEK3
	
		PLA
		STA FCURCLUS+1
		PLA
		STA FCURCLUS
		JSR CHAINCLU
		JMP FSEEK1
	
FSEEK3:		PLA
		PLA
		JMP FSEEK1
		
;
; INSIDE CLUSTER
; SECTOR+OFFSET
;
FSEEKS:		LDA #0
		STA FCURSEC
		JSR CLU2SEC
	
;		jsr DUMPSEC
		
		LDA FVAR32+1
		LSR
		STA FCURSEC
		CLC
		ADC SECTOR+1
		STA SECTOR+1
		BCC FSEEKS1
		INC SECTOR+2
		BNE FSEEKS1
		INC SECTOR+3

;		jsr DUMPSEC

		
FSEEKS1:	LDA FVAR32+1
		AND #1
		CLC
		ADC #>BUFFER
		STA FATPTRS+1
		LDA FVAR32
		STA FATPTRS

;		jsr DUMPSEC
;		JSR SEC2FSEC

		JSR READSEC
;		JSR KBGETC
		RTS


;-------------------------------------------------------------------------------
; LASTSEC = $FFFFFFFF
;-------------------------------------------------------------------------------
INITLSEC:	LDA #$FF
		LDX #3
INITLSEC1:	STA LASTSEC,X
		DEX
		BPL INITLSEC1
		RTS
	
;-------------------------------------------------------------------------------
; LASTFAT = $FFFFFFFF
;-------------------------------------------------------------------------------
INITFSEC:	LDA #$FF
		LDX #3
INITFSEC1:	STA LASTFAT,X
		DEX
		BPL INITFSEC1
		RTS

;-------------------------------------------------------------------------------
; Init all variables
; read boot sector
; compute FATBASE, DIRBASE, DATBASE, etc.
;-------------------------------------------------------------------------------
INITFAT:	
		LDA #0					;clear 512-byte of variables
		TAX
VCLEAR:		STA V,X
		STA V+256,X
		DEX
		BNE VCLEAR

;		LDA #0					;initialise offset
VSET2:		TAX					;into FCB
		STA FCB0+1,X				;0, 64, 128, 192
		CLC
		ADC #64
		BNE VSET2

		JSR INITLSEC				;set LASTSEC to $FFFFFFFF
		JSR INITFSEC				;set LASTFAT to $FFFFFFFF

		STA FIOCBNR				;all $FF
		STA FCB0
		STA FCB1
		STA FCB2
		STA FCB3


		LDA #<BUFFER
		STA BUFADRL
		LDA #>BUFFER
		STA BUFADRH
		
		LDA #VALIDNA2-VALIDCHA-2
		STA VALIDS
	
;		LDA #'/
;		STA PATH
	
		JSR READBOOT				;read boot sector
		
;	.IF PLATFORM <> 4
;		CMP #3
;		BNE DIE
;	.ELSE
;		CMP #2
;		BNE DIE
;	.ENDIF
		
;		JSR DUMPBUF
		
		LDX #10					;copy 11 important bytes / values
VCOPY:		LDA BUFFER+13,X				;from boot sector
		STA V,X					;to FAT variables
		DEX					;(SECCLUS to SECSFAT)
		BPL VCOPY
	
		LDA SECCLUS				;bytes per cluster as 32-byte word
		ASL
		STA BYTCLUS+1
	
		CLC					;compute FATBASE, DIRBASE
		LDA SECTOR
		ADC RESSEC
		STA FATBASE
		STA DIRBASE
		LDA SECTOR+1
		ADC RESSEC+1
		STA FATBASE+1
		STA DIRBASE+1
		BCC DIRBAS
		INC FATBASE+2
		INC DIRBASE+2
		BNE DIRBAS
		INC FATBASE+3
		INC DIRBASE+3
	
DIRBAS:		CLC
		LDX NUMFATS
DIRBAS2:	LDA DIRBASE
		ADC SECSFAT
		STA DIRBASE
		LDA DIRBASE+1
		ADC SECSFAT+1
		STA DIRBASE+1
		BCC DIRBAS1
		INC DIRBASE+2
		BNE DIRBAS1
		INC DIRBASE+3
DIRBAS1:	DEX
		BNE DIRBAS2
	
;		LDY #<DIRBASE	;COPY DIRBASE
;		LDA #>DIRBASE	;TO SECTOR
;		JSR COPY32
	
		LDA NUMDIR	;#ROOTDIRS
		STA DATBASE
		LDA NUMDIR+1
		STA DATBASE+1
	
		LDX #4		; DATBASE = NUMDIR / 16
DATBAS1:	LSR DATBASE+1
		ROR DATBASE
		DEX
		BNE DATBAS1
	
		CLC		; DATBASE += DIRBASE
		LDA DATBASE
		ADC DIRBASE
		STA DATBASE
		LDA DATBASE+1
		ADC DIRBASE+1
		STA DATBASE+1

;		jsr PRINTINFO
		
		CLC
		RTS

;-------------------------------------------------------------------------------
; get stuck if FAT16/12 can't be found
;-------------------------------------------------------------------------------	
DIE:	.IF PLATFORM <= 1
		SEC
		RTS
	.ELSE
		jsr PUTHEX
		lda DSTATS
		jsr PUTHEX
DIE1:		jmp DIE1
	.ENDIF
		
;-------------------------------------------------------------------------------
; read first sector and see if MBR (FAT-16) or boot-sector (FAT-12)
;-------------------------------------------------------------------------------
READBOOT:	
		JSR CLEARSEC

		JSR READSEC				;read first sector
		BMI READB2				;Fat16, SD-Card: MBR; Fat12 Bootsec 
		
		JSR CHECKFAT
		BEQ READB3				;Fat16 MBR
		CMP #3
		BNE READB2
READB1:		LDA #0
READB2:		RTS
	
READB3:		LDY #<(BUFFER+PART1)
		LDA #>(BUFFER+PART1)
		JSR COPY32
	
		JSR READSEC
		BMI READB2
;-------------------------------------------------------------------------------
; 0:FAT16 MBR
; 1:NO BOOTSEC/MBR
; 2:BOOTSEC, NO FAT16/Harddrive
; 3:BOOTSEC, FAT16
;-------------------------------------------------------------------------------
CHECKFAT:	LDA BUFFER+$1FE
		CMP #$55				;check sec+$1fe = 55AA
		BNE CHKFATEX1			
		LDA BUFFER+$1FF
		CMP #$AA
		BNE CHKFATEX1				;no boot sector
		LDA BUFFER+$1C2				;check in MBR
		CMP #$0E				;0E Partition
		BEQ CHKFATEX0
		CMP #$06				;06 Partition
		BEQ CHKFATEX0
		LDA BUFFER+$15
		CMP #$F8				;Hard Drive
		BNE CHKFATEX2
;		LDA BUFFER+$37
;		CMP #'A'
;		BNE CHKFAT4
CHKFATEX3:	LDA #3
		RTS
CHKFATEX2:	LDA #2
		RTS
CHKFATEX1:	LDA #1
		RTS
CHKFATEX0:	LDA #0
		RTS

;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------
; CLUSTER related routines
;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------


;-------------------------------------------------------------------------------
; compute absoute data-sector-number from FCURCLUS and FCURSEC
;-------------------------------------------------------------------------------
CLU2SEC:
		JSR CLEARSEC				;clear SECTOR
		SEC					;subtract 2 from current cluster
		LDA FCURCLUS
		SBC #2
		STA SECTOR
		LDA FCURCLUS+1
		SBC #0
		STA SECTOR+1
	
		LDA SECCLUS				;multiply by sec per clusters
CL2SEC2:	LSR
		BEQ CL2SEC1
		ASL SECTOR
		ROL SECTOR+1
		ROL SECTOR+2
		JMP CL2SEC2
	
CL2SEC1:	clc					;add Data-Base
		ldx #0
CL2SEC1A:	lda SECTOR, x
		adc DATBASE, x
		sta SECTOR, x
		inx
		cpx #4
		bcc CL2SEC1A
		
		clc					;add file current sector
		lda SECTOR
		adc FCURSEC
		sta SECTOR
		bcc CL2SEC1B		
		inc SECTOR+1
		bne CL2SEC1B
		inc SECTOR+2
		bne CL2SEC1B
		inc SECTOR+3
CL2SEC1B:	rts

;-------------------------------------------------------------------------------
; load AX with FCURCLUS
;-------------------------------------------------------------------------------
LOAXCCLUS:	ldx FCURCLUS
		lda FCURCLUS+1
		rts

;-------------------------------------------------------------------------------
; get next cluster from FCURCLUS and store in FCURCLUS
;-------------------------------------------------------------------------------
GETNEXTC:
		jsr LOAXCCLUS
		jsr GETCLUST

;-------------------------------------------------------------------------------
; load AX with FCURCLUS
;-------------------------------------------------------------------------------
STAXCCLUS:	stx FCURCLUS
		sta FCURCLUS+1
		rts

;-------------------------------------------------------------------------------
; load AX with NEWCLUS
;-------------------------------------------------------------------------------
LOAXNCLUS:	ldx NEWCLUS
		lda NEWCLUS+1
		rts


;-------------------------------------------------------------------------------
; GET FREE CLUSTER SEARCHING FROM
;
; X:CLUST:L
; A:CLUST:H
;
; AND INITIALIZE TO $FFFF
;
; FATPTRD	: POINTER TO PAGE OF FAT-BUF
; Y		: POINTS TO CLUSTER IN PAGE
; NEWCLUS	: HOLDS NEW CLUSTER-NO.
;-------------------------------------------------------------------------------
GETFCLUS:	stx NEWCLUS
		sta NEWCLUS+1
		
GETFCLUS2:	jsr LOAXNCLUS
		jsr GETCLUST

		tay					;high-byte zero?
		bne GETFCLUS1				;no, increment
		txa
		bne GETFCLUS1				;no, increment

		jsr LOAXNCLUS
		
	.IF PLATFORM = 4
		ldy #$0f
	.ELSE
		ldy #$ff
	.ENDIF
		sty NEWCLUS+1
		ldy #$ff
		sty NEWCLUS
		jmp PUTCLUST
		
GETFCLUS1:	inc NEWCLUS
		bne GETFCLUS2
		inc NEWCLUS+1
		jmp GETFCLUS2

;-------------------------------------------------------------------------------
; GET FREE CLUSTER
; INIT TO $FFFF
; CHAIN WITH CURCLUS
;-------------------------------------------------------------------------------
CHAINCLU:	jsr LOAXCCLUS				;load AX with FCURCLUS
		jsr GETFCLUS				;get free cluster in NEWCLUST
		jsr LOAXCCLUS				;load ax again run into PUTCLUST
		jsr PUTCLUST				;put NEWCLUST in current cluster
		jsr LOAXNCLUS
		jmp STAXCCLUS
;-------------------------------------------------------------------------------
; Put cluster-number in NEWCLUS to cluster pointed to by 
; X:	CLUST:L
; A:	CLUST:H
; even		odd
; 03 21		06 54
; Byte	Byte	Byte
; NN	NN	NN
; 21	43	65
;-------------------------------------------------------------------------------
PUTCLUST:
	.IF PLATFORM = 4

		jsr COMPFAT12
		
		lda #$FF				
		sta FDIRTY
		
		bcs PUTCODD

		lda NEWCLUS
		sta (FATPTRS), y
		jsr INCFATBYTE
		lda (FATPTRS), y
		and #240				;mask out lower nibble
		ora NEWCLUS+1				;or-in lower nibble
		sta (FATPTRS), y
		rts
		
PUTCODD:	lda (FATPTRS), y
		and #15					;mask out high nibble
		sta (FATPTRS), y
		lda NEWCLUS
		asl
		asl
		asl
		asl
		ora (FATPTRS), y			;or in low nibble 
		sta (FATPTRS), y			

		jsr INCFATBYTE
	
		ldx NEWCLUS
		lda NEWCLUS + 1
		asl NEWCLUS
		rol
		asl NEWCLUS
		rol
		asl NEWCLUS
		rol
		asl NEWCLUS
		rol
		sta (FATPTRS), y
		stx NEWCLUS
		rts
;-------------------------------------------------------------------------------
; Point FATPTRS to cluster in AX and read FAT sector if needed
; Carry holds even/odd cluster
; Y: 0
;-------------------------------------------------------------------------------
COMPFAT12:	tay		
		stx SECTOR
		sty SECTOR+1
		asl SECTOR
		rol SECTOR+1				;clust * 2
;		clc					;high byte always zero
		txa
		pha					;remember cluster low-byte
		adc SECTOR				;* 3		
		sta FATPTRS
		tya
		adc SECTOR+1
		lsr					;/ 2
		ror FATPTRS				;/ 2
		lsr
		clc
		adc FATBASE
		tax
		jsr CLEARSEC				;AY used
		stx SECTOR

		jsr READFAT

		clc
		lda FATPTRS+1
		and #1
		adc #>FATBUF
		sta FATPTRS+1
		
		ldy #0
		pla					;even / odd cluster
		lsr
		rts
	.ELSE
		jsr COMPFAT16
		lda NEWCLUST
		sta (FATPTRS),Y
		iny
		lda NEWCLUST+1
		sta (FATPTRS),Y
		rts

COMPFAT16:
		CLC
		STA SECTOR
		ADC FATBASE
		STA SECTOR
		LDA FATBASE+1
		ADC #0
		STA SECTOR+1
		LDA FATBASE+2
		ADC #0
		STA SECTOR+2
		LDA FATBASE+3
		ADC #0
		STA SECTOR+3	
		TXA					;save X
		PHA
		JSR READFAT
	
		LDA #<FATBUF
		STA FATPTRS
		LDA #>FATBUF
		STA FATPTRS+1
	
		PLA					;get former X
		ASL
		BCC COMPFAT16A
		INC FATPTRS+1
COMPFAT16A:	tay
		rts
	.ENDIF
;-------------------------------------------------------------------------------
; X:	CLUST:L
; A:	CLUST:H
; returns cluster-number stored at cluster AX in AX
;-------------------------------------------------------------------------------
GETCLUST:

	.IF PLATFORM = 4
;-------------------------------------------------------------------------------
; GETCLUST for FAT-12:
;	FATSEC = (A*256+X) * 3 / 2 (1.5)
;-------------------------------------------------------------------------------	
		jsr COMPFAT12
		bcs GETCODD
		
GETCEVEN:	lda (FATPTRS), y
		jsr INCFATBYTE
		tax
GETCEVEN1:	lda (FATPTRS), y
		and #15
		
GETCLUST1:
;		jsr PUTHEX
;		pha
;		txa
;		jsr PUTHEX
;		jsr NEWLINE
;		pla
		rts
		
GETCODD:	lda (FATPTRS),y 
		sta SECTOR
		jsr INCFATBYTE
		lda (FATPTRS),y
		lsr
		ror SECTOR
		lsr
		ror SECTOR
		lsr
		ror SECTOR
		lsr
		ror SECTOR
		ldx SECTOR
		rts
;		jmp GETCLUST1				;debug


INCFATBYTE:	inc FATPTRS
		bne INCFATBYTE1				;1ff?
		
		pha
		lda FATPTRS+1
		and #1
		beq INCFATBYTE2
		
		inc SECTOR
		jsr READFAT
		ldy #0
		sty FATPTRS
		lda #>FATBUF - 1
		sta FATPTRS + 1		
INCFATBYTE2:	pla
		inc FATPTRS+1
INCFATBYTE1:	rts

	.ELSE
;-------------------------------------------------------------------------------
; GETCLUST for FAT-16:
;-------------------------------------------------------------------------------
		jsr COMPFAT16
		LDA (FATPTRS),Y
		TAX
		INY
		LDA (FATPTRS),Y
		RTS
	.ENDIF


;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------
; DATA and FAT sector SIO routines 
;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------

	
;-------------------------------------------------------------------------------
; write FAT if FDIRTY <> 0
;-------------------------------------------------------------------------------
WRITEFAT:	LDA FDIRTY
		BEQ WRITEFA9

		LDX #<LASTFAT
		LDA #>LASTFAT
		JSR SETSEC				;set sector-number in floppy/drive
		BPL WRITEFA1
WRITEFA9:	RTS					;error

WRITEFA1:	JSR SETWRITE				;set DSTATS and DCOMND
		LDA #0					;reset dirty
		STA FDIRTY
		JMP RWFAT				;execute SIO command

;-------------------------------------------------------------------------------
; read a FAT sector. 
; if new sector to read, check if old one is dirty
; write old FAT sector if dirty
;-------------------------------------------------------------------------------
READFAT:	LDX #3
READFAT3:	LDA SECTOR,X				;compare SECTOR with LASTFAT
		CMP LASTFAT,X
		BNE READFAT2
		DEX
		BPL READFAT3				;if equal
		RTS					;sector already read, nothing to do

READFAT2:	JSR WRITEFAT				;write old sector if dirty

		LDX #3					;copy sector to LASTFAT
READFAT4:	LDA SECTOR,X
		STA LASTFAT,X
		DEX
		BPL READFAT4

		LDX #<SECTOR				;set sector to floppy/drive
		LDA #>SECTOR
		JSR SETSEC
		BPL READFAT1
		RTS					;error

READFAT1:	JSR SETREAD				;set DSTATS and DCOMND
RWFAT:		LDA #<FATBUF
		STA DBUFLO
		LDA #>FATBUF
		STA DBUFLO+1
		JMP RWSEC1

;-------------------------------------------------------------------------------
; write a Data sector if DDIRTY <> 0
;-------------------------------------------------------------------------------
WRITESEC:	LDA DDIRTY
		BEQ WRITESE9
		
		LDX #<LASTSEC
		LDA #>LASTSEC
		JSR SETSEC
		BPL WRITESE1
WRITESE9:	RTS

WRITESE1:	JSR SETWRITE
		LDA #0
		STA DDIRTY
		JMP RWSEC

;-------------------------------------------------------------------------------
; read a data sector, save old sector if dirty
;-------------------------------------------------------------------------------
READSEC:	LDX #3
READSEC3:	LDA SECTOR,X
		CMP LASTSEC,X
		BNE READSEC2
		DEX
		BPL READSEC3
		RTS

READSEC2:	JSR WRITESEC

		LDX #3					;set LASTSEC TO SECTOR
READSEC4:	LDA SECTOR,X
		STA LASTSEC,X
		DEX
		BPL READSEC4

READSECF:	LDX #0
		LDA FWBURST				;write Burst active?
		STX FWBURST		
		BEQ READSECF1				;no ->
		LDA ICBLHZ				;still $200 to read?
		CMP #2		
		BCC READSECF1				;no ->
		BNE READSECF2				;greater, no read
		LDA ICBLLZ				;we have substracted only $1ff
		BEQ READSECF1				;so, if lenght-LO = 0 then end is reached.
READSECF2:	RTS

READSECF1:	LDX #<SECTOR
		LDA #>SECTOR
		JSR SETSEC
		BPL READSEC1
		RTS

READSEC1:	JSR SETREAD

RWSEC:		LDA BUFADRL
		STA DBUFLO
		LDA BUFADRH
		STA DBUFLO+1

	.IF PLATFORM <= 1
RWSEC1:		LDX DBUFLO
		LDA DBUFLO+1
		CPY #$80		; $40 = read; $80 = write
		beq RWSEC2
		jmp readSector
RWSEC2:		jmp writeSector
	.ELSE	
RWSEC1:		LDA #0			; 512 bytes
		STA DBYTLO
		LDA #2
		STA DBYTLO+1
		JMP SIOV
	.ENDIF
	
SETREAD:
	.IF PLATFORM <= 1
		LDY #$40
	.ELSE
		LDA #$40
		STA DSTATS
		LDA #'R'
		STA DCOMND
	.ENDIF
		RTS

SETWRITE:
	.IF PLATFORM <= 1
		LDY #$80
	.ELSE
		LDA #$80
		STA DSTATS
		LDA #'P'
		STA DCOMND
	.ENDIF
		RTS
;
;
;
	.IF PLATFORM <= 1
SETSEC:		jmp setSector
	.ELSE	
SETSEC:		STX DBUFLO
		STA DBUFLO+1
		LDA #$31
		STA DDEVIC
		LDA #2
		STA DUNIT
	
		JSR SETWRITE
	
		LDA #4
		STA DBYTLO
		ASL
		STA DTIMLO
		LDA #0
		STA DBYTLO+1
		STA DAUX1
		STA DAUX2
		JMP SIOV

	.ENDIF

	
;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------
; debug and helper routines
;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------


;-------------------------------------------------------------------------------
; subtract 32-byte word: FATPTRD = FATPTRD - FATPTRS
;-------------------------------------------------------------------------------
SBC32:		LDY #0
		SEC
SBC32A:		LDA (FATPTRD),Y
		SBC (FATPTRS),Y
		STA (FATPTRD),Y
		INY
		CPY #4
		BCC SBC32A
		RTS

;-------------------------------------------------------------------------------
; FATPTRD - FATPTRS (compare)
;-------------------------------------------------------------------------------
CMP32:		LDY #3
CMP32A:		LDA (FATPTRD),Y
		CMP (FATPTRS),Y
		BNE CMP32B
		DEY
		BPL CMP32A	
CMP32B:		RTS

;-------------------------------------------------------------------------------
; copy from PTR in AY from FATPTRS to FATPTRD
;-------------------------------------------------------------------------------
COPY32:		STY FATPTRS
		STA FATPTRS+1
COPY32B:	LDY #3
COPY32A:	LDA (FATPTRS),Y
		STA (FATPTRD),Y
		DEY
		BPL COPY32A
		RTS

CLEARSEC:	LDY #<SECTOR				;Clear SECTOR via
		LDA #>SECTOR				;FATPTRD

;-------------------------------------------------------------------------------
; clear long-word AY -> FATPTRD
;-------------------------------------------------------------------------------
CLEAR32:	STY FATPTRD
		STA FATPTRD+1
		LDA #0
FILL32:		LDY #3
CL32A:		STA (FATPTRD),Y
		DEY
		BPL CL32A
		RTS

;-------------------------------------------------------------------------------
; print A hexadecimal, retain AXY
;-------------------------------------------------------------------------------
PUTHEX:		PHA
		TXA
		PHA
		TYA
		PHA
		
	.IF PLATFORM = 2 || PLATFORM = 4
		TSX
		LDA $103,X
	.ELSE
		LDA 3,s
	.ENDIF
		PHA
		LSR
		LSR
		LSR
		LSR
		JSR PUTNIB
		
		PLA
		AND #15
		JSR PUTNIB

		PLA
		TAY
		PLA
		TAX
		PLA
		RTS	

PUTNIB:		CMP #10
		BCC PUTNIB1
		ADC #6
PUTNIB1:	ADC #48
		JMP EOUTCH
		
PRINT:		PHA
		TXA
		PHA
		TYA
		PHA
	.IF PLATFORM = 2 || PLATFORM = 4
		TSX
		LDA $103,X
		CMP #$0A
		BNE PR1
		LDA #EOL
	.ELSE
		lda 3,s
	.ENDIF
PR1:		JSR EOUTCH
		PLA
		TAY
		PLA
		TAX
		PLA
		RTS

SPACE:		pha
		lda #32
		bne NEWLINE1
		
NEWLINE:	PHA
		LDA #EOL
NEWLINE1:	JSR PRINT
		PLA
		RTS
; 
;
;		
PRINTSTR:	TAY
		LDA FATPTRS
		PHA
		LDA FATPTRS+1
		PHA
		
		STX FATPTRS
		STY FATPTRS+1
		LDY #0
		BCC PRINTSTR2

		JSR NEWLINE

PRINTSTR2:	LDA (FATPTRS),Y
		BEQ PRINTSTR1
		JSR PRINT
		INY
		BNE PRINTSTR2	;do not print more than 256 chars
PRINTSTR1:	PLA
		STA FATPTRS+1
		PLA
		STA FATPTRS
		RTS

	.IF DEBUG = 1
PRINTINFO:
	.IF PLATFORM = 2 || PLATFORM = 4
		LDA #4					;key still pressed
		BIT SKSTAT			
		BNE PRINTINFO4				;no, leave
		LDA KBCODE				;help key?
		CMP #17			
		BEQ PRINTINFO6				;yes print
PRINTINFO4:	RTS
	.ENDIF
	
PRINTINFO6:	SEC
		LDX #<MSG0
		LDA #>MSG0
		JSR PRINTSTR
		LDA SECCLUS
		JSR PUTHEX

		SEC
		LDX #<MSG1
		LDA #>MSG1
		JSR PRINTSTR
		LDA RESSEC+1
		JSR PUTHEX
		LDA RESSEC
		JSR PUTHEX
		
		SEC
		LDX #<MSG2
		LDA #>MSG2
		JSR PRINTSTR
		LDA NUMFATS
		JSR PUTHEX

		SEC
		LDX #<MSG3
		LDA #>MSG3
		JSR PRINTSTR
		LDA NUMDIR+1
		JSR PUTHEX
		LDA NUMDIR
		JSR PUTHEX

		SEC
		LDX #<MSG4
		LDA #>MSG4
		JSR PRINTSTR
		LDA SECSFAT+1
		JSR PUTHEX
		LDA SECSFAT
		JSR PUTHEX
		
		SEC
		LDX #<MSG5
		LDA #>MSG5
		JSR PRINTSTR
		LDX #3
PRINTINFO7:	LDA SECTOR,X
		JSR PUTHEX
		DEX
		BPL PRINTINFO7

		SEC
		LDX #<MSG6
		LDA #>MSG6
		JSR PRINTSTR
		LDX #3
PRINTINFO1:	LDA FATBASE,X
		JSR PUTHEX
		DEX
		BPL PRINTINFO1
		
		SEC
		LDX #<MSG7
		LDA #>MSG7
		JSR PRINTSTR
		LDX #3
PRINTINFO2:	LDA DIRBASE,X
		JSR PUTHEX
		DEX
		BPL PRINTINFO2

		SEC
		LDX #<MSG8
		LDA #>MSG8
		JSR PRINTSTR
		LDX #3
PRINTINFO3:	LDA DATBASE,X
		JSR PUTHEX
		DEX
		BPL PRINTINFO3

	.IF PLATFORM = 2 || PLATFORM = 4
		LDA #4
PRINTINFO5:	BIT SKSTAT
		BEQ PRINTINFO5
	.ENDIF

		JMP NEWLINE

MSG0:		.byte "Sectors per cluster: $",0
MSG1:		.byte "Reserved sectors   : $",0
MSG2:		.byte "Number of FATs     : $",0
MSG3:		.byte "Number of root-entr: $",0
MSG4:		.byte "Sectors per FAT    : $",0
MSG5:		.byte "FAT-16 boot sector : $",0
MSG6:		.byte "FAT base           : $",0
MSG7:		.byte "DIR base           : $",0
MSG8:		.byte "DAT base           : $",0

	.ENDIF
	
;-------------------------------------------------------------------------------
; print character via Editor handler routine at $E406
;-------------------------------------------------------------------------------
EOUTCH:		TAX
		LDA EPB+1
		PHA
		LDA EPB
		PHA
		TXA
		RTS

;-------------------------------------------------------------------------------
; print SECTOR 
;-------------------------------------------------------------------------------
DUMPSEC:	pha
		txa
		pha
		ldx #3
DUMPSEC1:	lda SECTOR,x
		jsr PUTHEX
		dex
		bpl DUMPSEC1
		lda #EOL
		jsr PRINT
		pla
		tax
		pla
		rts
		
;-------------------------------------------------------------------------------
; DEBUG FATPTRS
;-------------------------------------------------------------------------------
;DUMPPTR:	LDA FATPTRS
;		JSR PUTHEX
;		LDA FATPTRS+1
;		JMP PUTHEX

;DUMPBUF:	jsr DUMP256
;		lda #4					;key still pressed
;DUMPBUF3:	bit SKSTAT			
;		bne DUMPBUF3				;no
;		inc DUMPBUF2+2
;		jsr DUMP256
;		dec DUMPBUF2+2
;		lda #4					;key still pressed
;DUMPBUF4:	bit SKSTAT			
;		bne DUMPBUF4				;no
;		rts
;		
;DUMP256:	ldx #0
;DUMPBUF1:	txa
;		and #15
;		bne DUMPBUF2
;		jsr NEWLINE
;DUMPBUF2:	lda BUFFER, x
;		jsr PUTHEX
;		inx
;		bne DUMPBUF1		
;		jmp NEWLINE

