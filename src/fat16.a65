.macro	cmp_icbalz_y
	.IF PLATFORM=0
		CMP [ICBALZ],Y
	.ELSE
		CMP (ICBALZ),Y
	.ENDIF
.endmacro

.macro	lda_icbalz_y
	.IF PLATFORM=0
		LDA [ICBALZ],Y
	.ELSE
		LDA (ICBALZ),Y
	.ENDIF
.endmacro

.macro	sta_icbalz_y
	.IF PLATFORM=0
		STA [ICBALZ],Y
	.ELSE
		STA (ICBALZ),Y
	.ENDIF
.endmacro

	.IF PLATFORM = 2
		.include "atarixl.inc"
		.include "fat16.inc"

EPB	=	$F2B0		;putbyte

		.ORG FATCODE
		
		JMP STARTUP	;0
		JMP PRINT	;3
		JMP PUTHEX	;6
		JMP PRINTSTR	;9
		JMP INITFAT
	.ENDIF
;
;
;
STARTUP:
	.IF PLATFORM = 2
		LDA #<INIT
		STA DOSINI
		LDA #>INIT
		STA DOSINI+1
	
		LDA #<DUPCODE
		STA DOSVEC
		LDA #>DUPCODE
		STA DOSVEC+1
	
;		LDA #25		; ATMAS-II patches		
;		STA $329F
;		STA $32BF
;		LDA #'B'
;		STA $2A11

INIT:		LDY #<HANDTAB
		LDA #>HANDTAB
		LDX #DRVCHAR
		JSR $E486
	
		LDA #<$2150
		STA MEMLO
		LDA #>$2150
		STA MEMLO+1
		
	.ELSE
;		ldx #0
;HAFIND:		lda HATABS,x
;		beq HAFOUND
;		cmp #DRVCHAR
;		beq HAFOUND
;		inx
;		inx
;		inx
;		cpx #MAXDEV
;		bcc HAFIND
;		rts
;HAFOUND:	lda #DRVCHAR
;		sta HATABS,x
;		lda #<HANDTAB
;		sta HATABS+1,x
;		lda #>HANDTAB
;		sta HATABS+2,x
	.ENDIF
		JMP INITFAT
		
HANDTAB:	.word OPENCHA-1		; open channel
		.word CLOSECHA-1	; close ...
		.word GETCHA-1		; get channel
		.word PUTCHA-1		; put channel
		.word STATUSCHA-1	; status of channel
		.word SPECIAL-1
		;jmp INITFAT
		rts
		.byte 0,0
		.byte 0

;
; 		DIRFILE	0=ALL, 1=FILES, 2=FREE DIR,
;			3=DIR
;
DIRSTART:	STA DIRFILE

		LDA DIRCLUS
		STA FSTRTCL
		LDA DIRCLUS+1
		STA FSTRTCL+1
		RTS
;
;
;
CHECKHAN:	LDY #1
		LDA #':'
		cmp_icbalz_y
;		CMP (ICBALZ),Y
		BEQ CHECKHA1
		INY
		cmp_icbalz_y
;		CMP (ICBALZ),Y
		BEQ CHECKHA1
ERR165:		JSR CLOSEFCB
		LDY #165
CHECKHA1:	RTS

;
;
;
GETFILE:	JSR DIRSTART
		JSR CHECKHAN
		BMI FINDFILEND

		INY
		JSR STR2RAW
		JSR OPENDIR		
		
FINDFIL1:	;lda #'F'
		;jsr PRINT
		
		LDY #0
FINDFIL3:
;		lda (FATPTRS),y
		LDA DIRTEXT,Y
;		jsr PRINT
		CMP #'?'
		BEQ FINDFIL2
		CMP (FATPTRS),Y
		BEQ FINDFIL2

NEXTFILE:	JSR NEXTDIR
		BCC FINDFIL1
		LDY #170
		RTS

FINDFIL2:	INY
		CPY #11
		BNE FINDFIL3
		LDY #1
FINDFILEND:	RTS
;
;
;

SAVEDIR:	LDA FATPTRS
		STA DIRPTR
		LDA FATPTRS+1
		STA DIRPTR+1
		LDX #3
SAVEDIR1:
		LDA SECTOR,X
		STA DIRSEC,X
		DEX
		BPL SAVEDIR1
		RTS

GETFCB:		STA FCBCODE
		LDX #0
GETFCB0:	LDA FCBCODE
		CMP FCB0,X
		BEQ GETFCB9
		TXA
		CLC
		ADC #64
		TAX
		BNE GETFCB0
		LDY #161		;TOO MANY
		RTS
GETFCB9:	LDY #1
		RTS			;OPEN FILES

CLOSEFCB:
		LDX FFCBOFF
		
;		stz DEVICNO
;		txa
;		jsr jprinthex
;		inc DEVICNO
		
		LDA #$FF
		STA FIOCBNR
		STA FCB0,X
		RTS


SETFCB:
;		stz DEVICNO
;		lda FIOCBNR
;		jsr jprinthex
;		lda ICIDNO
;		jsr jprinthex
;		inc DEVICNO

		LDA FIOCBNR		;RIGHT FCB
		CMP ICIDNO		;ACTIVE?
		BEQ SETFCB9		;YES

;		stz DEVICNO
;		lda #'*'
;		jsr jprinthex
;		inc DEVICNO
;		lda FIOCBNR
		
SWAPFCB:	CMP #$FF
		BEQ SWAPIN

		JSR SEC2FSEC

		LDY #0
		LDX FFCBOFF
SWAPFCB0:
		LDA FIOCBNR,Y
		STA FCB0,X
		INX
		INY
		CPY #FBLKEND-F+1
		BNE SWAPFCB0

SWAPIN:	
		LDA ICIDNO
		JSR GETFCB

		LDY #0
SWAPIN0:	LDA FCB0,X
		STA FIOCBNR,Y
		INX
		INY
		CPY #FBLKEND-F+1
		BNE SWAPIN0
	
		LDA ICCOMZ
		CMP #OPEN
		BEQ SETFCB9
	
		JSR FSEC2SEC
		JSR READSEC

SETFCB9:	RTS
;
;
;

OPENFCB:	LDA #$FF
		JSR GETFCB		;get FREE FCB
		BPL OPENFCB1
		RTS

OPENFCB1:	LDA ICIDNO
		STA FCB0,X

		LDA #0			;CLEAR FCB
		LDY #FBLKEND-F-1
OPENFCB0:
		STA FCB0+2,X
		INX
		DEY
		BNE OPENFCB0

		JSR SETFCB
		LDY #1
		RTS
;
;
;
VALIDNAM:
;		ldx #0
;v1:		lda DIRTEXT,x
;		jsr PUTHEX
;		lda #32
;		jsr PRINT
;		inx
;		cpx #11
;		bne v1
		
		LDX #10
VALIDNA1:	LDA DIRTEXT,X	;CARD
		CMP #'0'
		BCC VALIDNA3	;< 0? => check special chars
		CMP #'9'+1	;<= 9? 
		BCC VALIDNA2	;yes OK, next char
		CMP #'A'	;
		BCC VALIDNA3	;< A? => check special chars
		CMP #'Z'+1	;<= Z?
		BCC VALIDNA2	;yes OK, next char

VALIDNA3:	LDY VALIDS
VALIDNA4:	CMP VALIDCHA,Y
		BEQ VALIDNA2
		DEY
		BPL VALIDNA4
		RTS		;no valid char found, return N=1

VALIDCHA:	.byte " !#$%&()-_^|?"	;usually test without "?", so 12+1 bytes!

VALIDNA2:	DEX
		BPL VALIDNA1	;X=$FF
	
		LDA #32		;check if first char != space
		CMP DIRTEXT
		BEQ VALIDNA9	

;		CMP DIRTEXT+8
;		BEQ VALIDNA9

		INX		;X=0, make sure N=0		
		RTS
		
VALIDNA9:	DEX		;X=$FE, N=1
		RTS
;
;
;
DUMPPTR:	LDA FATPTRS
		JSR PUTHEX
		LDA FATPTRS+1
		JMP PUTHEX
;
;
;
INITDIR:	LDX #2
		LDA #0
		JSR GETFCLUS
		LDA NEWCLUS+1
		PHA
		LDA NEWCLUS
		PHA
	
		JSR FINDFDIR
		BCS INITDIR1
		PLA
		PLA		;NO FREE DIR
		PLA
		PLA
ERR169:		JSR CLOSEFCB
		LDY #169
		RTS

INITDIR1:
		LDY #0		;DIRNAME IN
		STY DIRFILE	;RESET DIRFILE
INITDIR2:
		LDA DIRTEXT,Y	;DIR ENTRY
		STA (FATPTRS),Y
		INY
		CPY #11
		BNE INITDIR2
	
		LDA #0		;INITIALIZE
INITDIR3:	STA (FATPTRS),Y	;REST
		INY
		CPY #32
		BNE INITDIR3
	
		STY DDIRTY	;PUT START
		LDY #DCLUS	;CLUSTER
		PLA		;INTO
		STA FCURCLUS
;		JSR PUTHEX
		STA (FATPTRS),Y	;DIR ENTRY
		INY
		PLA
		STA FCURCLUS+1
;		JSR PUTHEX
		STA (FATPTRS),Y
	
;		BRK
		RTS
		
;-------------------------------------------------------------------------------
; OPENCHA - Open Channel
; opens a FCB file control block for IO
;-------------------------------------------------------------------------------
OPENCHA:	JSR OPENFCB
		BMI OPENERR
;		RTS

;		LDA #$FF
;		STA FBURST

		LDA ICAX1Z
		AND #6
		CMP #6
		BNE OPENFILE

OPENDI:		JSR INITLSEC
		LDA #0
		STA HILF
		JMP GETFILE

OPENFILE:	LDA #1		;FILE THERE?
		JSR GETFILE
		BPL OPENEXIS	;YES

OPENNEW:	LDA ICAX1Z	;WRITE FILE?
		AND #1+4+8	;NO READ OR
		CMP #8		;APPEND
		BEQ OPENNEW3
OPEN170:	JSR CLOSEFCB
		LDY #170
OPENERR:	RTS

OPENNEW3:	JSR VALIDNAM
		BPL OPENNEW4	
		JMP ERR165

OPENNEW4:	JSR INITDIR

OPENEXIS:	JSR SAVEDIR
		LDX #5		;GET START
		LDY #DCLUS+5	;CLUSTER
OPENF1:		LDA (FATPTRS),Y	;AND FILELEN
		STA FSTRTCL,X	;FROM
		DEY		;DIRENTRY
		DEX
		BPL OPENF1
	
;		LDX #15		INITIALIZE
;		LDA #0		REST
;		STA FCURSEC
;OPENF2		STA FBYT2RD,X
;		DEX
;		BNE OPENF2
	
		LDA ICAX1Z	;IF READ
		AND #4		;FINISHED
		BNE OPENEND
	
;		LDA #'*'
;		JSR PRINT
		
		LDA ICAX1Z	;APPEND?
		AND #1		
		BEQ OPENWRIT	;NO
	
		LDX #3		;if append
OPENF3:		LDA FILELEN,X	;copy filelen
		STA FRPOS,X	;to file-read-pos
		DEX
		BPL OPENF3
		
		JMP OPENEND
	
OPENWRIT:
		LDY #$FF
		LDX FSTRTCL
		LDA FSTRTCL+1
		JSR DELCLUS
	
		LDA #0
		LDX #3
OPENW4:		STA FILELEN,X
		DEX
		BPL OPENW4
	
OPENEND:	JSR FSEEK
		LDY #1
		RTS
;
;
;
DELCLUS:	STY HILF

DELCLUS1:	CMP #$FF
		BNE DELCLUS2
		CPX #$FF
		BNE DELCLUS2
		RTS

DELCLUS2:	JSR GETCLUST
		PHA
		STY FDIRTY
		LDA HILF
		STA (FATPTRS),Y
		DEY
		STA (FATPTRS),Y
		PLA
	
		LDY HILF
		BEQ DELCLUS1
		INC HILF
		BEQ DELCLUS1
;
;
;
FINDFDIR:	LDA #2
		JSR DIRSTART
		JSR OPENDIR
		BCS FINDFDI1
FINDFDI2:
		JSR NEXTDIR
		BCC FINDFDI2
FINDFDI1:	RTS


STR2RAW:	LDX #10			;fill DIRTEXT
		LDA #32			;with spaces
S2R12:		STA DIRTEXT,X
		DEX
		BPL S2R12
	
		INX			;x = 0
		STX WILD

		LDA #'.'
		cmp_icbalz_y		;first char '.' (local dir)?
;		CMP (ICBALZ),Y
		BNE S2R1			;no, goto S2R1
		STA DIRTEXT			;save in first char of DIRTEXT
		INY					;examine next input char
		cmp_icbalz_y	
;		CMP (ICBALZ),Y		;also '.'?
		BNE S2R1			;no, goto S2R1
		STA DIRTEXT+1		;save in 2nd char of DIRTEXT
		INY					;Y += 2 ?
		INY
		RTS					;return

S2R1:		JSR S2R4		;call S2R4 until 8 chars processed
		BCS S2R2
		CPX #8
		BNE S2R1
S2R2:		CMP #EOL
		BEQ S2R6
		CMP #'/'
		BEQ S2R6
		LDX #8
		LDA #0
		STA WILD
S2R5:		JSR S2R4
		BCS S2R6
		CPX #11
		BNE S2R5
S2R6:		RTS

S2R4:		lda_icbalz_y
;		LDA (ICBALZ),Y
;		JSR PRINT
		BIT WILD		;wildcard active?
		BMI S2R7		;yes => S2R7
		
		INY
		CMP #'*'
		BNE S2R8
		DEC WILD
		BMI S2R7
S2R8:		CMP #'.'
		BNE S2R11
		CPX #8
		BCC S2R3
		CLC
		RTS
S2R11:		CMP #32			;is space?
		BEQ S2R3		;yes => next
		CMP #EOL
		BEQ S2R3
		CMP #'/'
		BEQ S2R3
		CMP #0
		BEQ S2R3
		BNE S2R9
S2R7:		LDA #'?'	
S2R9:		CMP #'a'
		BCC S2R10
		CMP #'z'+1
		BCS S2R10
		SBC #31
S2R10:		STA DIRTEXT,X		;normal character
		INX
		CLC
		RTS
S2R3:		INX
		SEC
		RTS

;
;
;
CLOSECHA:	JSR SETFCB

		LDA ICAX1Z
		AND #8
		BEQ CLOSE5
	
		JSR WRITEFAT
	
		LDX #3
CLOSE3:		LDA DIRSEC,X
		STA SECTOR,X
		DEX
		BPL CLOSE3
		JSR READSEC
	
		LDA DIRPTR
		STA FATPTRD
		LDA DIRPTR+1
		STA FATPTRD+1
	
		LDY #DLEN+3
		STY DDIRTY
		LDX #3
CLOSE4:		LDA FILELEN,X
;		JSR PUTHEX
		STA (FATPTRD),Y
		DEY
		DEX
		BPL CLOSE4
	
		JSR WRITESEC
	
CLOSE5:		JSR CLOSEFCB
		JMP OK

;
;
;
;
; PUTCHANNEL
;
PUTCHA:		STA CIOCHR	; save byte, could have been called via ICPTLZ

		JSR SETFCB

		LDA ICAX1Z	;UPDATE?
		AND #4		;CECK
		BEQ PUTCHA1	;FILELEN

PUTUPD:		JSR CHECKLEN	;file-pos less than filelen
		BCC PUTSLOW1	;yes, continue slow
PUTUPD1:	LDY #EOF	;signal error
		RTS
		
PUTCHA1:	LDA FATPTRS	;points to begin of page?
		BNE PUTSLOW
		LDA ICBLHZ	;at least 512 bytes To write?
		CMP #2
		BCC PUTSLOW
		LDA FATPTRS+1	;points to begin of buffer?
		CMP #>BUFFER
		BNE PUTSLOW
		LDA ICCOMZ	;binary put?
		CMP #PUTCHR
		BNE PUTSLOW

PUTFAST:	INC FWBURST
		LDY #0
PUTFAST1:	lda_icbalz_y
;		LDA (ICBALZ),Y
		STA BUFFER,Y
		INY
		BNE PUTFAST1
		INC ICBAHZ
PUTFAST2:	lda_icbalz_y
;		LDA (ICBALZ),Y
		STA BUFFER+$100,Y
		INY
		BNE PUTFAST2
		
		INY
		STY DDIRTY
		
		JSR INCRPOS2
		JSR INCRPOS2
		
		JSR INCFILELE2
		JSR INCFILELE2
		
		SEC
		LDA ICBLLZ
		SBC #$FF
		STA ICBLLZ
		LDA ICBLHZ
		SBC #1
		STA ICBLHZ
	.IF PLATFORM=0
		lda ICBLBZ
		sbc #0
		sta ICBLBZ
	.ENDIF
	
		CLC
		LDA ICBALZ
		ADC #$FF
		STA ICBALZ
		BCC PUTFAST3
		INC ICBAHZ
	.IF PLATFORM=0
		bne PUTFAST3
		inc ICBABZ
	.ENDIF

PUTFAST3:	JMP INCSEC	


PUTSLOW:	JSR INCFILELEN
PUTSLOW1:	LDA CIOCHR
		LDY #0
		STA (FATPTRS),Y
		INY
		STY DDIRTY
		
		JSR INCRPOS
		JMP INCPTR


INCFILELEN:	INC FILELEN
		BNE INCFILELEX
INCFILELE2:	INC FILELEN+1
		BNE INCFILELEX
		INC FILELEN+2
		BNE INCFILELEX
		INC FILELEN+3
INCFILELEX:	RTS
;
;
;
GETCHA:		JSR SETFCB
		LDX ICIDNO
		LDA ICAX1,X
		AND #2
		BNE GETDIR	;if Bit 1 set, dir access

GETBYTE:	JMP READBYTE

GETDIR:		;lda #'*'
		;jsr PRINT
		
		LDY HILF	;each call to GETDIR return just one byte
		BPL GETDIR6	;HILF counts the bytes in one dir entry
		;lda #'E'
		;jsr PRINT
		LDY #EOF
		RTS

GETDIR6:	BNE GETDIR1		; Y > 0, get next Dir

		LDA #32			; Y==0, init DIRLINE
		STA DIRLINE+8
		STA DIRLENG-1
		LDA #EOL
		STA DIREOF
	
		LDX #0			; copy DIR-info
GETDIR3:	LDA (FATPTRS),Y		; from sector-buffer
		STA DIRLINE,X		; into DIRLINE
		INX
		INY
		CPY #8			; 8.3 jump over " "
		BNE GETDIR3A
		INX
		
GETDIR3A:	CPY #11
		BNE GETDIR3
	
		LDY #DATTRIB
		LDA (FATPTRS),Y
		LDY #9
		AND #16			;ist directory?
		BEQ GETDLEN		;no, get file length

GETDTXT:	LDA DIRTXT,Y		;write "DIR" into
		STA DIRLENG,Y		;output length
		DEY			;pos 9 downto 0
		BPL GETDTXT
		BMI GETDIR5

GETDLEN:	LDA DECIMAL,Y
		STA DIRLENG,Y
		DEY
		BPL GETDLEN

GETDIR5:	LDY #0

GETDIR1:	;lda #'1'
		;jsr PRINT

		INC HILF
		LDA DIRLINE,Y		;if Y points to end in DIRLINE
		CMP #EOL		;read next dir entry
		BNE GETDIR7

		;lda #'2'
		;jsr PRINT
		
		JSR NEXTFILE
		BMI GETDIR9

		;lda #'D'
		;jsr PRINT
		
		LDY #0
		STY HILF
	
		LDA (FATPTRS),Y
		BNE GETDIR8

GETDIR9:	;lda #'9'
		;jsr PRINT

		DEY
		STY HILF		;NEG.

GETDIR8:	LDA #EOL

GETDIR7:	
	.IF PLATFORM > 0
		CMP #$7E		; "~" in "-"
		BNE GETDIR2
		LDA #'-'
	.ENDIF
GETDIR2:	;pha
		;lda #'#'
		;jsr PRINT
		;pla
		LDY #1
		RTS	

;
;	     1234567890123
;DIRLINE	.byte "             "
;DIRLENG	.byte "           "
;	.byte EOL
;		      "0123456789"
DIRTXT:		.byte "       DIR"
;
NEXTDIR:	;lda #'N'
		;jsr PRINT
		
		JSR READDIR
		BCS NEXTDIR9	;No further Dir, RTS

CHECKDIR:	
;		jsr NEWLINE
;		
;		ldy #0
;ch1:		lda (FATPTRS),Y
;		jsr PUTHEX
;		lda #' '
;		jsr PRINT
;		iny
;		cpy #16
;		bne ch1
;		
;		lda #' '
;		jsr PRINT
;		
;		ldy #0
;ch2:		lda (FATPTRS),Y
;		jsr PRINT
;		iny
;		cpy #8
;		bne ch2
;		jsr NEWLINE
		
		LDY #DNAME
		LDX DIRFILE
		LDA (FATPTRS),Y
	
		CMP #DEL	;ENTRY
		BNE NEXTDIR2	;DELETED?
		CPX #2		;AND
		BNE NEXTDIR	;DIRFILE=2
		SEC		;END C=1
		RTS

NEXTDIR2:	;lda #'2'
		;jsr PRINT
		
		LDY #DATTRIB
		LDA (FATPTRS),Y	;SKIP
		AND #8		;VOLUME
		BNE NEXTDIR	;LABEL
	
		LDA (FATPTRS),Y	;DIR?
		AND #16
		CPX #0		;DIRFILE<>0
		BEQ NEXTDIR3	;SKIP DIRS
		CPX #3
		BNE NEXTDIR4
		TAX
		BNE NEXTDIR3
		BEQ NEXTDIR
NEXTDIR4:
		TAX
		BNE NEXTDIR

NEXTDIR3:
;		LDY #0
;ND1:		LDA (FATPTRS),Y
;		JSR PRINT
;		INY
;		CPY #11
;		BNE ND1

		LDY #DLEN+3
		LDX #3
NEXTDIR1:
		LDA (FATPTRS),Y
		STA BIN,X
		DEY
		DEX
		BPL NEXTDIR1

		JSR BIN2DEC
;		lda #'B'
;		jsr PRINT		
		CLC
NEXTDIR9:	RTS

STATUSCHA:	JMP OK

SPECIAL:	LDA ICCOMZ
		LDX #(XFUNCEND-XFUNC)
SPECIAL2:	CMP XFUNC,X
		BEQ SPECIAL1
		DEX
		BPL SPECIAL2
		LDY #132
		RTS

SPECIAL1:	TXA
		ASL			;* 2
		STA HILF		;store found X-pos
		
		LDA ICCOMZ
		CMP #CFSTAT		;no OPENFCB for FSTAT
		BEQ SPECIAL3
		
		JSR OPENFCB
		BMI SPECIAL9		;no free FCB 
SPECIAL3:
;		LDA #$FF
;		STA FBURST
		LDX HILF		;reload X-pos
		LDA XJMPTAB+1,X		;jump to special-function
		PHA
		LDA XJMPTAB,X
		PHA
SPECIAL9:
		RTS

XFUNC:		.byte CDELETE
		.byte CCHADIR
		.byte CRENAME
		.byte CFSTAT
XFUNCEND:	.byte CCREDIR

	
XJMPTAB:	.word DELETE-1
		.word CHADIR-1
		.word RENAME-1
		.word FSTAT-1
		.word CREDIR-1
;
;
;

;
;
;
FSTAT:		;JSR SETFCB
;		BPL FSTAT2
;		RTS
		
FSTAT2:		LDY #5
		LDX #3
FSTAT1:		LDA FILELEN,X
		sta_icbalz_y
		DEY
		DEX
		BPL FSTAT1
		JMP OK
		
RENAME:		LDY #0
RENAME2:	lda_icbalz_y
;		LDA (ICBALZ),Y
		CMP #','
		BEQ RENAME1	;FOUND
		CMP #EOL
		BEQ RENAME8
		INY
		BNE RENAME2
RENAME8:	JMP ERR165

RENAME1:	INY
		JSR STR2RAW
		INC VALIDS
		JSR VALIDNAM
		PHP
		DEC VALIDS
		PLP	
		BPL RENAME4
		JMP ERR165

RENAME4:	LDX #10
RENAME3:	LDA DIRTEXT,X
		STA DIRRENA,X
		DEX
		BPL RENAME3

		LDA #1
		JSR GETFILE
		BMI RENAME9

RENAME7:	LDY #10
RENAME6:	LDA DIRRENA,Y
		CMP #'?'
		BEQ RENAME5

;		TAX
;		LDA (FATPTRS),Y
;		JSR PRINT
;		TXA

		STA (FATPTRS),Y
		STA DDIRTY
RENAME5:	DEY
		BPL RENAME6

		JSR NEXTFILE
		BPL RENAME7

RENAME9:	JMP DELETE8
;
;
;
CREDIR:		LDA #3
		JSR GETFILE
		BMI CREDIR1
		JMP OPEN170

CREDIR1:	JSR VALIDNAM
		BPL CREDIR3
		JMP ERR165

CREDIR3:	LDA #8
		STA ICAX1Z
		JSR INITDIR
	
		LDY #DATTRIB
		LDA #16		;ATTR-DIR
		STA (FATPTRS),Y
	
		LDA #0
		STA FCURSEC
		JSR CLU2SEC
				
CREDIR2:	JSR READSEC
		JSR CLEARBUF
		
		LDA FCURSEC
		BNE CREDIR5
	
		LDX #10
		LDA #32
CREDIR6:	STA BUFFER,X
		STA BUFFER+32,X
		DEX
		BPL CREDIR6
	
		LDA #'.'
		STA BUFFER
		STA BUFFER+32
		STA BUFFER+33
	
		LDA #16
		STA BUFFER+DATTRIB
		STA BUFFER+DATTRIB+32
	
		LDA FCURCLUS
		STA BUFFER+DCLUS
		LDA FCURCLUS+1
		STA BUFFER+DCLUS+1
	
		LDA DIRCLUS
		STA BUFFER+DCLUS+32
		LDA DIRCLUS+1
		STA BUFFER+DCLUS+33

CREDIR5:	INC FCURSEC
		LDA FCURSEC
		CMP SECCLUS
		BEQ CREDIR4
	
		JSR INCSECTO
		JMP CREDIR2

CREDIR4:	JSR WRITESEC
		JSR WRITEFAT
		JMP DELETE8
;
;
;
CHADIR:		JSR CHECKHAN
		BPL CHADIR2
		RTS

CHADIR2:	LDA DIRCLUS		;push DIRCLUS to stack
		PHA
		LDA DIRCLUS+1
		PHA
		INY
		lda_icbalz_y		;is '/' access from ROOT?
;		LDA (ICBALZ),Y
		CMP #'/'
		BNE CHADIR3		;no
		
		LDA #0			;set DIRCLUS to 0
		STA DIRCLUS
		STA DIRCLUS+1
		INY			;yes
		lda_icbalz_y		;get next char
;		LDA (ICBALZ),Y

CHADIR3:	CMP #EOL		;end of filename?
		BNE CHADIR3C		;no
		PLA			;otherwise pop DIRCLUS from stack
		PLA			;and exit
CHADIREND:	JMP DELETE9		;EXIT
		
CHADIR3C:	LDA #3			;read only dirs
		JSR DIRSTART		;copy DIRCLUS to FSTRTCL
		JSR STR2RAW	
		DEY
		STY SAVEY
		
		JSR OPENDIR		
		BCC CHADIR3A
CHADIR3B:	PLA
		STA DIRCLUS+1
		PLA
		STA DIRCLUS
		JMP OPEN170
CHADIR3A:	JSR FINDFIL1
		BMI CHADIR3B

CHADIR1:	LDY #DCLUS
		LDA (FATPTRS),Y
;		JSR PUTHEX
		STA DIRCLUS
		INY
		LDA (FATPTRS),Y
;		JSR PUTHEX
		STA DIRCLUS+1
;		JSR KBGETC
		
CHADIR4:	LDY SAVEY
CHADIR5:	lda_icbalz_y
;		LDA (ICBALZ),Y
		CMP #'/'
		BNE CHADIR3
		INY
		JMP CHADIR5
;
;
;
DELETE:		LDA #0
		JSR GETFILE
		BMI DELETE9

DELETE2:	LDA FATPTRS
		PHA
		LDA FATPTRS+1
		PHA
	
		LDY #DCLUS
		LDA (FATPTRS),Y
		TAX
		INY
		LDA (FATPTRS),Y
	
		LDY #0
		JSR DELCLUS
	
		PLA
		STA FATPTRS+1
		PLA
		STA FATPTRS
	
		LDY #DNAME
		LDA #$E5
		STA (FATPTRS),Y
		STA DDIRTY
	
		JSR NEXTFILE
		BPL DELETE2
	
		JSR WRITEFAT
DELETE8:	JSR WRITESEC

DELETE9:	JSR CLOSEFCB
;		JMP OK	

OK:		LDY #1
		CLC
NOTOK:		RTS

;IODUMP:		LDX ICIDNO
;		LDY #0
;IODUMP1:	LDA IOCB,X
;		JSR PUTHEX
;		INX
;		INY
;		CPY #16
;		BNE IODUMP1
;		LDA #$9B
;		JSR PRINT
;		LDY #EOF
;		RTS

;
;
;
OPENDIR:	LDA FSTRTCL
		STA FCURCLUS
		ORA FSTRTCL+1
		BNE OPENDIR1
	
		JSR CROOT
		JMP CHECKDIR

OPENDIR1:	LDA FSTRTCL+1
		STA FCURCLUS+1
		LDA #0
		LDX #3
OPENDIR2:	STA FVAR32,X
		DEX
		BPL OPENDIR2
		
;		LDA FSTRTCL
;		JSR PUTHEX
;		LDA FSTRTCL+1
;		JSR PUTHEX
;		JSR KBGETC
		
		JSR FSEEK1
		JMP CHECKDIR
;
;
;
READDIR:	;lda FATPTRS+1
		;jsr PUTHEX
		;lda FATPTRS
		;jsr PUTHEX
		;lda #' '
		;jsr PRINT

		LDY #DNAME
		LDA (FATPTRS),Y
		BEQ READDIR9

CDIR3:		CLC
		LDA FATPTRS
		ADC #32
		STA FATPTRS
		LDA FATPTRS+1
		ADC #0
		STA FATPTRS+1		
		CMP #(>BUFFER)+2
		BNE READDIR8		;OK => CLC,RTS

		LDA FSTRTCL
		ORA FSTRTCL+1
		BEQ CDIR4
	
		JSR INCSEC
	
;		LDA #'I
;		JSR PRINT
;		LDA FCURCLUS
;		JSR PUTHEX
;		LDA FCURCLUS+1
;		JSR PUTHEX
	
		LDA #$FF
		CMP FCURCLUS+1
		BNE READDIR8
		CMP FCURCLUS
		BNE READDIR8
		BEQ READDIR9
	
CDIR4:		JSR INCSECTO
		JSR CROOT2
READDIR8:	CLC
		RTS
READDIR9:	SEC
		RTS
;
;
;
CROOT:		LDX #3
CROOT1:		LDA DIRBASE,X
		STA SECTOR,X
		DEX
		BPL CROOT1
		INX
		STX FSTRTCL
		STX FSTRTCL+1
CROOT2:		LDA #<BUFFER
		STA FATPTRS
		LDA #>BUFFER
		STA FATPTRS+1
		JMP READSEC

CHECKLEN:
;		LDX #3
;CL1:		LDA FRPOS,X
;		JSR PUTHEX
;		DEX	
;		BPL CL1
;		LDA #EOL
;		JSR PRINT

		LDX #3
CHECKL2:	LDA FRPOS,X
		CMP FILELEN,X
		BCC CHECKL1
		DEX
		BPL CHECKL2
CHECKL1:
		RTS
;
;
;
READSLOW:
;		BIT FBURST	;burst off?
;		BMI READSLO1	;yes
;		DEC FBURST	;turn it off
		
;		JSR READSEC	;read sector
		
READSLO1:
;		LDA FATPTRS
;		JSR PUTHEX
;		LDA FATPTRS+1
;		JSR PUTHEX
		LDY #0
		LDA (FATPTRS),Y
		STA CIOCHR

		JSR INCRPOS
		JSR INCPTR

READBYT4:
;		JSR CHECKLEN
		LDA CIOCHR
;		BCS READBYT3
READBYT5:	LDY #1
		RTS
;READBYT3:	LDY #3
;		RTS

READBYTE:	JSR CHECKLEN
		BCC READBYT1
;		LDX ICIDNO
;		LDA FRPOS
;		JSR PUTHEX
;		STA ICBLLZ
;		STA ICBLL,X		
;		LDA FRPOS+1
;		JSR PUTHEX
;		STA ICBLHZ
;		STA ICBLH,X		

		LDY #EOF
		RTS
		
READBYT1:	LDY FATPTRS	;FATPTRS must point to begin of buffer, check LO-byte=0
		BNE READSLOW
;		TAY		;Y=0
		LDA ICBLHZ	;still >= 512 bytes to be read?
		CMP #2
		BCC READSLOW
		LDA ICCOMZ	;only GETCHAR allowed
		CMP #GETCHR
		BNE READSLOW
		LDA FATPTRS+1
		CMP #>BUFFER	;FATPTRS must point to begin of buffer
		BNE READSLOW
		
;		SEC		;still more than 512 bytes in the files available?
		LDA FILELEN	;filelen can't be greater then 64k
		SBC FRPOS
		LDA FILELEN+1
		SBC FRPOS+1
		CMP #2
		BCC READSLOW

;		JSR IODUMP

READFAST:
;		BIT FBURST	;Burst OFF?
;		BMI READFA2	;yes

;		STY FBURST	;Y=0
		
;		JSR INITLSEC
		
;		LDA ICBALZ
;		STA BUFADRL
;		LDA ICBAHZ
;		STA BUFADRH
;		JSR READSECF
;		LDA #<BUFFER
;		STA BUFADRL
;		LDA #>BUFFER
;		STA BUFADRH

;		INC ICBAHZ
;		LDY #$FF
;		LDA (ICBALZ),Y
;		JMP READFA3

READFA2:	LDA BUFFER,Y
		sta_icbalz_y
;		STA (ICBALZ),Y
		DEY
		BNE READFA2
		INC ICBAHZ
	.IF PLATFORM=0
		bne READFA1
		inc ICBABZ
	.ENDIF	
READFA1:	LDA BUFFER+$100,Y
		sta_icbalz_y
;		STA (ICBALZ),Y
		INY
		BNE READFA1

READFA3:	STA CIOCHR
		INC ICBAHZ
	.IF PLATFORM=0
		bne READFA3A
		inc ICBABZ
	.ENDIF	
	
READFA3A:
	.IF PLATFORM=0
		lda ICBLHZ
		bne READFA3B
		dec ICBLBZ
READFA3B:	dec ICBLHZ
		bne READFA3C
		dec ICBLBZ
READFA3C:	dec ICBLHZ
	.ELSE
		DEC ICBLHZ
		DEC ICBLHZ
	.ENDIF
		JSR INCRPOS2
		JSR INCRPOS2

		JSR INCSEC

		LDA ICBLHZ
		ORA ICBLLZ
	.IF PLATFORM=0
		ora ICBLBZ
	.ENDIF
		BEQ READFA4
		JMP READBYTE
		
READFA4:	INC ICBLLZ	;set buffer length to 1
		
		LDA ICBALZ	;decrement buffer address
		BNE READFA5
		
	.IF PLATFORM=0
		lda ICBAHZ
		bne READFA6
		dec ICBABZ
	.ENDIF
	
READFA6:	DEC ICBAHZ
READFA5:	DEC ICBALZ
		LDA CIOCHR
		JMP READBYT5	;exit success, Y=1

		
INCRPOS:	INC FRPOS
		BNE INCRPOS1
INCRPOS2:	INC FRPOS+1
		BNE INCRPOS1
		INC FRPOS+2
		BNE INCRPOS1
		INC FRPOS+3
INCRPOS1:	RTS


INCSECTO:	INC SECTOR
		BNE INCSECT1
		INC SECTOR+1
		BNE INCSECT1
		INC SECTOR+2
		BNE INCSECT1
		INC SECTOR+3
INCSECT1:	RTS
;
; convert 32 bit number to 10-byte text
;
BIN2DEC:	LDA #0			;clear 5-byte BCD (=10 nibbles)
		LDX #4
BIN2DEC1:	STA BCD,X
		DEX
		BPL BIN2DEC1

		LDX #32
		SED
BIN2DEC2:
		ASL BIN
		ROL BIN+1
		ROL BIN+2
		ROL BIN+3

		LDY #5
BIN2DEC3:
		LDA BCD-1,Y
		ADC BCD-1,Y
		STA BCD-1,Y
		DEY
		BNE BIN2DEC3
		DEX
		BNE BIN2DEC2
		
		CLD				
		STY NODISPL		;Y = 0
BIN2DEC4:
		LDA BCD,X
		LSR
		LSR
		LSR
		LSR
		JSR BIN2INC
		LDA BCD,X
		AND #15
		JSR BIN2INC
		INX
		CPX #5
		BNE BIN2DEC4
		RTS

BIN2INC:	BNE BIN2INC1		; no '0' => print it? 	
		BIT NODISPL		; print if nodisplay negativ
		BMI BIN2INC2	
		CPY #9			; print last digit in any case
		BEQ BIN2INC2
		LDA #32			; else print space
		BNE BIN2INC3

BIN2INC1:	DEC NODISPL
BIN2INC2:	EOR #'0'
BIN2INC3:	STA DECIMAL,Y
		INY
		RTS



INCPTR:		INC FATPTRS
		BNE INCPTR9
		INC FATPTRS+1
		LDA FATPTRS+1
		CMP #(>BUFFER)+2
		BNE INCPTR9
;
; READ NEXT SECTOR
;
INCSEC:		INC FCURSEC
		LDA FCURSEC
		CMP SECCLUS
		BEQ INCSEC3	;new cluster necessary!
	
		JSR INCSECTO	;just increment sector
		JMP INCPTR8	;reset buffer-ptr and read-sector

;
; READ NEXT CLUSTER
;
INCSEC3:	LDA #0
		STA FCURSEC
	
		LDX FCURCLUS
		LDA FCURCLUS+1
		JSR GETCLUST
	
		CMP #$FF
		BNE INCSEC4
		CPX #$FF
		BNE INCSEC4
	
		TAY
		LDA ICAX1Z	;READ ACCESS
		AND #8
		BEQ INCPTR10	;YES, do not acquire new cluster
	
;		LDA ICAX1Z
;		AND #4		;UPDATE?
;		BNE INCPTR10
	
		JSR CHAINCLU	;ONLY VALID

		LDA DIRFILE	;IF
		CMP #2		;GET FREE
		BNE INCSEC5	;DIR
	
		JSR CLU2SEC
	
		LDA SECCLUS
		STA FCURSEC

INCSEC2:	JSR READSEC
		JSR CLEARBUF
		JSR WRITESEC
	
		JSR INCSECTO
	
		DEC FCURSEC
		BNE INCSEC2
		BEQ INCSEC5
;
INCSEC4:	STX FCURCLUS
		STA FCURCLUS+1

INCSEC5:	JSR CLU2SEC

;		BIT FBURST	;burst active?
;		BPL INCPTR9	;yes ->

INCPTR8:	LDA #>BUFFER
		STA FATPTRS+1
		
		JMP READSEC

INCPTR10:
		STX FCURCLUS
		STY FCURCLUS+1
INCPTR9:	RTS
;
;
;
CLEARBUF:	LDA #0
		TAX
CLEARBU1:	STA BUFFER,X
		STA BUFFER+$100,X
		INX
		BNE CLEARBU1
		INC DDIRTY	
		RTS
;
; GET FREE CLUSTER
; INIT TO $FFFF
; CHAIN WITH CURCLUS
;
CHAINCLU:	LDX FCURCLUS
		LDA FCURCLUS+1
		JSR GETFCLUS
	
		JSR GETNEXTC
	
		STY FDIRTY	;Y IS ODD
		LDA NEWCLUS+1
		STA FCURCLUS+1
		STA (FATPTRS),Y
		DEY
		LDA NEWCLUS
		STA FCURCLUS
		STA (FATPTRS),Y
		RTS
;
;
;
FSEEK:		LDA FSTRTCL
		STA FCURCLUS
		LDA FSTRTCL+1
		STA FCURCLUS+1
	
		LDX #3
FSEEK2:		LDA FRPOS,X
		STA FVAR32,X
		DEX
		BPL FSEEK2
	
FSEEK1:		LDA #<FVAR32
		STA FATPTRD
		LDA #>FVAR32
		STA FATPTRD+1
		LDA #<BYTCLUS
		STA FATPTRS
		LDA #>BYTCLUS
		STA FATPTRS+1
	
		JSR CMP32	; FATPTRD < FATPTRS?
		BCC FSEEKS	; ja
	
		JSR SBC32
	
		LDA FCURCLUS
		PHA
		LDA FCURCLUS+1
		PHA
		JSR GETNEXTC
	
		CMP #$FF
		BNE FSEEK3
		CPX #$FF
		BNE FSEEK3
	
		PLA
		STA FCURCLUS+1
		PLA
		STA FCURCLUS
		JSR CHAINCLU
		JMP FSEEK1
	
FSEEK3:		PLA
		PLA
		JMP FSEEK1
		
DUMPSEC:	pha
		txa
		pha
		ldx #3
DUMPSEC1:	lda SECTOR,x
		jsr PUTHEX
		dex
		bpl DUMPSEC1
		lda #EOL
		jsr PRINT
		pla
		tax
		pla
		rts
;
; INSIDE CLUSTER
; SECTOR+OFFSET
;
FSEEKS:		LDA #0
		STA FCURSEC
		JSR CLU2SEC
	
;		jsr DUMPSEC
		
		LDA FVAR32+1
		LSR
		STA FCURSEC
		CLC
		ADC SECTOR+1
		STA SECTOR+1
		BCC FSEEKS1
		INC SECTOR+2
		BNE FSEEKS1
		INC SECTOR+3

;		jsr DUMPSEC

		
FSEEKS1:	LDA FVAR32+1
		AND #1
		CLC
		ADC #>BUFFER
		STA FATPTRS+1
		LDA FVAR32
		STA FATPTRS

;		jsr DUMPSEC
;		JSR SEC2FSEC

		JSR READSEC
;		JSR KBGETC
		RTS
;
SEC2FSEC:	
;		LDA #'S'
;		JSR PRINT

		LDX #3
SEC2FSE1:	LDA SECTOR,X
		STA FSECTOR,X
		DEX
		BPL SEC2FSE1

PTR2FPTR:	LDA FATPTRS
		STA FCURPTR
		LDA FATPTRS+1
		STA FCURPTR+1
		RTS
;
;
;
FSEC2SEC:	
;		LDA #'F'
;		JSR PRINT

		LDX #3
FSEC2SE1:	LDA FSECTOR,X
		STA SECTOR,X
		DEX
		BPL FSEC2SE1

FPTR2PTR:	LDA FCURPTR
		STA FATPTRS
		LDA FCURPTR+1
		STA FATPTRS+1
		RTS

;
; GET FREE CLUSTER SEARCHING FROM
;
; X:CLUST:L
; A:CLUST:H
;
; AND INITIALIZE TO $FFFF
;
; FATPTRD	: POINTER TO PAGE OF FAT-BUF
; Y	: POINTS TO CLUSTER IN PAGE
; NEWCLUS: HOLDS NEW CLUSTER-NO.
;
GETFCLUS:	STX NEWCLUS
		STA NEWCLUS+1
	
		JSR GETCLUST
		DEY
		STY FATPTRD
		LDA FATPTRS+1
		STA FATPTRD+1

GETFCLU3:	INC NEWCLUS
		BNE GETFCLU4
		INC NEWCLUS+1

GETFCLU4:	INC FATPTRD
		INC FATPTRD
		BNE GETFCLU1
		INC FATPTRD+1
		LDA FATPTRD+1
		CMP #(>FATBUF)+2
		BNE GETFCLU1

		JSR INCSECTO
	
		JSR READFAT
		LDA #>FATBUF
		STA FATPTRD+1
GETFCLU1:	LDY #0
		LDA (FATPTRD),Y
		INY
		ORA (FATPTRD),Y
		BNE GETFCLU3
		LDA #$FF
		STA FDIRTY
		STA (FATPTRD),Y
		DEY
		STA (FATPTRD),Y

;		LDA NEWCLUS
;		JSR PUTHEX
;		LDA NEWCLUS+1
;		JSR PUTHEX
		RTS
	
DIE:	.IF PLATFORM <= 1
		SEC
		RTS
	.ELSE
		BRK
	.ENDIF

INITLSEC:	LDA #$FF
		LDX #3
INITLSEC1:	STA LASTSEC,X
		DEX
		BPL INITLSEC1
		RTS
		
INITFSEC:	LDA #$FF
		LDX #3
INITFSEC1:	STA LASTFAT,X
		DEX
		BPL INITFSEC1
		RTS

INITFAT:	
;	.IF PLATFORM=1
;		jsr jSDInit
;	.ENDIF
		LDX #0
		TXA
VCLEAR:		STA V,X
		STA V+256,X
		DEX
		BNE VCLEAR

		JSR INITLSEC
		JSR INITFSEC

		STA FIOCBNR
		STA FCB0
		STA FCB1
		STA FCB2
		STA FCB3

		LDA #0		;initialise offset
VSET2:		TAX		;into FCB
		STA FCB0+1,X	; 0, 64, 128, 192
		CLC
		ADC #64
		BNE VSET2

		LDA #<BUFFER
		STA BUFADRL
		LDA #>BUFFER
		STA BUFADRH
		
		LDA #VALIDNA2-VALIDCHA-2
		STA VALIDS
	
;		LDA #'/
;		STA PATH
	
		JSR READBOOT
		BMI DIE
		CMP #3
		BNE DIE
		
		LDX #10
VCOPY:		LDA BUFFER+13,X
		STA V,X
		DEX
		BPL VCOPY
	
		LDA SECCLUS
		ASL
		STA BYTCLUS+1
	
		CLC
		LDA SECTOR
		ADC RESSEC
		STA FATBASE
		STA DIRBASE
		LDA SECTOR+1
		ADC RESSEC+1
		STA FATBASE+1
		STA DIRBASE+1
		BCC DIRBAS
		INC FATBASE+2
		INC DIRBASE+2
		BNE DIRBAS
		INC FATBASE+3
		INC DIRBASE+3
	
DIRBAS:		CLC
		LDX NUMFATS
DIRBAS2:	LDA DIRBASE
		ADC SECSFAT
		STA DIRBASE
		LDA DIRBASE+1
		ADC SECSFAT+1
		STA DIRBASE+1
		BCC DIRBAS1
		INC DIRBASE+2
		BNE DIRBAS1
		INC DIRBASE+3
DIRBAS1:	DEX
		BNE DIRBAS2
	
;		LDY #<DIRBASE	;COPY DIRBASE
;		LDA #>DIRBASE	;TO SECTOR
;		JSR COPY32
	
		LDA NUMDIR	;#ROOTDIRS
		STA DATBASE
		LDA NUMDIR+1
		STA DATBASE+1
	
		LDX #4
DATBAS1:	LSR DATBASE+1
		ROR DATBASE
		DEX
		BNE DATBAS1
	
		CLC
		LDA DATBASE
		ADC DIRBASE
		STA DATBASE
		LDA DATBASE+1
		ADC DIRBASE+1
		STA DATBASE+1

		
PRINTINFO:
	.IF PLATFORM = 2
		LDA #4
		BIT SKSTAT
		BNE PRINTINFO4
		LDA KBCODE
		CMP #17
		BEQ PRINTINFO6
PRINTINFO4:	RTS
	.ENDIF
	
PRINTINFO6:	SEC
		LDX #<MSG0
		LDA #>MSG0
		JSR PRINTSTR
		LDA SECCLUS
		JSR PUTHEX

		SEC
		LDX #<MSG1
		LDA #>MSG1
		JSR PRINTSTR
		LDA RESSEC+1
		JSR PUTHEX
		LDA RESSEC
		JSR PUTHEX
		
		SEC
		LDX #<MSG2
		LDA #>MSG2
		JSR PRINTSTR
		LDA NUMFATS
		JSR PUTHEX

		SEC
		LDX #<MSG3
		LDA #>MSG3
		JSR PRINTSTR
		LDA NUMDIR+1
		JSR PUTHEX
		LDA NUMDIR
		JSR PUTHEX

		SEC
		LDX #<MSG4
		LDA #>MSG4
		JSR PRINTSTR
		LDA SECSFAT+1
		JSR PUTHEX
		LDA SECSFAT
		JSR PUTHEX
		
		SEC
		LDX #<MSG5
		LDA #>MSG5
		JSR PRINTSTR
		LDX #3
PRINTINFO7:	LDA SECTOR,X
		JSR PUTHEX
		DEX
		BPL PRINTINFO7

		SEC
		LDX #<MSG6
		LDA #>MSG6
		JSR PRINTSTR
		LDX #3
PRINTINFO1:	LDA FATBASE,X
		JSR PUTHEX
		DEX
		BPL PRINTINFO1
		
		SEC
		LDX #<MSG7
		LDA #>MSG7
		JSR PRINTSTR
		LDX #3
PRINTINFO2:	LDA DIRBASE,X
		JSR PUTHEX
		DEX
		BPL PRINTINFO2

		SEC
		LDX #<MSG8
		LDA #>MSG8
		JSR PRINTSTR
		LDX #3
PRINTINFO3:	LDA DATBASE,X
		JSR PUTHEX
		DEX
		BPL PRINTINFO3

	.IF PLATFORM = 2
		LDA #4
PRINTINFO5:	BIT SKSTAT
		BEQ PRINTINFO5
	.ENDIF

		JSR NEWLINE
		CLC
		RTS
;
;
;
READBOOT:	
		LDY #<SECTOR	;Clear SECTOR via
		LDA #>SECTOR	;FATPTRD
		JSR CLEAR32

		JSR READSEC
		BMI READB2
	
		JSR CHECKFAT
		BEQ READB3
		CMP #3
		BNE READB2
READB1:		LDA #0
READB2:		RTS
	
READB3:		LDY #<(BUFFER+PART1)
		LDA #>(BUFFER+PART1)
		JSR COPY32
	
		JSR READSEC
		BMI READB2
;
; 0:FAT16 MBR
; 1:NO BOOTSEC/MBR
; 2:BOOTSEC, NO FAT16
; 3:BOOTSEC, FAT16
;
CHECKFAT:	LDA BUFFER+$1FE
		CMP #$55
		BEQ CHKFAT1
CHKFAT2:	LDA #1
		RTS
CHKFAT1:	LDA BUFFER+$1FF
		CMP #$AA
		BNE CHKFAT2
		LDA BUFFER+$1C2
		CMP #$0E
		BEQ CHKFAT3
		CMP #$06
		BEQ CHKFAT3
		LDA BUFFER+$36
		CMP #'F'
		BNE CHKFAT4
		LDA BUFFER+$37
		CMP #'A'
		BNE CHKFAT4
		LDA #3
		RTS
CHKFAT4:	LDA #2
		RTS
CHKFAT3:	LDA #0
		RTS

;
;
;		
CLU2SEC:	SEC
		LDA FCURCLUS
		SBC #2
		STA SECTOR
		LDA FCURCLUS+1
		SBC #0
		STA SECTOR+1
		LDA #0
		STA SECTOR+2
		STA SECTOR+3
	
		LDA SECCLUS
CL2SEC2:	LSR
		BEQ CL2SEC1
		ASL SECTOR
		ROL SECTOR+1
		ROL SECTOR+2
		JMP CL2SEC2
	
CL2SEC1:	CLC
		LDA SECTOR
		ADC DATBASE
		STA SECTOR
		LDA SECTOR+1
		ADC DATBASE+1
		STA SECTOR+1
		LDA SECTOR+2
		LDA SECTOR+2
		ADC DATBASE+2
		STA SECTOR+2
		LDA SECTOR+3
		ADC DATBASE+3
		STA SECTOR+3
	
		CLC
		LDA SECTOR
		ADC FCURSEC
		STA SECTOR
		LDA SECTOR+1
		ADC #0
		STA SECTOR+1
		LDA SECTOR+2
		ADC #0
		STA SECTOR+2
		LDA SECTOR+3
		ADC #0
		STA SECTOR+3
	
		RTS

GETNEXTC:
		LDX FCURCLUS
		LDA FCURCLUS+1
		JSR GETCLUST
		STX FCURCLUS
		STA FCURCLUS+1
		RTS
;
; X:CLUST:L
; A:CLUST:H
;
GETCLUST:	CLC
		STA SECTOR
		ADC FATBASE
		STA SECTOR
		LDA FATBASE+1
		ADC #0
		STA SECTOR+1
		LDA FATBASE+2
		ADC #0
		STA SECTOR+2
		LDA FATBASE+3
		ADC #0
		STA SECTOR+3	
		TXA
		PHA
		JSR READFAT
	
		LDA #<FATBUF
		STA FATPTRS
		LDA #>FATBUF
		STA FATPTRS+1
	
		PLA	
		ASL
		BCC GETCLUS1
		INC FATPTRS+1
GETCLUS1:	TAY
		LDA (FATPTRS),Y
		TAX
		INY
		LDA (FATPTRS),Y
		RTS
;
;
;
SBC32:		LDY #0
		LDX #3
		SEC
SBC32A:		LDA (FATPTRD),Y
		SBC (FATPTRS),Y
		STA (FATPTRD),Y
		INY
		DEX
		BPL SBC32A
		RTS
;
; FATPTRD - FATPTRS (compare)
;
CMP32:		LDY #3
CMP32A:		LDA (FATPTRD),Y
		CMP (FATPTRS),Y
		BNE CMP32B
		DEY
		BPL CMP32A	
CMP32B:		RTS

COPY32:		STY FATPTRS
		STA FATPTRS+1
COPY32B:	LDY #3
COPY32A:	LDA (FATPTRS),Y
		STA (FATPTRD),Y
		DEY
		BPL COPY32A
		RTS

CLEAR32:	STY FATPTRD
		STA FATPTRD+1
		LDY #3
		LDA #0
CL32A:		STA (FATPTRD),Y
		DEY
		BPL CL32A
		RTS

WRITEFAT:	LDA FDIRTY
		BEQ WRITEFA9

		LDX #<LASTFAT
		LDA #>LASTFAT
		JSR SETSEC
		BPL WRITEFA1
WRITEFA9:	RTS

WRITEFA1:	JSR SETWRITE
		LDA #0
		STA FDIRTY
		JMP RWFAT

READFAT:	LDX #3
READFAT3:	LDA SECTOR,X
		CMP LASTFAT,X
		BNE READFAT2
		DEX
		BPL READFAT3
		RTS

READFAT2:	JSR WRITEFAT

		LDX #3
READFAT4:	LDA SECTOR,X
		STA LASTFAT,X
		DEX
		BPL READFAT4

		LDX #<SECTOR
		LDA #>SECTOR
		JSR SETSEC
		BPL READFAT1
		RTS

READFAT1:	JSR SETREAD
RWFAT:		LDA #<FATBUF
		STA DBUFLO
		LDA #>FATBUF
		STA DBUFLO+1
		JMP RWSEC1
;
;
;
WRITESEC:	LDA DDIRTY
		BEQ WRITESE9
		
		LDX #<LASTSEC
		LDA #>LASTSEC
		JSR SETSEC
		BPL WRITESE1
WRITESE9:	RTS

WRITESE1:	JSR SETWRITE
		LDA #0
		STA DDIRTY
		JMP RWSEC

READSEC:	LDX #3
READSEC3:	LDA SECTOR,X
		CMP LASTSEC,X
		BNE READSEC2
		DEX
		BPL READSEC3
		RTS

READSEC2:	JSR WRITESEC

		LDX #3
READSEC4:	LDA SECTOR,X
		STA LASTSEC,X
		DEX
		BPL READSEC4

READSECF:	LDX #0
		LDA FWBURST		;write Burst active?
		STX FWBURST
		BEQ READSECF1		;no ->
		LDA ICBLHZ		;still $200 to read?
		CMP #2
		BCC READSECF1		;no ->
		BNE READSECF2		;greater, no read
		LDA ICBLLZ		;we have substracted only $1ff
		BEQ READSECF1		;so, if lenght-LO = 0 then end is reached.
READSECF2:	RTS

READSECF1:	LDX #<SECTOR
		LDA #>SECTOR
		JSR SETSEC
		BPL READSEC1
		RTS

READSEC1:	JSR SETREAD

RWSEC:		LDA BUFADRL
		STA DBUFLO
		LDA BUFADRH
		STA DBUFLO+1

	.IF PLATFORM <= 1
RWSEC1:		LDX DBUFLO
		LDA DBUFLO+1
		CPY #$80		; $40 = read; $80 = write
		beq RWSEC2
		jmp readSector
RWSEC2:		jmp writeSector
	.ELSE	
RWSEC1:		LDA #0			; 512 bytes
		STA DBYTLO
		LDA #2
		STA DBYTLO+1
		JMP SIOV
	.ENDIF
	
SETREAD:
	.IF PLATFORM <= 1
		LDY #$40
	.ELSE
		LDA #$40
		STA DSTATS
		LDA #'R'
		STA DCOMND
	.ENDIF
		RTS

SETWRITE:
	.IF PLATFORM <= 1
		LDY #$80
	.ELSE
		LDA #$80
		STA DSTATS
		LDA #'P'
		STA DCOMND
	.ENDIF
		RTS
;
;
;
	.IF PLATFORM <= 1
SETSEC:		jmp setSector
	.ELSE	
SETSEC:		STX DBUFLO
		STA DBUFLO+1
		LDA #$31
		STA DDEVIC
		LDA #1
		STA DUNIT
	
		JSR SETWRITE
	
		LDA #4
		STA DBYTLO
		STA DTIMLO
		LDA #0
		STA DBYTLO+1
		STA DAUX1
		STA DAUX2
		JMP SIOV

	.ENDIF
;
PUTHEX:		PHA
		TXA
		PHA
		TYA
		PHA
		
	.IF PLATFORM = 2
		TSX
		LDA $103,X
	.ELSE
		LDA 3,s
	.ENDIF
		PHA
		LSR
		LSR
		LSR
		LSR
		JSR PUTNIB
		
		PLA
		AND #15
		JSR PUTNIB

		PLA
		TAY
		PLA
		TAX
		PLA
		RTS	

PUTNIB:		CMP #10
		BCC PUTNIB1
		ADC #6
PUTNIB1:	ADC #48
		JMP EOUTCH
		
PRINT:		PHA
		TXA
		PHA
		TYA
		PHA
	.IF PLATFORM = 2
		TSX
		LDA $103,X
		CMP #$0A
		BNE PR1
		LDA #EOL
	.ELSE
		lda 3,s
	.ENDIF
PR1:		JSR EOUTCH
		PLA
		TAY
		PLA
		TAX
		PLA
		RTS

NEWLINE:	PHA
		LDA #EOL
		JSR PRINT
		PLA
		RTS
; 
;
;		
PRINTSTR:	TAY
		LDA FATPTRS
		PHA
		LDA FATPTRS+1
		PHA
		
		STX FATPTRS
		STY FATPTRS+1
		LDY #0
		BCC PRINTSTR2

		JSR NEWLINE

PRINTSTR2:	LDA (FATPTRS),Y
		BEQ PRINTSTR1
		JSR PRINT
		INY
		BNE PRINTSTR2	;do not print more than 256 chars
PRINTSTR1:	PLA
		STA FATPTRS+1
		PLA
		STA FATPTRS
		RTS


MSG0:		.byte "Sectors per cluster: $",0
MSG1:		.byte "Reserved sectors   : $",0
MSG2:		.byte "Number of FATs     : $",0
MSG3:		.byte "Number of root-entr: $",0
MSG4:		.byte "Sectors per FAT    : $",0
MSG5:		.byte "FAT-16 boot sector : $",0
MSG6:		.byte "FAT base           : $",0
MSG7:		.byte "DIR base           : $",0
MSG8:		.byte "DAT base           : $",0

EOUTCH:		TAX
		LDA #>(EPB-1)
		PHA
		LDA #<(EPB-1)
		PHA
		TXA
		RTS
